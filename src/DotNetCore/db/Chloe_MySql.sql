/*
Navicat MySQL Data Transfer

Source Server         : .
Source Server Version : 50703
Source Host           : localhost:3306
Source Database       : chloe

Target Server Type    : MYSQL
Target Server Version : 50703
File Encoding         : 65001

Date: 2016-12-11 15:06:58
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for sys_department
-- ----------------------------
DROP TABLE IF EXISTS `sys_department`;
CREATE TABLE `sys_department` (
  `Id` varchar(50) NOT NULL,
  `EnCode` varchar(50) DEFAULT NULL,
  `Name` varchar(50) DEFAULT NULL,
  `Manager` varchar(50) DEFAULT NULL,
  `Telephone` varchar(50) DEFAULT NULL,
  `MobilePhone` varchar(50) DEFAULT NULL,
  `WeChat` varchar(50) DEFAULT NULL,
  `Fax` varchar(50) DEFAULT NULL,
  `Email` varchar(50) DEFAULT NULL,
  `SortCode` int(11) DEFAULT NULL,
  `Description` varchar(500) DEFAULT NULL,
  `CreationTime` datetime NOT NULL,
  `CreateUserId` varchar(50) DEFAULT NULL,
  `IsDeleted` bit(1) NOT NULL,
  `DeletionTime` datetime DEFAULT NULL,
  `DeleteUserId` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of sys_department
-- ----------------------------
INSERT INTO `sys_department` VALUES ('111', '11', '2', '3', '4', '5', '6', '7', '8', '1', 'fhdf', '2016-10-10 00:00:00', null, '', '2016-10-29 13:52:41', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba');
INSERT INTO `sys_department` VALUES ('fd1df42f71e74a3a9541dabc85175f4e', '1', '技术部', '秦树新', '1346585136', '2', 'a', null, '1', null, '3', '2016-10-29 13:37:06', null, '\0', null, null);

-- ----------------------------
-- Table structure for sys_duty
-- ----------------------------
DROP TABLE IF EXISTS `sys_duty`;
CREATE TABLE `sys_duty` (
  `Id` varchar(50) NOT NULL,
  `Name` varchar(50) CHARACTER SET utf8 DEFAULT NULL,
  `DepartmentId` varchar(50) DEFAULT NULL,
  `SortCode` int(11) DEFAULT NULL,
  `CreationTime` datetime NOT NULL,
  `CreateUserId` varchar(50) DEFAULT NULL,
  `IsDeleted` bit(1) NOT NULL,
  `DeletionTime` datetime DEFAULT NULL,
  `DeleteUserId` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of sys_duty
-- ----------------------------
INSERT INTO `sys_duty` VALUES ('5824d5f07ab24933b06b85595bc3399b', '小开发', 'fd1df42f71e74a3a9541dabc85175f4e', '1', '2016-10-29 18:08:03', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', '\0', null, null);
INSERT INTO `sys_duty` VALUES ('5AB270C0-5D33-4203-A54F-4552699FDA3C', '开发部', '5AB270C0-5D33-4203-A54F-4552699FDA3C', null, '2016-10-10 00:00:00', null, '', '2016-10-29 18:08:15', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba');
INSERT INTO `sys_duty` VALUES ('80E10CD5-7591-40B8-A005-BCDE1B961E76', '测试部', 'fd1df42f71e74a3a9541dabc85175f4e', '1', '2016-10-10 00:00:00', null, '\0', null, null);

-- ----------------------------
-- Table structure for sys_log
-- ----------------------------
DROP TABLE IF EXISTS `sys_log`;
CREATE TABLE `sys_log` (
  `Id` int(11) NOT NULL AUTO_INCREMENT,
  `UserId` varchar(50) DEFAULT NULL,
  `RealName` varchar(50) DEFAULT NULL,
  `Type` int(11) NOT NULL,
  `IP` varchar(50) DEFAULT NULL,
  `IPAddress` varchar(50) DEFAULT NULL,
  `ModuleId` varchar(50) DEFAULT NULL,
  `ModuleName` varchar(50) DEFAULT NULL,
  `Result` bit(1) DEFAULT NULL,
  `Description` varchar(500) DEFAULT NULL,
  `CreationTime` datetime NOT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of sys_log
-- ----------------------------

-- ----------------------------
-- Table structure for sys_module
-- ----------------------------
DROP TABLE IF EXISTS `sys_module`;
CREATE TABLE `sys_module` (
  `Id` varchar(50) NOT NULL,
  `ParentId` varchar(50) DEFAULT NULL,
  `EnCode` varchar(50) DEFAULT NULL,
  `Name` varchar(50) DEFAULT NULL,
  `Icon` varchar(50) DEFAULT NULL,
  `UrlAddress` varchar(500) DEFAULT NULL,
  `OpenTarget` varchar(50) DEFAULT NULL,
  `IsMenu` bit(1) NOT NULL,
  `IsExpand` bit(1) NOT NULL,
  `IsPublic` bit(1) NOT NULL,
  `SortCode` int(11) DEFAULT NULL,
  `Description` varchar(500) DEFAULT NULL,
  `CreationTime` datetime NOT NULL,
  `CreateUserId` varchar(50) DEFAULT NULL,
  `LastModifyTime` datetime DEFAULT NULL,
  `LastModifyUserId` varchar(50) DEFAULT NULL,
  `IsEnabled` bit(1) NOT NULL,
  `IsDeleted` bit(1) NOT NULL,
  `DeleteTime` datetime DEFAULT NULL,
  `DeleteUserId` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of sys_module
-- ----------------------------
INSERT INTO `sys_module` VALUES ('252229DB-35CA-47AE-BDAE-C9903ED5BA7B', '462027E0-0848-41DD-BCC3-025DCAE65555', null, '部门管理', null, '/SystemManage/Department/Index', 'iframe', '', '\0', '\0', '1', null, '2016-10-20 12:34:59', null, '2016-11-29 22:58:59', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('38CA5A66-C993-4410-AF95-50489B22939C', '462027E0-0848-41DD-BCC3-025DCAE65555', null, '用户管理', null, '/SystemManage/User/Index', 'iframe', '', '\0', '\0', '4', null, '2016-10-20 12:34:59', null, '2016-07-14 16:22:47', null, '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('462027E0-0848-41DD-BCC3-025DCAE65555', null, null, '系统管理', 'fa fa-gears', null, 'expand', '\0', '', '\0', '1', null, '2016-10-20 12:34:59', null, '2016-12-10 23:48:06', '9f2ec0797d0f4fe290ab8b09a8302aba', '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('64A1C550-2C61-4A8C-833D-ACD0C012260F', '462027E0-0848-41DD-BCC3-025DCAE65555', null, '系统菜单', null, '/SystemManage/Module/Index', 'iframe', '', '\0', '\0', '7', '测试', '2016-10-20 12:34:59', null, '2016-07-27 10:50:09', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('6e5b779e849e459f957f3abef2a277e6', 'e7e1cfb2856d492faeaadc8e2962ac76', null, '文档管理', null, '/WikiManage/WikiDocument/Index', 'iframe', '', '\0', '\0', '1', null, '2016-11-29 23:08:12', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', '2016-11-29 23:08:29', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('73FD1267-79BA-4E23-A152-744AF73117E9', null, null, '系统安全', 'fa fa-desktop', null, 'expand', '\0', '', '\0', '3', null, '2016-10-20 12:34:59', null, '2016-07-22 15:46:56', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('91A6CFAD-B2F9-4294-BDAE-76DECF412C6C', '462027E0-0848-41DD-BCC3-025DCAE65555', null, '角色管理', '&nbsp;', '/SystemManage/Role/Index', 'iframe', '', '\0', '\0', '2', '&nbsp;', '2016-10-20 12:34:59', null, '2016-10-29 11:01:29', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('96EE855E-8CD2-47FC-A51D-127C131C9FB9', '73FD1267-79BA-4E23-A152-744AF73117E9', null, '系统日志', null, '/SystemSecurity/Log/Index', 'iframe', '', '\0', '\0', '3', null, '2016-10-20 12:34:59', null, '2016-07-20 16:16:19', null, '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('a3a4742d-ca39-42ec-b95a-8552a6fae579', '73FD1267-79BA-4E23-A152-744AF73117E9', null, '访问控制', null, '/SystemSecurity/FilterIP/Index', 'iframe', '', '\0', '\0', '2', null, '2016-10-20 12:34:59', null, '2016-07-20 16:16:03', null, '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('a7f1f2f73ac74b5ba8421ed9b3840439', 'e7e1cfb2856d492faeaadc8e2962ac76', null, '菜单管理', null, '/WikiManage/WikiMenu/Index', 'iframe', '', '\0', '\0', '2', null, '2016-11-29 23:09:15', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', null, null, '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('e72c75d0-3a69-41ad-b220-13c9a62ec788', '73FD1267-79BA-4E23-A152-744AF73117E9', null, '数据备份', null, '/SystemSecurity/DbBackup/Index', 'iframe', '', '\0', '\0', '1', null, '2016-10-20 12:34:59', null, '2016-07-20 16:15:41', null, '', '\0', null, null);
INSERT INTO `sys_module` VALUES ('e7e1cfb2856d492faeaadc8e2962ac76', null, null, 'Wiki管理', 'fa fa-gears', null, 'expand', '\0', '\0', '\0', '2', null, '2016-11-29 23:05:59', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', '2016-11-29 23:14:04', '9f2ec079-7d0f-4fe2-90ab-8b09a8302aba', '\0', '\0', null, null);
INSERT INTO `sys_module` VALUES ('F298F868-B689-4982-8C8B-9268CBF0308D', '462027E0-0848-41DD-BCC3-025DCAE65555', null, '岗位管理', null, '/SystemManage/Duty/Index', 'iframe', '', '\0', '\0', '3', null, '2016-10-20 12:34:59', null, '2016-07-14 16:22:41', null, '', '\0', null, null);

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role` (
  `Id` varchar(50) NOT NULL,
  `EnCode` varchar(50) DEFAULT NULL,
  `Name` varchar(50) DEFAULT NULL,
  `SortCode` int(11) DEFAULT NULL,
  `IsEnabled` bit(1) DEFAULT NULL,
  `Description` varchar(500) DEFAULT NULL,
  `CreationTime` datetime DEFAULT NULL,
  `CreateUserId` varchar(50) DEFAULT NULL,
  `LastModifyTime` datetime DEFAULT NULL,
  `LastModifyUserId` varchar(50) DEFAULT NULL,
  `IsDeleted` bit(1) DEFAULT NULL,
  `DeletionTime` datetime DEFAULT NULL,
  `DeleteUserId` varchar(500) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES ('2f0242ca3ed945b49599ce7da76a5a31', 'SysAdmin', '管理员', '1', '', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba', null, null, '\0', null, null);

-- ----------------------------
-- Table structure for sys_roleauthorize
-- ----------------------------
DROP TABLE IF EXISTS `sys_roleauthorize`;
CREATE TABLE `sys_roleauthorize` (
  `Id` varchar(50) NOT NULL,
  `ModuleId` varchar(50) DEFAULT NULL,
  `RoleId` varchar(50) DEFAULT NULL,
  `SortCode` int(11) DEFAULT NULL,
  `CreationTime` datetime NOT NULL,
  `CreateUserId` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of sys_roleauthorize
-- ----------------------------
INSERT INTO `sys_roleauthorize` VALUES ('05d12686d81b44be8a2c004aa35bc569', '252229DB-35CA-47AE-BDAE-C9903ED5BA7B', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('2978b449d9ea4baab779794ef849d4fd', '462027E0-0848-41DD-BCC3-025DCAE65555', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('535d0e4d87d74f27aa7afaa6cd4446c2', '38CA5A66-C993-4410-AF95-50489B22939C', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('66abb6ffe0364a1da4cfb482a55aa432', 'a3a4742d-ca39-42ec-b95a-8552a6fae579', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('797f135dc1ef49a3821a2abc74a0e4b4', 'e7e1cfb2856d492faeaadc8e2962ac76', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('98bb6d4e7d2a49e0abe6798b4a7c3d8e', '6e5b779e849e459f957f3abef2a277e6', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('9f770a38a62542e7a76572bdc9a2e00a', 'F298F868-B689-4982-8C8B-9268CBF0308D', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('a173c4d94b464170af33402d1aad85bc', '73FD1267-79BA-4E23-A152-744AF73117E9', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('a2ed7a83b3784a9f821f38196505f810', '96EE855E-8CD2-47FC-A51D-127C131C9FB9', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('d95823606d744f22a61bc436e3c75edc', 'e72c75d0-3a69-41ad-b220-13c9a62ec788', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('dc0f1c56158d4d5498429758f99f7be0', '91A6CFAD-B2F9-4294-BDAE-76DECF412C6C', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('e2311fa562664c55b5d8ad1340904979', 'a7f1f2f73ac74b5ba8421ed9b3840439', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');
INSERT INTO `sys_roleauthorize` VALUES ('f801d39a37d845339a28b5c176323f98', '64A1C550-2C61-4A8C-833D-ACD0C012260F', '2f0242ca3ed945b49599ce7da76a5a31', null, '2016-12-01 19:47:48', '9f2ec0797d0f4fe290ab8b09a8302aba');

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user` (
  `Id` varchar(50) NOT NULL,
  `UserName` varchar(50) DEFAULT NULL,
  `RealName` varchar(50) DEFAULT NULL,
  `HeadIcon` varchar(50) DEFAULT NULL,
  `Gender` int(11) DEFAULT NULL,
  `Birthday` datetime DEFAULT NULL,
  `MobilePhone` varchar(50) DEFAULT NULL,
  `Email` varchar(50) DEFAULT NULL,
  `WeChat` varchar(50) DEFAULT NULL,
  `DepartmentId` varchar(50) DEFAULT NULL,
  `RoleId` varchar(50) DEFAULT NULL,
  `DutyId` varchar(50) DEFAULT NULL,
  `IsEnabled` bit(1) NOT NULL,
  `Description` varchar(500) DEFAULT NULL,
  `CreationTime` datetime NOT NULL,
  `CreateUserId` varchar(50) DEFAULT NULL,
  `LastModifyTime` datetime DEFAULT NULL,
  `LastModifyUserId` varchar(50) DEFAULT NULL,
  `IsDeleted` bit(1) NOT NULL,
  `DeletionTime` datetime DEFAULT NULL,
  `DeleteUserId` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES ('9f2ec0797d0f4fe290ab8b09a8302aba', 'admin', '超级管理员', null, '1', '2016-11-29 00:00:00', '13548654896', 'so_while@163.com', 'so9527', '554C61CE-6AE0-44EB-B33D-A462BE7EB3E1', null, null, '', '系统内置账户a', '2016-07-20 00:00:00', null, null, null, '\0', null, null);

-- ----------------------------
-- Table structure for sys_userlogon
-- ----------------------------
DROP TABLE IF EXISTS `sys_userlogon`;
CREATE TABLE `sys_userlogon` (
  `Id` varchar(50) NOT NULL,
  `UserId` varchar(50) DEFAULT NULL,
  `UserPassword` varchar(50) DEFAULT NULL,
  `UserSecretkey` varchar(50) DEFAULT NULL,
  `PreviousVisitTime` datetime DEFAULT NULL,
  `LastVisitTime` datetime DEFAULT NULL,
  `LogOnCount` int(11) NOT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of sys_userlogon
-- ----------------------------
INSERT INTO `sys_userlogon` VALUES ('9f2ec0797d0f4fe290ab8b09a8302aba', '9f2ec0797d0f4fe290ab8b09a8302aba', 'd55f4123e31ad942196576df9afab607', 'dfa03f23aaa22372', '2016-12-10 10:55:45', '2016-12-10 23:47:19', '221');

-- ----------------------------
-- Table structure for wikidocument
-- ----------------------------
DROP TABLE IF EXISTS `wikidocument`;
CREATE TABLE `wikidocument` (
  `Id` varchar(100) NOT NULL,
  `Title` varchar(100) CHARACTER SET utf8 DEFAULT NULL,
  `Summary` varchar(500) CHARACTER SET utf8 DEFAULT NULL,
  `Tag` varchar(100) CHARACTER SET utf8 DEFAULT NULL,
  `HtmlContent` text,
  `MarkdownCode` text,
  `CreationTime` datetime NOT NULL,
  `UpdationTime` datetime DEFAULT NULL,
  `IsDeleted` int(11) NOT NULL,
  `DeletionTime` datetime DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of wikidocument
-- ----------------------------
INSERT INTO `wikidocument` VALUES ('3324756912431431680', 'IDbContext', 'IDbContext接口介绍', 'IDbContext', '<h1 id=\"h1-idbcontext\"><a name=\"IDbContext\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>IDbContext</h1><p>数据库上下文接口，包含创建查询对象（IQuery）、插入数据、更新数据和删除数据等基本操作。</p>\n<pre><code class=\"lang-csharp\">public interface IDbContext : IDisposable\n{\n    /* 获取关联的会话，通过该对象可以执行基本的 ado.net 操作（包括事务） */\n    IDbSession Session { get; }\n\n    /* 获取 IQuery 对象。主要数据查询的入口 */\n    IQuery&lt;TEntity&gt; Query&lt;TEntity&gt;() where TEntity : new();\n\n    /* 原生 sql 查询，支持存储过程 */\n    IEnumerable&lt;T&gt; SqlQuery&lt;T&gt;(string sql, params DbParam[] parameters) where T : new();\n    IEnumerable&lt;T&gt; SqlQuery&lt;T&gt;(string sql, CommandType cmdType, params DbParam[] parameters) where T : new();\n\n    /* 传入一个实体对象，插入数据。返回传入的实体对象（如果实体拥有自增列，会自动将自增值设置到实体相应的属性上） */\n    TEntity Insert&lt;TEntity&gt;(TEntity entity);\n\n    /* 传入一个 lambda 表达式树，向表插入指定的字段数据，返回主键值（如果主键是自增，则返回的就是自增值） */\n    object Insert&lt;TEntity&gt;(Expression&lt;Func&lt;TEntity&gt;&gt; body);\n\n    /* 传入一个实体，更新单条数据。返回受影响的行数 */\n    int Update&lt;TEntity&gt;(TEntity entity);\n\n    /* 传入 condition 条件和 body 表达式树，更新满足 condition 条件的指定的字段。返回受影响的行数 */\n    int Update&lt;TEntity&gt;(Expression&lt;Func&lt;TEntity, bool&gt;&gt; condition, Expression&lt;Func&lt;TEntity, TEntity&gt;&gt; body);\n\n    /* 传入一个实体，删除单条数据。返回受影响的行数 */\n    int Delete&lt;TEntity&gt;(TEntity entity);\n    /* 传入 condition 条件表达式树，删除满足 condition 条件的数据。返回受影响的行数 */\n    int Delete&lt;TEntity&gt;(Expression&lt;Func&lt;TEntity, bool&gt;&gt; condition);\n\n    /* 传入一个实体，让当前上下文跟踪该实体的属性变化。调用 &#39;int Update&lt;TEntity&gt;(TEntity entity)&#39; 方法更新数据时，只会更新实体被修改过的属性。 */\n    void TrackEntity(object entity);\n}\n</code></pre>\n', '# IDbContext\n数据库上下文接口，包含创建查询对象（IQuery）、插入数据、更新数据和删除数据等基本操作。\n```csharp\npublic interface IDbContext : IDisposable\n{\n    /* 获取关联的会话，通过该对象可以执行基本的 ado.net 操作（包括事务） */\n    IDbSession Session { get; }\n\n    /* 获取 IQuery 对象。主要数据查询的入口 */\n    IQuery<TEntity> Query<TEntity>() where TEntity : new();\n\n    /* 原生 sql 查询，支持存储过程 */\n    IEnumerable<T> SqlQuery<T>(string sql, params DbParam[] parameters) where T : new();\n    IEnumerable<T> SqlQuery<T>(string sql, CommandType cmdType, params DbParam[] parameters) where T : new();\n\n    /* 传入一个实体对象，插入数据。返回传入的实体对象（如果实体拥有自增列，会自动将自增值设置到实体相应的属性上） */\n    TEntity Insert<TEntity>(TEntity entity);\n\n    /* 传入一个 lambda 表达式树，向表插入指定的字段数据，返回主键值（如果主键是自增，则返回的就是自增值） */\n    object Insert<TEntity>(Expression<Func<TEntity>> body);\n\n    /* 传入一个实体，更新单条数据。返回受影响的行数 */\n    int Update<TEntity>(TEntity entity);\n\n    /* 传入 condition 条件和 body 表达式树，更新满足 condition 条件的指定的字段。返回受影响的行数 */\n    int Update<TEntity>(Expression<Func<TEntity, bool>> condition, Expression<Func<TEntity, TEntity>> body);\n\n    /* 传入一个实体，删除单条数据。返回受影响的行数 */\n    int Delete<TEntity>(TEntity entity);\n    /* 传入 condition 条件表达式树，删除满足 condition 条件的数据。返回受影响的行数 */\n    int Delete<TEntity>(Expression<Func<TEntity, bool>> condition);\n\n    /* 传入一个实体，让当前上下文跟踪该实体的属性变化。调用 \'int Update<TEntity>(TEntity entity)\' 方法更新数据时，只会更新实体被修改过的属性。 */\n    void TrackEntity(object entity);\n}\n```\n', '2016-12-01 13:57:00', '2016-12-03 23:04:11', '0', null);
INSERT INTO `wikidocument` VALUES ('3324760360224817152', 'IQuery', 'IQuery 接口介绍', 'IQuery', '<h1 id=\"h1-iquery\"><a name=\"IQuery\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>IQuery</h1><p>强类型对象化查询接口，包含条件筛选、排序、分组查询、聚合查询、多表连接查询和分页等功能。</p>\n<pre><code class=\"lang-csharp\">public interface IQuery&lt;T&gt;\n{\n    /* 在上下文中跟踪实体 */\n    IQuery&lt;T&gt; AsTracking();\n    IEnumerable&lt;T&gt; AsEnumerable();\n    /* 投影选择数据（支持匿名类型） */\n    IQuery&lt;TResult&gt; Select&lt;TResult&gt;(Expression&lt;Func&lt;T, TResult&gt;&gt; selector);\n\n    /* 筛选条件，和 linq 一样的用法 */\n    IQuery&lt;T&gt; Where(Expression&lt;Func&lt;T, bool&gt;&gt; predicate);\n\n    /* 排序，和 linq 一样的用法 */\n    IOrderedQuery&lt;T&gt; OrderBy&lt;K&gt;(Expression&lt;Func&lt;T, K&gt;&gt; keySelector);\n    IOrderedQuery&lt;T&gt; OrderByDesc&lt;K&gt;(Expression&lt;Func&lt;T, K&gt;&gt; keySelector);\n\n    IQuery&lt;T&gt; Skip(int count);\n    IQuery&lt;T&gt; Take(int count);\n    /* 分页 */\n    IQuery&lt;T&gt; TakePage(int pageNumber, int pageSize);\n\n    /* 获取分组查询对象 */\n    IGroupingQuery&lt;T&gt; GroupBy&lt;K&gt;(Expression&lt;Func&lt;T, K&gt;&gt; keySelector);\n\n    /* 多表内连接 */\n    IJoiningQuery&lt;T, TSource&gt; InnerJoin&lt;TSource&gt;(IQuery&lt;TSource&gt; q, Expression&lt;Func&lt;T, TSource, bool&gt;&gt; on);\n    /* 多表左连接 */\n    IJoiningQuery&lt;T, TSource&gt; LeftJoin&lt;TSource&gt;(IQuery&lt;TSource&gt; q, Expression&lt;Func&lt;T, TSource, bool&gt;&gt; on);\n    /* 多表右连接 */\n    IJoiningQuery&lt;T, TSource&gt; RightJoin&lt;TSource&gt;(IQuery&lt;TSource&gt; q, Expression&lt;Func&lt;T, TSource, bool&gt;&gt; on);\n    /* 多表全连接 */\n    IJoiningQuery&lt;T, TSource&gt; FullJoin&lt;TSource&gt;(IQuery&lt;TSource&gt; q, Expression&lt;Func&lt;T, TSource, bool&gt;&gt; on);\n\n    T First();\n    T First(Expression&lt;Func&lt;T, bool&gt;&gt; predicate);\n    T FirstOrDefault();\n    T FirstOrDefault(Expression&lt;Func&lt;T, bool&gt;&gt; predicate);\n\n    /* 查询数据，返回 List 集合 */\n    List&lt;T&gt; ToList();\n\n    /* 判断满足条件的数据是否存在 */\n    bool Any();\n    bool Any(Expression&lt;Func&lt;T, bool&gt;&gt; predicate);\n\n    /* 获取总条数 */\n    int Count();\n    long LongCount();\n\n    /* 求最大值和最小值 */\n    TResult Max&lt;TResult&gt;(Expression&lt;Func&lt;T, TResult&gt;&gt; selector);\n    TResult Min&lt;TResult&gt;(Expression&lt;Func&lt;T, TResult&gt;&gt; selector);\n\n    /* 求和 */\n    int Sum(Expression&lt;Func&lt;T, int&gt;&gt; selector);\n    int? Sum(Expression&lt;Func&lt;T, int?&gt;&gt; selector);\n    long Sum(Expression&lt;Func&lt;T, long&gt;&gt; selector);\n    long? Sum(Expression&lt;Func&lt;T, long?&gt;&gt; selector);\n    decimal Sum(Expression&lt;Func&lt;T, decimal&gt;&gt; selector);\n    decimal? Sum(Expression&lt;Func&lt;T, decimal?&gt;&gt; selector);\n    double Sum(Expression&lt;Func&lt;T, double&gt;&gt; selector);\n    double? Sum(Expression&lt;Func&lt;T, double?&gt;&gt; selector);\n    float Sum(Expression&lt;Func&lt;T, float&gt;&gt; selector);\n    float? Sum(Expression&lt;Func&lt;T, float?&gt;&gt; selector);\n\n    /* 求平均值 */\n    double Average(Expression&lt;Func&lt;T, int&gt;&gt; selector);\n    double? Average(Expression&lt;Func&lt;T, int?&gt;&gt; selector);\n    double Average(Expression&lt;Func&lt;T, long&gt;&gt; selector);\n    double? Average(Expression&lt;Func&lt;T, long?&gt;&gt; selector);\n    decimal Average(Expression&lt;Func&lt;T, decimal&gt;&gt; selector);\n    decimal? Average(Expression&lt;Func&lt;T, decimal?&gt;&gt; selector);\n    double Average(Expression&lt;Func&lt;T, double&gt;&gt; selector);\n    double? Average(Expression&lt;Func&lt;T, double?&gt;&gt; selector);\n    float Average(Expression&lt;Func&lt;T, float&gt;&gt; selector);\n    float? Average(Expression&lt;Func&lt;T, float?&gt;&gt; selector);\n}\n</code></pre>\n', '# IQuery\n强类型对象化查询接口，包含条件筛选、排序、分组查询、聚合查询、多表连接查询和分页等功能。\n```csharp\npublic interface IQuery<T>\n{\n    /* 在上下文中跟踪实体 */\n    IQuery<T> AsTracking();\n    IEnumerable<T> AsEnumerable();\n    /* 投影选择数据（支持匿名类型） */\n    IQuery<TResult> Select<TResult>(Expression<Func<T, TResult>> selector);\n\n    /* 筛选条件，和 linq 一样的用法 */\n    IQuery<T> Where(Expression<Func<T, bool>> predicate);\n\n    /* 排序，和 linq 一样的用法 */\n    IOrderedQuery<T> OrderBy<K>(Expression<Func<T, K>> keySelector);\n    IOrderedQuery<T> OrderByDesc<K>(Expression<Func<T, K>> keySelector);\n\n    IQuery<T> Skip(int count);\n    IQuery<T> Take(int count);\n    /* 分页 */\n    IQuery<T> TakePage(int pageNumber, int pageSize);\n\n    /* 获取分组查询对象 */\n    IGroupingQuery<T> GroupBy<K>(Expression<Func<T, K>> keySelector);\n\n    /* 多表内连接 */\n    IJoiningQuery<T, TSource> InnerJoin<TSource>(IQuery<TSource> q, Expression<Func<T, TSource, bool>> on);\n    /* 多表左连接 */\n    IJoiningQuery<T, TSource> LeftJoin<TSource>(IQuery<TSource> q, Expression<Func<T, TSource, bool>> on);\n    /* 多表右连接 */\n    IJoiningQuery<T, TSource> RightJoin<TSource>(IQuery<TSource> q, Expression<Func<T, TSource, bool>> on);\n    /* 多表全连接 */\n    IJoiningQuery<T, TSource> FullJoin<TSource>(IQuery<TSource> q, Expression<Func<T, TSource, bool>> on);\n\n    T First();\n    T First(Expression<Func<T, bool>> predicate);\n    T FirstOrDefault();\n    T FirstOrDefault(Expression<Func<T, bool>> predicate);\n\n    /* 查询数据，返回 List 集合 */\n    List<T> ToList();\n\n    /* 判断满足条件的数据是否存在 */\n    bool Any();\n    bool Any(Expression<Func<T, bool>> predicate);\n\n    /* 获取总条数 */\n    int Count();\n    long LongCount();\n\n    /* 求最大值和最小值 */\n    TResult Max<TResult>(Expression<Func<T, TResult>> selector);\n    TResult Min<TResult>(Expression<Func<T, TResult>> selector);\n\n    /* 求和 */\n    int Sum(Expression<Func<T, int>> selector);\n    int? Sum(Expression<Func<T, int?>> selector);\n    long Sum(Expression<Func<T, long>> selector);\n    long? Sum(Expression<Func<T, long?>> selector);\n    decimal Sum(Expression<Func<T, decimal>> selector);\n    decimal? Sum(Expression<Func<T, decimal?>> selector);\n    double Sum(Expression<Func<T, double>> selector);\n    double? Sum(Expression<Func<T, double?>> selector);\n    float Sum(Expression<Func<T, float>> selector);\n    float? Sum(Expression<Func<T, float?>> selector);\n\n    /* 求平均值 */\n    double Average(Expression<Func<T, int>> selector);\n    double? Average(Expression<Func<T, int?>> selector);\n    double Average(Expression<Func<T, long>> selector);\n    double? Average(Expression<Func<T, long?>> selector);\n    decimal Average(Expression<Func<T, decimal>> selector);\n    decimal? Average(Expression<Func<T, decimal?>> selector);\n    double Average(Expression<Func<T, double>> selector);\n    double? Average(Expression<Func<T, double?>> selector);\n    float Average(Expression<Func<T, float>> selector);\n    float? Average(Expression<Func<T, float?>> selector);\n}\n```', '2016-12-01 14:10:42', '2016-12-09 14:09:03', '0', null);
INSERT INTO `wikidocument` VALUES ('3324761124187930624', 'IOrderedQuery', 'IOrderedQuery 接口介绍', 'IOrderedQuery', '<h1 id=\"h1-iorderedquery\"><a name=\"IOrderedQuery\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>IOrderedQuery</h1><p>支持多个排序字段接口。</p>\n<pre><code class=\"lang-csharp\">public interface IOrderedQuery&lt;T&gt; : IQuery&lt;T&gt;\n{\n    IOrderedQuery&lt;T&gt; ThenBy&lt;K&gt;(Expression&lt;Func&lt;T, K&gt;&gt; keySelector);\n    IOrderedQuery&lt;T&gt; ThenByDesc&lt;K&gt;(Expression&lt;Func&lt;T, K&gt;&gt; keySelector);\n}\n</code></pre>\n', '# IOrderedQuery\n支持多个排序字段接口。\n```csharp\npublic interface IOrderedQuery<T> : IQuery<T>\n{\n    IOrderedQuery<T> ThenBy<K>(Expression<Func<T, K>> keySelector);\n    IOrderedQuery<T> ThenByDesc<K>(Expression<Func<T, K>> keySelector);\n}\n```', '2016-12-01 14:13:44', '2016-12-09 14:09:11', '0', null);
INSERT INTO `wikidocument` VALUES ('3324765409034371072', 'IGroupingQuery', 'IGroupingQuery 接口介绍', 'IGroupingQuery', '<h1 id=\"h1-igroupingquery\"><a name=\"IGroupingQuery\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>IGroupingQuery</h1><p>分组查询接口。</p>\n<pre><code class=\"lang-csharp\">public interface IGroupingQuery&lt;T&gt;\n{\n    /* 支持多个字段分组，即 group by Age，Id... */\n    IGroupingQuery&lt;T&gt; ThenBy&lt;K&gt;(Expression&lt;Func&lt;T, K&gt;&gt; keySelector);\n\n    /* 增加 having 条件： select Age from Users group by Age having count(Age)&gt;1  */\n    IGroupingQuery&lt;T&gt; Having(Expression&lt;Func&lt;T, bool&gt;&gt; predicate);\n\n    /* select 数据：g.Select(a =&gt; new { a.Age, Count = AggregateFunctions.Count() }) --&gt; select Age,COUNT(1) from Users group by Age having count(Age)&gt;1  */\n    IQuery&lt;TResult&gt; Select&lt;TResult&gt;(Expression&lt;Func&lt;T, TResult&gt;&gt; selector);\n}\n</code></pre>\n', '# IGroupingQuery\n分组查询接口。\n```csharp\npublic interface IGroupingQuery<T>\n{\n    /* 支持多个字段分组，即 group by Age，Id... */\n    IGroupingQuery<T> ThenBy<K>(Expression<Func<T, K>> keySelector);\n\n    /* 增加 having 条件： select Age from Users group by Age having count(Age)>1  */\n    IGroupingQuery<T> Having(Expression<Func<T, bool>> predicate);\n\n    /* select 数据：g.Select(a => new { a.Age, Count = AggregateFunctions.Count() }) --> select Age,COUNT(1) from Users group by Age having count(Age)>1  */\n    IQuery<TResult> Select<TResult>(Expression<Func<T, TResult>> selector);\n}\n```', '2016-12-01 14:30:46', '2016-12-09 14:09:19', '0', null);
INSERT INTO `wikidocument` VALUES ('3324766621741875200', 'IJoiningQuery', 'IJoiningQuery 接口介绍', 'IJoiningQuery', '<h1 id=\"h1-ijoiningquery\"><a name=\"IJoiningQuery\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>IJoiningQuery</h1><p>该接口用于基本的多表连接操作。</p>\n<pre><code class=\"lang-csharp\">public interface IJoiningQuery&lt;T1, T2&gt;\n{\n    /* 多表内连接 */\n    IJoiningQuery&lt;T1, T2, T3&gt; InnerJoin&lt;T3&gt;(IQuery&lt;T3&gt; q, Expression&lt;Func&lt;T1, T2, T3, bool&gt;&gt; on);\n    /* 多表左连接 */\n    IJoiningQuery&lt;T1, T2, T3&gt; LeftJoin&lt;T3&gt;(IQuery&lt;T3&gt; q, Expression&lt;Func&lt;T1, T2, T3, bool&gt;&gt; on);\n    /* 多表右连接 */\n    IJoiningQuery&lt;T1, T2, T3&gt; RightJoin&lt;T3&gt;(IQuery&lt;T3&gt; q, Expression&lt;Func&lt;T1, T2, T3, bool&gt;&gt; on);\n    /* 多表全连接 */\n    IJoiningQuery&lt;T1, T2, T3&gt; FullJoin&lt;T3&gt;(IQuery&lt;T3&gt; q, Expression&lt;Func&lt;T1, T2, T3, bool&gt;&gt; on);\n    /* 投影选择数据（支持匿名类型） */\n    IQuery&lt;TResult&gt; Select&lt;TResult&gt;(Expression&lt;Func&lt;T1, T2, TResult&gt;&gt; selector);\n}\n\npublic interface IJoiningQuery&lt;T1, T2, T3&gt;\n{\n    IJoiningQuery&lt;T1, T2, T3, T4&gt; InnerJoin&lt;T4&gt;(IQuery&lt;T4&gt; q, Expression&lt;Func&lt;T1, T2, T3, T4, bool&gt;&gt; on);\n    IJoiningQuery&lt;T1, T2, T3, T4&gt; LeftJoin&lt;T4&gt;(IQuery&lt;T4&gt; q, Expression&lt;Func&lt;T1, T2, T3, T4, bool&gt;&gt; on);\n    IJoiningQuery&lt;T1, T2, T3, T4&gt; RightJoin&lt;T4&gt;(IQuery&lt;T4&gt; q, Expression&lt;Func&lt;T1, T2, T3, T4, bool&gt;&gt; on);\n    IJoiningQuery&lt;T1, T2, T3, T4&gt; FullJoin&lt;T4&gt;(IQuery&lt;T4&gt; q, Expression&lt;Func&lt;T1, T2, T3, T4, bool&gt;&gt; on);\n    IQuery&lt;TResult&gt; Select&lt;TResult&gt;(Expression&lt;Func&lt;T1, T2, T3, TResult&gt;&gt; selector);\n}\n\npublic interface IJoiningQuery&lt;T1, T2, T3, T4&gt;\n{\n    IJoiningQuery&lt;T1, T2, T3, T4, T5&gt; InnerJoin&lt;T5&gt;(IQuery&lt;T5&gt; q, Expression&lt;Func&lt;T1, T2, T3, T4, T5, bool&gt;&gt; on);\n    IJoiningQuery&lt;T1, T2, T3, T4, T5&gt; LeftJoin&lt;T5&gt;(IQuery&lt;T5&gt; q, Expression&lt;Func&lt;T1, T2, T3, T4, T5, bool&gt;&gt; on);\n    IJoiningQuery&lt;T1, T2, T3, T4, T5&gt; RightJoin&lt;T5&gt;(IQuery&lt;T5&gt; q, Expression&lt;Func&lt;T1, T2, T3, T4, T5, bool&gt;&gt; on);\n    IJoiningQuery&lt;T1, T2, T3, T4, T5&gt; FullJoin&lt;T5&gt;(IQuery&lt;T5&gt; q, Expression&lt;Func&lt;T1, T2, T3, T4, T5, bool&gt;&gt; on);\n    IQuery&lt;TResult&gt; Select&lt;TResult&gt;(Expression&lt;Func&lt;T1, T2, T3, T4, TResult&gt;&gt; selector);\n}\n\n/* IJoiningQuery 接口最多支持 5 个泛型参数，如需连接更多表，可以调用 Select 方法得到 IQuery 对象后继续连接即可 */\npublic interface IJoiningQuery&lt;T1, T2, T3, T4, T5&gt;\n{\n    IQuery&lt;TResult&gt; Select&lt;TResult&gt;(Expression&lt;Func&lt;T1, T2, T3, T4, T5, TResult&gt;&gt; selector);\n}\n</code></pre>\n', '# IJoiningQuery\n该接口用于基本的多表连接操作。\n```csharp\npublic interface IJoiningQuery<T1, T2>\n{\n    /* 多表内连接 */\n    IJoiningQuery<T1, T2, T3> InnerJoin<T3>(IQuery<T3> q, Expression<Func<T1, T2, T3, bool>> on);\n    /* 多表左连接 */\n    IJoiningQuery<T1, T2, T3> LeftJoin<T3>(IQuery<T3> q, Expression<Func<T1, T2, T3, bool>> on);\n    /* 多表右连接 */\n    IJoiningQuery<T1, T2, T3> RightJoin<T3>(IQuery<T3> q, Expression<Func<T1, T2, T3, bool>> on);\n    /* 多表全连接 */\n    IJoiningQuery<T1, T2, T3> FullJoin<T3>(IQuery<T3> q, Expression<Func<T1, T2, T3, bool>> on);\n    /* 投影选择数据（支持匿名类型） */\n    IQuery<TResult> Select<TResult>(Expression<Func<T1, T2, TResult>> selector);\n}\n\npublic interface IJoiningQuery<T1, T2, T3>\n{\n    IJoiningQuery<T1, T2, T3, T4> InnerJoin<T4>(IQuery<T4> q, Expression<Func<T1, T2, T3, T4, bool>> on);\n    IJoiningQuery<T1, T2, T3, T4> LeftJoin<T4>(IQuery<T4> q, Expression<Func<T1, T2, T3, T4, bool>> on);\n    IJoiningQuery<T1, T2, T3, T4> RightJoin<T4>(IQuery<T4> q, Expression<Func<T1, T2, T3, T4, bool>> on);\n    IJoiningQuery<T1, T2, T3, T4> FullJoin<T4>(IQuery<T4> q, Expression<Func<T1, T2, T3, T4, bool>> on);\n    IQuery<TResult> Select<TResult>(Expression<Func<T1, T2, T3, TResult>> selector);\n}\n\npublic interface IJoiningQuery<T1, T2, T3, T4>\n{\n    IJoiningQuery<T1, T2, T3, T4, T5> InnerJoin<T5>(IQuery<T5> q, Expression<Func<T1, T2, T3, T4, T5, bool>> on);\n    IJoiningQuery<T1, T2, T3, T4, T5> LeftJoin<T5>(IQuery<T5> q, Expression<Func<T1, T2, T3, T4, T5, bool>> on);\n    IJoiningQuery<T1, T2, T3, T4, T5> RightJoin<T5>(IQuery<T5> q, Expression<Func<T1, T2, T3, T4, T5, bool>> on);\n    IJoiningQuery<T1, T2, T3, T4, T5> FullJoin<T5>(IQuery<T5> q, Expression<Func<T1, T2, T3, T4, T5, bool>> on);\n    IQuery<TResult> Select<TResult>(Expression<Func<T1, T2, T3, T4, TResult>> selector);\n}\n\n/* IJoiningQuery 接口最多支持 5 个泛型参数，如需连接更多表，可以调用 Select 方法得到 IQuery 对象后继续连接即可 */\npublic interface IJoiningQuery<T1, T2, T3, T4, T5>\n{\n    IQuery<TResult> Select<TResult>(Expression<Func<T1, T2, T3, T4, T5, TResult>> selector);\n}\n```', '2016-12-01 14:35:35', '2016-12-01 14:55:19', '0', null);
INSERT INTO `wikidocument` VALUES ('3324773693170647040', 'IDbSession', 'IDbSession 接口介绍', 'IDbSession', '<h1 id=\"h1-idbsession\"><a name=\"IDbSession\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>IDbSession</h1><p>DbContext 上下文会话接口，包含基本的 ado.net 操作（支持存储过程及 output 参数）。</p>\n<pre><code class=\"lang-csharp\">public interface IDbSession : IDisposable\n{\n    /* 获取关联的上下文 */\n    IDbContext DbContext { get; }\n\n    /* 判断当前会话是否开启了事务 */\n    bool IsInTransaction { get; }\n    /* 获取或设置在终止执行命令的尝试并生成错误之前的等待时间（以秒为单位）。默认值为 30 秒 */\n    int CommandTimeout { get; set; }\n\n    /* 下面这些方法，你懂的... */\n    int ExecuteNonQuery(string cmdText, params DbParam[] parameters);\n    int ExecuteNonQuery(string cmdText, CommandType cmdType, params DbParam[] parameters);\n\n    object ExecuteScalar(string cmdText, params DbParam[] parameters);\n    object ExecuteScalar(string cmdText, CommandType cmdType, params DbParam[] parameters);\n\n    IDataReader ExecuteReader(string cmdText, params DbParam[] parameters);\n    IDataReader ExecuteReader(string cmdText, CommandType cmdType, params DbParam[] parameters);\n\n    void BeginTransaction();\n    void BeginTransaction(IsolationLevel il);\n    void CommitTransaction();\n    void RollbackTransaction();\n}\n</code></pre>\n', '# IDbSession\nDbContext 上下文会话接口，包含基本的 ado.net 操作（支持存储过程及 output 参数）。\n```csharp\npublic interface IDbSession : IDisposable\n{\n    /* 获取关联的上下文 */\n    IDbContext DbContext { get; }\n\n    /* 判断当前会话是否开启了事务 */\n    bool IsInTransaction { get; }\n    /* 获取或设置在终止执行命令的尝试并生成错误之前的等待时间（以秒为单位）。默认值为 30 秒 */\n    int CommandTimeout { get; set; }\n\n    /* 下面这些方法，你懂的... */\n    int ExecuteNonQuery(string cmdText, params DbParam[] parameters);\n    int ExecuteNonQuery(string cmdText, CommandType cmdType, params DbParam[] parameters);\n\n    object ExecuteScalar(string cmdText, params DbParam[] parameters);\n    object ExecuteScalar(string cmdText, CommandType cmdType, params DbParam[] parameters);\n\n    IDataReader ExecuteReader(string cmdText, params DbParam[] parameters);\n    IDataReader ExecuteReader(string cmdText, CommandType cmdType, params DbParam[] parameters);\n\n    void BeginTransaction();\n    void BeginTransaction(IsolationLevel il);\n    void CommitTransaction();\n    void RollbackTransaction();\n}\n```', '2016-12-01 15:03:41', '2016-12-01 15:04:59', '0', null);
INSERT INTO `wikidocument` VALUES ('3324786622028840960', 'AggregateFunctions', 'AggregateFunctions 接口介绍', 'AggregateFunctions', '<h1 id=\"h1-aggregatefunctions\"><a name=\"AggregateFunctions\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>AggregateFunctions</h1><p>该系列方法用在 Where、Select、Having 等方法的表达式树中，用于表示数据库对应的聚合函数。</p>\n<pre><code class=\"lang-csharp\">public static class AggregateFunctions\n{\n    /* 对应数据库中的 COUNT() 函数 */\n    public static int Count()\n    {\n        return 0;\n    }\n    public static long LongCount()\n    {\n        return 0;\n    }\n\n    /* 对应数据库中的 MAX(exp) 函数 */\n    public static TResult Max&lt;TResult&gt;(TResult p)\n    {\n        return p;\n    }\n    /* 对应数据库中的 MIN(exp) 函数 */\n    public static TResult Min&lt;TResult&gt;(TResult p)\n    {\n        return p;\n    }\n\n    /* 对应数据库中的 SUM(exp) 函数 */\n    public static int Sum(int p)\n    {\n        return p;\n    }\n    public static int? Sum(int? p)\n    {\n        return p;\n    }\n    public static long Sum(long p)\n    {\n        return p;\n    }\n    public static long? Sum(long? p)\n    {\n        return p;\n    }\n    public static decimal Sum(decimal p)\n    {\n        return p;\n    }\n    public static decimal? Sum(decimal? p)\n    {\n        return p;\n    }\n    public static double Sum(double p)\n    {\n        return p;\n    }\n    public static double? Sum(double? p)\n    {\n        return p;\n    }\n    public static float Sum(float p)\n    {\n        return p;\n    }\n    public static float? Sum(float? p)\n    {\n        return p;\n    }\n\n    /* 对应数据库中的 AVG(exp) 函数 */\n    public static double Average(int p)\n    {\n        return p;\n    }\n    public static double? Average(int? p)\n    {\n        return p;\n    }\n    public static double Average(long p)\n    {\n        return p;\n    }\n    public static double? Average(long? p)\n    {\n        return p;\n    }\n    public static decimal Average(decimal p)\n    {\n        return p;\n    }\n    public static decimal? Average(decimal? p)\n    {\n        return p;\n    }\n    public static double Average(double p)\n    {\n        return p;\n    }\n    public static double? Average(double? p)\n    {\n        return p;\n    }\n    public static float Average(float p)\n    {\n        return p;\n    }\n    public static float? Average(float? p)\n    {\n        return p;\n    }\n}\n</code></pre>\n', '# AggregateFunctions\n该系列方法用在 Where、Select、Having 等方法的表达式树中，用于表示数据库对应的聚合函数。\n```csharp\npublic static class AggregateFunctions\n{\n    /* 对应数据库中的 COUNT() 函数 */\n    public static int Count()\n    {\n        return 0;\n    }\n    public static long LongCount()\n    {\n        return 0;\n    }\n\n    /* 对应数据库中的 MAX(exp) 函数 */\n    public static TResult Max<TResult>(TResult p)\n    {\n        return p;\n    }\n    /* 对应数据库中的 MIN(exp) 函数 */\n    public static TResult Min<TResult>(TResult p)\n    {\n        return p;\n    }\n\n    /* 对应数据库中的 SUM(exp) 函数 */\n    public static int Sum(int p)\n    {\n        return p;\n    }\n    public static int? Sum(int? p)\n    {\n        return p;\n    }\n    public static long Sum(long p)\n    {\n        return p;\n    }\n    public static long? Sum(long? p)\n    {\n        return p;\n    }\n    public static decimal Sum(decimal p)\n    {\n        return p;\n    }\n    public static decimal? Sum(decimal? p)\n    {\n        return p;\n    }\n    public static double Sum(double p)\n    {\n        return p;\n    }\n    public static double? Sum(double? p)\n    {\n        return p;\n    }\n    public static float Sum(float p)\n    {\n        return p;\n    }\n    public static float? Sum(float? p)\n    {\n        return p;\n    }\n\n    /* 对应数据库中的 AVG(exp) 函数 */\n    public static double Average(int p)\n    {\n        return p;\n    }\n    public static double? Average(int? p)\n    {\n        return p;\n    }\n    public static double Average(long p)\n    {\n        return p;\n    }\n    public static double? Average(long? p)\n    {\n        return p;\n    }\n    public static decimal Average(decimal p)\n    {\n        return p;\n    }\n    public static decimal? Average(decimal? p)\n    {\n        return p;\n    }\n    public static double Average(double p)\n    {\n        return p;\n    }\n    public static double? Average(double? p)\n    {\n        return p;\n    }\n    public static float Average(float p)\n    {\n        return p;\n    }\n    public static float? Average(float? p)\n    {\n        return p;\n    }\n}\n```\n', '2016-12-01 15:55:03', null, '0', null);
INSERT INTO `wikidocument` VALUES ('3324788085501198336', 'DbFunctions', 'DbFunctions 接口介绍', 'DbFunctions', '<h1 id=\"h1-dbfunctions\"><a name=\"DbFunctions\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>DbFunctions</h1><p>表示与数据库对应函数的一系列方法，可用在 Where、Select 等方法的表达式树中。</p>\n<pre><code class=\"lang-csharp\">public static class DbFunctions\n{\n    /* 求两个时间的年差，对应 SqlServer 的 DATEDIFF(YEAR,dateTime1,dateTime2) */\n    public static int? DiffYears(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的月差，对应 SqlServer 的 DATEDIFF(MONTH,dateTime1,dateTime2) */\n    public static int? DiffMonths(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的日差，对应 SqlServer 的 DATEDIFF(DAY,dateTime1,dateTime2) */\n    public static int? DiffDays(DateTime? dateTime1, DateTime? ddateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的时差，对应 SqlServer 的 DATEDIFF(HOUR,dateTime1,dateTime2) */\n    public static int? DiffHours(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的分钟差，对应 SqlServer 的 DATEDIFF(MINUTE,dateTime1,dateTime2) */\n    public static int? DiffMinutes(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的秒差，对应 SqlServer 的 DATEDIFF(SECOND,dateTime1,dateTime2) */\n    public static int? DiffSeconds(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的毫秒差，对应 SqlServer 的 DATEDIFF(DATEDIFF,dateTime1,dateTime2) */\n    public static int? DiffMilliseconds(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的微毫秒差，对应 SqlServer 的 DATEDIFF(MICROSECOND,dateTime1,dateTime2) */\n    public static int? DiffMicroseconds(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n}\n</code></pre>\n', '# DbFunctions\n表示与数据库对应函数的一系列方法，可用在 Where、Select 等方法的表达式树中。\n```csharp\npublic static class DbFunctions\n{\n    /* 求两个时间的年差，对应 SqlServer 的 DATEDIFF(YEAR,dateTime1,dateTime2) */\n    public static int? DiffYears(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的月差，对应 SqlServer 的 DATEDIFF(MONTH,dateTime1,dateTime2) */\n    public static int? DiffMonths(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的日差，对应 SqlServer 的 DATEDIFF(DAY,dateTime1,dateTime2) */\n    public static int? DiffDays(DateTime? dateTime1, DateTime? ddateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的时差，对应 SqlServer 的 DATEDIFF(HOUR,dateTime1,dateTime2) */\n    public static int? DiffHours(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的分钟差，对应 SqlServer 的 DATEDIFF(MINUTE,dateTime1,dateTime2) */\n    public static int? DiffMinutes(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的秒差，对应 SqlServer 的 DATEDIFF(SECOND,dateTime1,dateTime2) */\n    public static int? DiffSeconds(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的毫秒差，对应 SqlServer 的 DATEDIFF(DATEDIFF,dateTime1,dateTime2) */\n    public static int? DiffMilliseconds(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n\n    /* 求两个时间的微毫秒差，对应 SqlServer 的 DATEDIFF(MICROSECOND,dateTime1,dateTime2) */\n    public static int? DiffMicroseconds(DateTime? dateTime1, DateTime? dateTime2)\n    {\n        throw new NotSupportedException();\n    }\n}\n```', '2016-12-01 16:00:52', null, '0', null);
INSERT INTO `wikidocument` VALUES ('3324793835434803200', 'SqlServer-实体特性', 'SqlServer-实体特性', 'SqlServer-实体特性', '<h1 id=\"h1-u5B9Eu4F53u7279u6027\"><a name=\"实体特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实体特性</h1><p>实体特性位于命名空间 Chloe.Entity 下。<br><strong>TableAttribute：</strong><br>Name：映射的表名。<br>实体对应的表默认是实体类名，如实体类型名与表名不一致，可通过该特性指定映射的表名。</p>\n<pre><code class=\"lang-csharp\">public class TableAttribute : Attribute\n{\n    public TableAttribute() { }\n    public TableAttribute(string name)\n    {\n        Name = name;\n    }\n    public string Name { get; set; }\n}\n</code></pre>\n<p><strong>ColumnAttribute：</strong><br>Name：映射的列名，如不指定，则默认使用属性名。<br>IsPrimaryKey：指示列是否为主键，默认为 false。<br>当一个实体没显示指定主键的时候，Chloe 默认选择名为 Id 的属性（如果存在）作为主键列，与此同时，如果该实体也没有显示指定任何自增列并且 Id 属性为 Int16、Int32 或者 Int64 类型，则也会默认其为自增列。</p>\n<pre><code class=\"lang-csharp\">public class ColumnAttribute : Attribute\n{\n    public ColumnAttribute() { }\n    public ColumnAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; set; }\n    public bool IsPrimaryKey { get; set; }\n}\n</code></pre>\n<p><strong>AutoIncrementAttribute：</strong><br>标记属性为自增列。在 SqlServer 中，一个实体不能指定多个自增列，否则会报异常提示。</p>\n<pre><code class=\"lang-csharp\">public class AutoIncrementAttribute : Attribute\n{\n}\n</code></pre>\n<p><strong>NonAutoIncrementAttribute：</strong><br>标记属性为非自增列。</p>\n<pre><code class=\"lang-csharp\">public class NonAutoIncrementAttribute : Attribute\n{\n}\n</code></pre>\n<p><strong>NotMappedAttribute：</strong><br>指示属性不映射任何列。</p>\n<pre><code class=\"lang-csharp\">public class NotMappedAttribute : Attribute\n{\n}\n</code></pre>\n', '# 实体特性\n实体特性位于命名空间 Chloe.Entity 下。\n**TableAttribute：**\nName：映射的表名。\n实体对应的表默认是实体类名，如实体类型名与表名不一致，可通过该特性指定映射的表名。\n```csharp\npublic class TableAttribute : Attribute\n{\n    public TableAttribute() { }\n    public TableAttribute(string name)\n    {\n        Name = name;\n    }\n    public string Name { get; set; }\n}\n```\n**ColumnAttribute：**\nName：映射的列名，如不指定，则默认使用属性名。\nIsPrimaryKey：指示列是否为主键，默认为 false。\n当一个实体没显示指定主键的时候，Chloe 默认选择名为 Id 的属性（如果存在）作为主键列，与此同时，如果该实体也没有显示指定任何自增列并且 Id 属性为 Int16、Int32 或者 Int64 类型，则也会默认其为自增列。\n```csharp\npublic class ColumnAttribute : Attribute\n{\n    public ColumnAttribute() { }\n    public ColumnAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; set; }\n    public bool IsPrimaryKey { get; set; }\n}\n```\n**AutoIncrementAttribute：**\n标记属性为自增列。在 SqlServer 中，一个实体不能指定多个自增列，否则会报异常提示。\n```csharp\npublic class AutoIncrementAttribute : Attribute\n{\n}\n```\n**NonAutoIncrementAttribute：**\n标记属性为非自增列。\n```csharp\npublic class NonAutoIncrementAttribute : Attribute\n{\n}\n```\n**NotMappedAttribute：**\n指示属性不映射任何列。\n```csharp\npublic class NotMappedAttribute : Attribute\n{\n}\n```', '2016-12-01 16:23:43', '2016-12-02 19:32:10', '0', null);
INSERT INTO `wikidocument` VALUES ('3324795934096752640', 'SqlServer-实体定义', 'SqlServer-实体定义', 'SqlServer-实体定义', '<h1 id=\"h1-u5B9Eu4F53u5B9Au4E49\"><a name=\"实体定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实体定义</h1><p>实体为纯 POCO，支持可空类型以及枚举类型映射。</p>\n<pre><code class=\"lang-csharp\">public enum Gender\n{\n    Man = 1,\n    Woman\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">[TableAttribute(&quot;Users&quot;)]\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">public class City\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">public class Province\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n</code></pre>\n', '# 实体定义\n实体为纯 POCO，支持可空类型以及枚举类型映射。\n```csharp\npublic enum Gender\n{\n    Man = 1,\n    Woman\n}\n```\n```csharp\n[TableAttribute(\"Users\")]\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n```\n```csharp\npublic class City\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n```\n```csharp\npublic class Province\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n```', '2016-12-01 16:32:03', '2016-12-01 16:39:30', '0', null);
INSERT INTO `wikidocument` VALUES ('3324798423210655744', 'SqlServer-创建DbContext', 'SqlServer-创建DbContext', 'SqlServer-创建DbContext', '<h1 id=\"h1--dbcontext\"><a name=\"创建 DbContext\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建 DbContext</h1><p>对于 SqlServer 数据库，需要引用程序集 Chloe.dll 和 Chloe.SqlServer.dll，然后使用 Chloe.SqlServer.MsSqlContext 创建上下文实例。</p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nMsSqlContext context = new MsSqlContext(connString);\n</code></pre>\n<p>MsSqlContext 对象默认使用 ROWNUMBER 的分页方式，如果您的数据库是 SqlServer2012 或更高版本，可以切换使用 OFFSET FETCH 分页方式。</p>\n<pre><code class=\"lang-csharp\">context.PagingMode = PagingMode.OFFSET_FETCH;\n</code></pre>\n', '# 创建 DbContext\n对于 SqlServer 数据库，需要引用程序集 Chloe.dll 和 Chloe.SqlServer.dll，然后使用 Chloe.SqlServer.MsSqlContext 创建上下文实例。\n```csharp\nstring connString = \"Your connection string\";\nMsSqlContext context = new MsSqlContext(connString);\n```\nMsSqlContext 对象默认使用 ROWNUMBER 的分页方式，如果您的数据库是 SqlServer2012 或更高版本，可以切换使用 OFFSET FETCH 分页方式。\n```csharp\ncontext.PagingMode = PagingMode.OFFSET_FETCH;\n```', '2016-12-01 16:41:57', '2016-12-01 19:39:45', '0', null);
INSERT INTO `wikidocument` VALUES ('3324802610879266816', 'SqlServer-基本查询', 'SqlServer-基本查询', 'SqlServer-基本查询', '<h1 id=\"h1-u57FAu672Cu67E5u8BE2\"><a name=\"基本查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本查询</h1><p><strong>根据 Id 查询出一个 User 对象：</strong></p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nMsSqlContext context = new MsSqlContext(connString);\ncontext.PagingMode = PagingMode.OFFSET_FETCH;\nIQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nq.Where(a =&gt; a.Id == 1).FirstOrDefault();\n/*\n *生成的 sql：\n * SELECT TOP (1) [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] = 1\n */\n</code></pre>\n<p><strong>in 查询：</strong></p>\n<pre><code class=\"lang-csharp\">List&lt;int&gt; ids = new List&lt;int&gt;() { 1, 2, 3 };\nq.Where(a =&gt; ids.Contains(a.Id)).ToList();\n/*\n * Int32 @P_0 = 1;\n   Int32 @P_1 = 2;\n   Int32 @P_2 = 3;\n   SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] IN (@P_0,@P_1,@P_2)\n */\n</code></pre>\n<p><strong>可以选取指定的字段，返回一个匿名类型：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id == 1).Select(a =&gt; new { a.Id, a.Name }).FirstOrDefault();\n/*\n * 只会生成包含 Id 和 Name 两个字段的 sql 语句：\n * SELECT TOP (1) [Users].[Id] AS [Id],[Users].[Name] AS [Name] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] = 1\n */\n</code></pre>\n<p><strong>排序：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).ThenBy(a =&gt; a.Id).ToList();\n/*\n * SELECT TOP (1) [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] &gt; 0 \n   ORDER BY [Age] ASC,[Id] ASC\n */\n</code></pre>\n<p><strong>分页：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).TakePage(1, 20).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] WHERE [Users].[Id] &gt; 0 \n   ORDER BY [Users].[Age] ASC \n   OFFSET 0 ROWS FETCH NEXT 20 ROWS ONLY\n */\n</code></pre>\n', '# 基本查询\n**根据 Id 查询出一个 User 对象：**\n```csharp\nstring connString = \"Your connection string\";\nMsSqlContext context = new MsSqlContext(connString);\ncontext.PagingMode = PagingMode.OFFSET_FETCH;\nIQuery<User> q = context.Query<User>();\n\nq.Where(a => a.Id == 1).FirstOrDefault();\n/*\n *生成的 sql：\n * SELECT TOP (1) [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] = 1\n */\n```\n**in 查询：**\n```csharp\nList<int> ids = new List<int>() { 1, 2, 3 };\nq.Where(a => ids.Contains(a.Id)).ToList();\n/*\n * Int32 @P_0 = 1;\n   Int32 @P_1 = 2;\n   Int32 @P_2 = 3;\n   SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] IN (@P_0,@P_1,@P_2)\n */\n```\n**可以选取指定的字段，返回一个匿名类型：**\n```csharp\nq.Where(a => a.Id == 1).Select(a => new { a.Id, a.Name }).FirstOrDefault();\n/*\n * 只会生成包含 Id 和 Name 两个字段的 sql 语句：\n * SELECT TOP (1) [Users].[Id] AS [Id],[Users].[Name] AS [Name] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] = 1\n */\n```\n**排序：**\n```csharp\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).ThenBy(a => a.Id).ToList();\n/*\n * SELECT TOP (1) [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] > 0 \n   ORDER BY [Age] ASC,[Id] ASC\n */\n```\n**分页：**\n```csharp\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).TakePage(1, 20).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] WHERE [Users].[Id] > 0 \n   ORDER BY [Users].[Age] ASC \n   OFFSET 0 ROWS FETCH NEXT 20 ROWS ONLY\n */\n```', '2016-12-01 16:58:35', '2016-12-08 11:39:20', '0', null);
INSERT INTO `wikidocument` VALUES ('3324809512287731712', 'SqlServer-连接查询', 'SqlServer-连接查询', 'SqlServer-连接查询', '<h1 id=\"h1-u8FDEu63A5u67E5u8BE2\"><a name=\"连接查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>连接查询</h1><p>Chloe 友好支持多表连接查询，一切都可以用 lambda 表达式操作，返回类型可以是自定义类型，也可以是匿名类型。强类型开发，编译可见错误，容错率高。<br><strong>1.创建相关的 IQuery 对象：</strong></p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; users = context.Query&lt;User&gt;();\nIQuery&lt;City&gt; cities = context.Query&lt;City&gt;();\nIQuery&lt;Province&gt; provinces = context.Query&lt;Province&gt;();\n</code></pre>\n<p><strong>2.建立连接：</strong></p>\n<pre><code class=\"lang-csharp\">/* User 表和 City 表 inner join，得到 IJoiningQuery&lt;User, City&gt; 对象 */\nIJoiningQuery&lt;User, City&gt; user_city = users.InnerJoin(cities, (user, city) =&gt; user.CityId == city.Id);\n\n/* City 表和 Province 表 inner join，得到 IJoiningQuery&lt;User, City, Province&gt; 对象 */\nIJoiningQuery&lt;User, City, Province&gt; user_city_province = user_city.InnerJoin(provinces, (user, city, province) =&gt; city.ProvinceId == province.Id);\n</code></pre>\n<p><strong>3.得到最终的 IJoiningQuery 对象，就可以 Select 所需要的数据返回一个 IQuery 对象，然后就可以进行 Where、OrderBy、GroupBy、分页、聚合查询等操作：</strong><br>查出一个用户及其隶属的城市和省份的所有信息：</p>\n<pre><code class=\"lang-csharp\">/* 调用 Select 方法返回一个泛型为包含 User、City、Province 匿名类型的 IQuery 对象。\n * Select 方法也可以返回自定义类型 。\n */\nvar qq = user_city_province.Select((user, city, province) =&gt; new\n{\n    User = user,\n    City = city,\n    Province = province\n});\n\n/* 根据条件筛选，然后调用 ToList 就会返回一个泛型为 new { User = user, City = city, Province = province } 的 List 集合 */\nvar result = qq.Where(a =&gt; a.User.Id == 1).ToList();\n\n/*\n * 生成的 sql：\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[City].[Id] AS [Id0],[City].[Name] AS [Name0],[City].[ProvinceId] AS [ProvinceId],[Province].[Id] AS [Id1],[Province].[Name] AS [Name1] \n   FROM [Users] AS [Users] \n   INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n   WHERE [Users].[Id] = 1\n */\n</code></pre>\n<p>可以只获取指定的字段信息：</p>\n<pre><code class=\"lang-csharp\">user_city_province.Select((user, city, province) =&gt; new\n{\n    UserId = user.Id,\n    UserName = user.Name,\n    CityName = city.Name,\n    ProvinceName = province.Name\n}).Where(a =&gt; a.UserId == 1).ToList();\n\n/*\n * 生成的 sql 只会包含 UserId、UserName、CityName、ProvinceName 四个字段\n * SELECT [Users].[Id] AS [UserId],[Users].[Name] AS [UserName],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] \n   FROM [Users] AS [Users] \n   INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n   WHERE [Users].[Id] = 1\n */\n</code></pre>\n<p>框架亦支持左连接、右连接和Full连接查询，用法和内连接相同。</p>\n', '# 连接查询\nChloe 友好支持多表连接查询，一切都可以用 lambda 表达式操作，返回类型可以是自定义类型，也可以是匿名类型。强类型开发，编译可见错误，容错率高。\n**1.创建相关的 IQuery 对象：**\n```csharp\nIQuery<User> users = context.Query<User>();\nIQuery<City> cities = context.Query<City>();\nIQuery<Province> provinces = context.Query<Province>();\n```\n**2.建立连接：**\n```csharp\n/* User 表和 City 表 inner join，得到 IJoiningQuery<User, City> 对象 */\nIJoiningQuery<User, City> user_city = users.InnerJoin(cities, (user, city) => user.CityId == city.Id);\n\n/* City 表和 Province 表 inner join，得到 IJoiningQuery<User, City, Province> 对象 */\nIJoiningQuery<User, City, Province> user_city_province = user_city.InnerJoin(provinces, (user, city, province) => city.ProvinceId == province.Id);\n```\n**3.得到最终的 IJoiningQuery 对象，就可以 Select 所需要的数据返回一个 IQuery 对象，然后就可以进行 Where、OrderBy、GroupBy、分页、聚合查询等操作：**\n查出一个用户及其隶属的城市和省份的所有信息：\n```csharp\n/* 调用 Select 方法返回一个泛型为包含 User、City、Province 匿名类型的 IQuery 对象。\n * Select 方法也可以返回自定义类型 。\n */\nvar qq = user_city_province.Select((user, city, province) => new\n{\n    User = user,\n    City = city,\n    Province = province\n});\n\n/* 根据条件筛选，然后调用 ToList 就会返回一个泛型为 new { User = user, City = city, Province = province } 的 List 集合 */\nvar result = qq.Where(a => a.User.Id == 1).ToList();\n\n/*\n * 生成的 sql：\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[City].[Id] AS [Id0],[City].[Name] AS [Name0],[City].[ProvinceId] AS [ProvinceId],[Province].[Id] AS [Id1],[Province].[Name] AS [Name1] \n   FROM [Users] AS [Users] \n   INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n   WHERE [Users].[Id] = 1\n */\n```\n可以只获取指定的字段信息：\n```csharp\nuser_city_province.Select((user, city, province) => new\n{\n    UserId = user.Id,\n    UserName = user.Name,\n    CityName = city.Name,\n    ProvinceName = province.Name\n}).Where(a => a.UserId == 1).ToList();\n\n/*\n * 生成的 sql 只会包含 UserId、UserName、CityName、ProvinceName 四个字段\n * SELECT [Users].[Id] AS [UserId],[Users].[Name] AS [UserName],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] \n   FROM [Users] AS [Users] \n   INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n   WHERE [Users].[Id] = 1\n */\n```\n框架亦支持左连接、右连接和Full连接查询，用法和内连接相同。', '2016-12-01 17:26:01', '2016-12-01 18:13:08', '0', null);
INSERT INTO `wikidocument` VALUES ('3324832206215446528', 'SqlServer-分组查询', 'SqlServer-分组查询', 'SqlServer-分组查询', '<h1 id=\"h1-u5206u7EC4u67E5u8BE2\"><a name=\"分组查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分组查询</h1><p>Chloe 支持分组查询以及分组后 Having 过滤和聚合查询。</p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nIGroupingQuery&lt;User&gt; g = q.Where(a =&gt; a.Id &gt; 0).GroupBy(a =&gt; a.Age);\ng = g.Having(a =&gt; a.Age &gt; 1 &amp;&amp; AggregateFunctions.Count() &gt; 0);\n\ng.Select(a =&gt; new\n{\n    a.Age,\n    Count = AggregateFunctions.Count(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Avg = AggregateFunctions.Average(a.Age)\n}).ToList();\n/*\n * SELECT [Users].[Age] AS [Age],COUNT(1) AS [Count],CAST(SUM([Users].[Age]) AS INT) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Avg] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] &gt; 0 \n   GROUP BY [Users].[Age] \n   HAVING ([Users].[Age] &gt; 1 AND COUNT(1) &gt; 0)\n */\n</code></pre>\n', '# 分组查询\nChloe 支持分组查询以及分组后 Having 过滤和聚合查询。\n```csharp\nIQuery<User> q = context.Query<User>();\n\nIGroupingQuery<User> g = q.Where(a => a.Id > 0).GroupBy(a => a.Age);\ng = g.Having(a => a.Age > 1 && AggregateFunctions.Count() > 0);\n\ng.Select(a => new\n{\n    a.Age,\n    Count = AggregateFunctions.Count(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Avg = AggregateFunctions.Average(a.Age)\n}).ToList();\n/*\n * SELECT [Users].[Age] AS [Age],COUNT(1) AS [Count],CAST(SUM([Users].[Age]) AS INT) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Avg] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] > 0 \n   GROUP BY [Users].[Age] \n   HAVING ([Users].[Age] > 1 AND COUNT(1) > 0)\n */\n```', '2016-12-01 18:56:11', '2016-12-02 19:11:07', '0', null);
INSERT INTO `wikidocument` VALUES ('3324833832581988352', 'SqlServer-聚合查询', 'SqlServer-聚合查询', 'SqlServer-聚合查询', '<h1 id=\"h1-u805Au5408u67E5u8BE2\"><a name=\"聚合查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>聚合查询</h1><p>Chloe 可以像写 sql 一样实现聚合查询。</p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nq.Select(a =&gt; AggregateFunctions.Count()).First();\n/*\n * SELECT TOP (1) COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\n/* 支持多个聚合函数 */\nq.Select(a =&gt; new\n{\n    Count = AggregateFunctions.Count(),\n    LongCount = AggregateFunctions.LongCount(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Average = AggregateFunctions.Average(a.Age)\n}).First();\n/*\n * SELECT TOP (1) COUNT(1) AS [Count],COUNT_BIG(1) AS [LongCount],CAST(SUM([Users].[Age]) AS INT) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Average] \n   FROM [Users] AS [Users]\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT_BIG(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar sum = q.Sum(a =&gt; a.Age);\n/*\n * SELECT CAST(SUM([Users].[Age]) AS INT) AS [C] FROM [Users] AS [Users]\n */\n\nvar max = q.Max(a =&gt; a.Age);\n/*\n * SELECT MAX([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar min = q.Min(a =&gt; a.Age);\n/*\n * SELECT MIN([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar avg = q.Average(a =&gt; a.Age);\n/*\n * SELECT CAST(AVG([Users].[Age]) AS FLOAT) AS [C] FROM [Users] AS [Users]\n */\n</code></pre>\n', '# 聚合查询\nChloe 可以像写 sql 一样实现聚合查询。\n```csharp\nIQuery<User> q = context.Query<User>();\n\nq.Select(a => AggregateFunctions.Count()).First();\n/*\n * SELECT TOP (1) COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\n/* 支持多个聚合函数 */\nq.Select(a => new\n{\n    Count = AggregateFunctions.Count(),\n    LongCount = AggregateFunctions.LongCount(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Average = AggregateFunctions.Average(a.Age)\n}).First();\n/*\n * SELECT TOP (1) COUNT(1) AS [Count],COUNT_BIG(1) AS [LongCount],CAST(SUM([Users].[Age]) AS INT) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Average] \n   FROM [Users] AS [Users]\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT_BIG(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar sum = q.Sum(a => a.Age);\n/*\n * SELECT CAST(SUM([Users].[Age]) AS INT) AS [C] FROM [Users] AS [Users]\n */\n\nvar max = q.Max(a => a.Age);\n/*\n * SELECT MAX([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar min = q.Min(a => a.Age);\n/*\n * SELECT MIN([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar avg = q.Average(a => a.Age);\n/*\n * SELECT CAST(AVG([Users].[Age]) AS FLOAT) AS [C] FROM [Users] AS [Users]\n */\n```', '2016-12-01 19:02:39', '2016-12-01 19:05:33', '0', null);
INSERT INTO `wikidocument` VALUES ('3324834901575860224', 'SqlServer-Sql查询', 'SqlServer-Sql查询', 'SqlServer-Sql查询', '<h1 id=\"h1-sql-\"><a name=\"Sql查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Sql查询</h1><p>对于一些极其复杂的 sql 查询，还是得依赖原生 sql，因此，Chloe 提供了原生 sql 查询接口。<br><strong>获取满足条件的用户信息，将结果映射到 User 类上：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;User&gt;(&quot;select * from Users where Age&gt;@age&quot;, new DbParam(&quot;@age&quot;, 18)).ToList();\n</code></pre>\n<p><strong>获取满足条件的用户 Id：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;int&gt;(&quot;select Id from Users where Age&gt;@age&quot;, new DbParam(&quot;@age&quot;, 18)).ToList();\n</code></pre>\n<p><strong>支持存储过程：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;User&gt;(&quot;Proc_Test&quot;, CommandType.StoredProcedure, new DbParam(&quot;@age&quot;, 18)).ToList();\n</code></pre>\n', '# Sql查询\n对于一些极其复杂的 sql 查询，还是得依赖原生 sql，因此，Chloe 提供了原生 sql 查询接口。\n**获取满足条件的用户信息，将结果映射到 User 类上：**\n```csharp\ncontext.SqlQuery<User>(\"select * from Users where Age>@age\", new DbParam(\"@age\", 18)).ToList();\n```\n**获取满足条件的用户 Id：**\n```csharp\ncontext.SqlQuery<int>(\"select Id from Users where Age>@age\", new DbParam(\"@age\", 18)).ToList();\n```\n**支持存储过程：**\n```csharp\ncontext.SqlQuery<User>(\"Proc_Test\", CommandType.StoredProcedure, new DbParam(\"@age\", 18)).ToList();\n```', '2016-12-01 19:06:54', '2016-12-01 19:16:33', '0', null);
INSERT INTO `wikidocument` VALUES ('3324837619082199040', 'SqlServer-插入数据', 'SqlServer-插入数据', 'SqlServer-插入数据', '<h1 id=\"h1-u63D2u5165u6570u636E\"><a name=\"插入数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>插入数据</h1><p>Chloe 具备两种插入数据的方式。<br><strong>1.实体插入：</strong><br>该方式插入，如果一个实体存在自增列，会自动将自增列设置到相应的属性上。</p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Name = &quot;lu&quot;;\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = DateTime.Now;\n\n/* 会自动将自增 Id 设置到 user 的 Id 属性上 */\nuser = context.Insert(user);\n/*\n * String @P_0 = &#39;lu&#39;;\n   Gender @P_1 = Man;\n   Int32 @P_2 = 18;\n   Int32 @P_3 = 1;\n   DateTime @P_4 = &#39;2016/8/26 18:41:08&#39;;\n   INSERT INTO [Users]([Name],[Gender],[Age],[CityId],[OpTime]) \n   VALUES(@P_0,@P_1,@P_2,@P_3,@P_4);SELECT @@IDENTITY\n */\n</code></pre>\n<p><strong>2.lambda 方式插入：</strong><br>此种方式插入的好处是，可以指定列插入，就像写 sql 一样简单。<br>同时，该方式插入返回表主键值。如果实体主键是自增列，返回值就会是自增值。</p>\n<pre><code class=\"lang-csharp\">/* 返回主键 Id */\nint id = (int)context.Insert&lt;User&gt;(() =&gt; new User()\n{\n    Name = &quot;lu&quot;,\n    Age = 18,\n    Gender = Gender.Man,\n    CityId = 1,\n    OpTime = DateTime.Now\n});\n/*\n * INSERT INTO [Users]([Name],[Age],[Gender],[CityId],[OpTime]) \n   VALUES(N&#39;lu&#39;,18,1,1,GETDATE());SELECT @@IDENTITY\n */\n</code></pre>\n', '# 插入数据\nChloe 具备两种插入数据的方式。\n**1.实体插入：**\n该方式插入，如果一个实体存在自增列，会自动将自增列设置到相应的属性上。\n```csharp\nUser user = new User();\nuser.Name = \"lu\";\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = DateTime.Now;\n\n/* 会自动将自增 Id 设置到 user 的 Id 属性上 */\nuser = context.Insert(user);\n/*\n * String @P_0 = \'lu\';\n   Gender @P_1 = Man;\n   Int32 @P_2 = 18;\n   Int32 @P_3 = 1;\n   DateTime @P_4 = \'2016/8/26 18:41:08\';\n   INSERT INTO [Users]([Name],[Gender],[Age],[CityId],[OpTime]) \n   VALUES(@P_0,@P_1,@P_2,@P_3,@P_4);SELECT @@IDENTITY\n */\n```\n**2.lambda 方式插入：**\n此种方式插入的好处是，可以指定列插入，就像写 sql 一样简单。\n同时，该方式插入返回表主键值。如果实体主键是自增列，返回值就会是自增值。\n```csharp\n/* 返回主键 Id */\nint id = (int)context.Insert<User>(() => new User()\n{\n    Name = \"lu\",\n    Age = 18,\n    Gender = Gender.Man,\n    CityId = 1,\n    OpTime = DateTime.Now\n});\n/*\n * INSERT INTO [Users]([Name],[Age],[Gender],[CityId],[OpTime]) \n   VALUES(N\'lu\',18,1,1,GETDATE());SELECT @@IDENTITY\n */\n```', '2016-12-01 19:17:42', '2016-12-04 11:55:03', '0', null);
INSERT INTO `wikidocument` VALUES ('3324837696316112896', 'SqlServer-更新数据', 'SqlServer-更新数据', 'SqlServer-更新数据', '<h1 id=\"h1-u66F4u65B0u6570u636E\"><a name=\"更新数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更新数据</h1><p>Chloe 支持两种数据更新方式。<br><strong>1.实体更新：</strong></p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Id = 1;\nuser.Name = &quot;lu&quot;;\nuser.Age = 28;\nuser.Gender = Gender.Man;\nuser.OpTime = DateTime.Now;\n\n/* 更新所有映射的字段 */\ncontext.Update(user);\n/*\n * String @P_0 = &#39;lu&#39;;\n   Gender @P_1 = Man;\n   Int32 @P_2 = 28;\n   Nullable&lt;Int32&gt; @P_3 = NULL;\n   DateTime @P_4 = &#39;2016/8/26 18:18:36&#39;;\n   Int32 @P_5 = 1;\n   UPDATE [Users] SET [Name]=@P_0,[Gender]=@P_1,[Age]=@P_2,[CityId]=@P_3,[OpTime]=@P_4 \n   WHERE [Users].[Id] = @P_5\n */\n</code></pre>\n<p>由于 user 对象未被上下文跟踪，这会使所有的映射列都会被更新。Chloe 也支持类似 EF 一样只更新被修改过的属性。</p>\n<pre><code class=\"lang-csharp\">/*\n * 支持只更新属性值已变的属性\n */\n\n/* 在修改实体属性前让上下文跟踪实体 */\ncontext.TrackEntity(user);\n\n/* 然后再修改实体属性 */\nuser.Name = user.Name + &quot;1&quot;;\n\n/* 然后调用 Update 方法，这时只会更新被修改过的属性 */\ncontext.Update(user);\n/*\n * String @P_0 = &#39;lu1&#39;;\n   Int32 @P_1 = 1;\n   UPDATE [Users] SET [Name]=@P_0 WHERE [Users].[Id] = @P_1\n */\n</code></pre>\n<p><strong>2.lambda 方式更新：</strong><br>该方式解决的问题是：1.指定列更新；2.批量更新；3.支持类似 Age=Age + 100 这样更新字段。用法如下：</p>\n<pre><code class=\"lang-csharp\">context.Update&lt;User&gt;(a =&gt; a.Age &gt; 18, a =&gt; new User()\n{\n    Name = a.Name,\n    Age = a.Age + 100,\n    Gender = Gender.Man,\n    OpTime = DateTime.Now\n});\n/*\n * UPDATE [Users] SET [Name]=[Users].[Name],[Age]=([Users].[Age] + 100),[Gender]=1,[OpTime]=GETDATE() \n   WHERE [Users].[Age] &gt; 18\n */\n</code></pre>\n', '# 更新数据\nChloe 支持两种数据更新方式。\n**1.实体更新：**\n```csharp\nUser user = new User();\nuser.Id = 1;\nuser.Name = \"lu\";\nuser.Age = 28;\nuser.Gender = Gender.Man;\nuser.OpTime = DateTime.Now;\n\n/* 更新所有映射的字段 */\ncontext.Update(user);\n/*\n * String @P_0 = \'lu\';\n   Gender @P_1 = Man;\n   Int32 @P_2 = 28;\n   Nullable<Int32> @P_3 = NULL;\n   DateTime @P_4 = \'2016/8/26 18:18:36\';\n   Int32 @P_5 = 1;\n   UPDATE [Users] SET [Name]=@P_0,[Gender]=@P_1,[Age]=@P_2,[CityId]=@P_3,[OpTime]=@P_4 \n   WHERE [Users].[Id] = @P_5\n */\n```\n由于 user 对象未被上下文跟踪，这会使所有的映射列都会被更新。Chloe 也支持类似 EF 一样只更新被修改过的属性。\n```csharp\n/*\n * 支持只更新属性值已变的属性\n */\n\n/* 在修改实体属性前让上下文跟踪实体 */\ncontext.TrackEntity(user);\n\n/* 然后再修改实体属性 */\nuser.Name = user.Name + \"1\";\n\n/* 然后调用 Update 方法，这时只会更新被修改过的属性 */\ncontext.Update(user);\n/*\n * String @P_0 = \'lu1\';\n   Int32 @P_1 = 1;\n   UPDATE [Users] SET [Name]=@P_0 WHERE [Users].[Id] = @P_1\n */\n```\n**2.lambda 方式更新：**\n该方式解决的问题是：1.指定列更新；2.批量更新；3.支持类似 Age=Age + 100 这样更新字段。用法如下：\n```csharp\ncontext.Update<User>(a => a.Age > 18, a => new User()\n{\n    Name = a.Name,\n    Age = a.Age + 100,\n    Gender = Gender.Man,\n    OpTime = DateTime.Now\n});\n/*\n * UPDATE [Users] SET [Name]=[Users].[Name],[Age]=([Users].[Age] + 100),[Gender]=1,[OpTime]=GETDATE() \n   WHERE [Users].[Age] > 18\n */\n```', '2016-12-01 19:18:00', '2016-12-02 19:20:02', '0', null);
INSERT INTO `wikidocument` VALUES ('3324837762527395840', 'SqlServer-删除数据', 'SqlServer-删除数据', 'SqlServer-删除数据', '<h1 id=\"h1-u5220u9664u6570u636E\"><a name=\"删除数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除数据</h1><p>Chloe 支持两种数据删除方式。<br><strong>1.实体删除：</strong><br>该方式删除必须要求实体拥有一个主键，否则会报异常提示。</p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 @P_0 = 1;\n   DELETE [Users] WHERE [Users].[Id] = @P_0\n */\n</code></pre>\n<p><strong>2.lambda 方式删除：</strong><br>使用该方式可以删除单条数据，也可以删除多条数据。</p>\n<pre><code class=\"lang-csharp\">/* 删除单条数据 */\ncontext.Delete&lt;User&gt;(a =&gt; a.Id == 1);\n/*\n * DELETE [Users] WHERE [Users].[Id] = 1\n */\n\n/* 批量删除满足条件的数据 */\ncontext.Delete&lt;User&gt;(a =&gt; a.Age &gt; 18);\n/*\n * DELETE [Users] WHERE [Users].[Age] &gt; 18\n */\n</code></pre>\n', '# 删除数据\nChloe 支持两种数据删除方式。\n**1.实体删除：**\n该方式删除必须要求实体拥有一个主键，否则会报异常提示。\n```csharp\nUser user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 @P_0 = 1;\n   DELETE [Users] WHERE [Users].[Id] = @P_0\n */\n```\n**2.lambda 方式删除：**\n使用该方式可以删除单条数据，也可以删除多条数据。\n```csharp\n/* 删除单条数据 */\ncontext.Delete<User>(a => a.Id == 1);\n/*\n * DELETE [Users] WHERE [Users].[Id] = 1\n */\n\n/* 批量删除满足条件的数据 */\ncontext.Delete<User>(a => a.Age > 18);\n/*\n * DELETE [Users] WHERE [Users].[Age] > 18\n */\n```', '2016-12-01 19:18:16', '2016-12-02 11:19:16', '0', null);
INSERT INTO `wikidocument` VALUES ('3324837828717707264', 'SqlServer-存储过程', 'SqlServer-存储过程', 'SqlServer-存储过程', '<h1 id=\"h1-u5B58u50A8u8FC7u7A0B\"><a name=\"存储过程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>存储过程</h1><p>Chloe 支持存储过程以及 output 参数。<br><strong>通过存储过程获取一个 User 信息：</strong></p>\n<pre><code class=\"lang-csharp\">DbParam id = new DbParam(&quot;@id&quot;, 1);\nUser user = context.SqlQuery&lt;User&gt;(&quot;Proc_GetUser&quot;, CommandType.StoredProcedure, id).FirstOrDefault();\n</code></pre>\n<p><strong>通过存储过程的 output 参数获取一个用户的 name：</strong></p>\n<pre><code class=\"lang-csharp\">DbParam id = new DbParam(&quot;@id&quot;, 1);\nDbParam outputName = new DbParam(&quot;@name&quot;, null, typeof(string)) { Direction = ParamDirection.Output };\ncontext.Session.ExecuteNonQuery(&quot;Proc_GetUserName&quot;, CommandType.StoredProcedure, id, outputName);\n</code></pre>\n', '# 存储过程\nChloe 支持存储过程以及 output 参数。\n**通过存储过程获取一个 User 信息：**\n```csharp\nDbParam id = new DbParam(\"@id\", 1);\nUser user = context.SqlQuery<User>(\"Proc_GetUser\", CommandType.StoredProcedure, id).FirstOrDefault();\n```\n**通过存储过程的 output 参数获取一个用户的 name：**\n```csharp\nDbParam id = new DbParam(\"@id\", 1);\nDbParam outputName = new DbParam(\"@name\", null, typeof(string)) { Direction = ParamDirection.Output };\ncontext.Session.ExecuteNonQuery(\"Proc_GetUserName\", CommandType.StoredProcedure, id, outputName);\n```', '2016-12-01 19:18:32', '2016-12-02 14:19:30', '0', null);
INSERT INTO `wikidocument` VALUES ('3324837890621440000', 'SqlServer-事务', 'SqlServer-事务', 'SqlServer-事务', '<h1 id=\"h1-u4E8Bu52A1u652Fu6301\"><a name=\"事务支持\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>事务支持</h1><p><strong>基本用法：</strong></p>\n<pre><code class=\"lang-csharp\">using (MsSqlContext context = new MsSqlContext(DbHelper.ConnectionString))\n{\n    try\n    {\n        context.Session.BeginTransaction();\n\n        /* do some things here */\n        context.Update(user);\n        context.Delete&lt;User&gt;(a =&gt; a.Gender == null);\n\n        context.Session.CommitTransaction();\n    }\n    catch\n    {\n        if (context.Session.IsInTransaction)\n            context.Session.RollbackTransaction();\n        throw;\n    }\n}\n</code></pre>\n', '# 事务支持\n**基本用法：**\n```csharp\nusing (MsSqlContext context = new MsSqlContext(DbHelper.ConnectionString))\n{\n    try\n    {\n        context.Session.BeginTransaction();\n\n        /* do some things here */\n        context.Update(user);\n        context.Delete<User>(a => a.Gender == null);\n\n        context.Session.CommitTransaction();\n    }\n    catch\n    {\n        if (context.Session.IsInTransaction)\n            context.Session.RollbackTransaction();\n        throw;\n    }\n}\n```', '2016-12-01 19:18:47', '2016-12-02 14:24:54', '0', null);
INSERT INTO `wikidocument` VALUES ('3325141727961939968', 'SqlServer-常用函数', 'SqlServer-常用函数', 'SqlServer-常用函数', '<h1 id=\"h1-u5E38u7528u51FDu6570\"><a name=\"常用函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>常用函数</h1><p><strong>Chloe 对很多数据库函数支持很丰富，具体用法如下：</strong></p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nvar space = new char[] { &#39; &#39; };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = DateTime.Now.AddDays(1);\nq.Select(a =&gt; new\n{\n    Id = a.Id,\n\n    String_Length = (int?)a.Name.Length,//LEN([Users].[Name])\n    Substring = a.Name.Substring(0),//SUBSTRING([Users].[Name],0 + 1,LEN([Users].[Name]))\n    Substring1 = a.Name.Substring(1),//SUBSTRING([Users].[Name],1 + 1,LEN([Users].[Name]))\n    Substring1_2 = a.Name.Substring(1, 2),//SUBSTRING([Users].[Name],1 + 1,2)\n    ToLower = a.Name.ToLower(),//LOWER([Users].[Name])\n    ToUpper = a.Name.ToUpper(),//UPPER([Users].[Name])\n    IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//too long\n    Contains = (bool?)a.Name.Contains(&quot;s&quot;),//\n    Trim = a.Name.Trim(),//RTRIM(LTRIM([Users].[Name]))\n    TrimStart = a.Name.TrimStart(space),//LTRIM([Users].[Name])\n    TrimEnd = a.Name.TrimEnd(space),//RTRIM([Users].[Name])\n    StartsWith = (bool?)a.Name.StartsWith(&quot;s&quot;),//\n    EndsWith = (bool?)a.Name.EndsWith(&quot;s&quot;),//\n\n    DiffYears = DbFunctions.DiffYears(startTime, endTime),//DATEDIFF(YEAR,@P_0,@P_1)\n    DiffMonths = DbFunctions.DiffMonths(startTime, endTime),//DATEDIFF(MONTH,@P_0,@P_1)\n    DiffDays = DbFunctions.DiffDays(startTime, endTime),//DATEDIFF(DAY,@P_0,@P_1)\n    DiffHours = DbFunctions.DiffHours(startTime, endTime),//DATEDIFF(HOUR,@P_0,@P_1)\n    DiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//DATEDIFF(MINUTE,@P_0,@P_1)\n    DiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//DATEDIFF(SECOND,@P_0,@P_1)\n    DiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//DATEDIFF(MILLISECOND,@P_0,@P_1)\n    //DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//DATEDIFF(MICROSECOND,@P_0,@P_1)  Exception\n\n    AddYears = startTime.AddYears(1),//DATEADD(YEAR,1,@P_0)\n    AddMonths = startTime.AddMonths(1),//DATEADD(MONTH,1,@P_0)\n    AddDays = startTime.AddDays(1),//DATEADD(DAY,1,@P_0)\n    AddHours = startTime.AddHours(1),//DATEADD(HOUR,1,@P_0)\n    AddMinutes = startTime.AddMinutes(2),//DATEADD(MINUTE,2,@P_0)\n    AddSeconds = startTime.AddSeconds(120),//DATEADD(SECOND,120,@P_0)\n    AddMilliseconds = startTime.AddMilliseconds(20000),//DATEADD(MILLISECOND,20000,@P_0)\n\n    Now = DateTime.Now,//GETDATE()\n    UtcNow = DateTime.UtcNow,//GETUTCDATE()\n    Today = DateTime.Today,//CAST(GETDATE() AS DATE)\n    Date = DateTime.Now.Date,//CAST(GETDATE() AS DATE)\n    Year = DateTime.Now.Year,//DATEPART(YEAR,GETDATE())\n    Month = DateTime.Now.Month,//DATEPART(MONTH,GETDATE())\n    Day = DateTime.Now.Day,//DATEPART(DAY,GETDATE())\n    Hour = DateTime.Now.Hour,//DATEPART(HOUR,GETDATE())\n    Minute = DateTime.Now.Minute,//DATEPART(MINUTE,GETDATE())\n    Second = DateTime.Now.Second,//DATEPART(SECOND,GETDATE())\n    Millisecond = DateTime.Now.Millisecond,//DATEPART(MILLISECOND,GETDATE())\n    DayOfWeek = DateTime.Now.DayOfWeek,//(DATEPART(WEEKDAY,GETDATE()) - 1)\n\n    Int_Parse = int.Parse(&quot;1&quot;),//CAST(N&#39;1&#39; AS INT)\n    Int16_Parse = Int16.Parse(&quot;11&quot;),//CAST(N&#39;11&#39; AS SMALLINT)\n    Long_Parse = long.Parse(&quot;2&quot;),//CAST(N&#39;2&#39; AS BIGINT)\n    Double_Parse = double.Parse(&quot;3&quot;),//CAST(N&#39;3&#39; AS FLOAT)\n    Float_Parse = float.Parse(&quot;4&quot;),//CAST(N&#39;4&#39; AS REAL)\n    //Decimal_Parse = decimal.Parse(&quot;5&quot;),//CAST(N&#39;5&#39; AS DECIMAL)  ps: &#39;Decimal.Parse(string s)&#39; is not supported now,because we don&#39;t know the precision and scale information.\n    Guid_Parse = Guid.Parse(&quot;D544BC4C-739E-4CD3-A3D3-7BF803FCE179&quot;),//CAST(N&#39;D544BC4C-739E-4CD3-A3D3-7BF803FCE179&#39; AS UNIQUEIDENTIFIER) AS [Guid_Parse]\n\n    Bool_Parse = bool.Parse(&quot;1&quot;),//CASE WHEN CAST(N&#39;1&#39; AS BIT) = CAST(1 AS BIT) THEN CAST(1 AS BIT) WHEN NOT (CAST(N&#39;1&#39; AS BIT) = CAST(1 AS BIT)) THEN CAST(0 AS BIT) ELSE NULL END AS [Bool_Parse]\n    DateTime_Parse = DateTime.Parse(&quot;1992-1-16&quot;),//CAST(N&#39;1992-1-16&#39; AS DATETIME) AS [DateTime_Parse]\n\n    B = a.Age == null ? false : a.Age &gt; 1,\n}).ToList();\n</code></pre>\n<p>上述的函数可以用于 Select 方法，亦可用在 Where 或其它方法的 lambda 表达式树中，最终都会翻译成数据库函数。</p>\n', '# 常用函数\n**Chloe 对很多数据库函数支持很丰富，具体用法如下：**\n```csharp\nIQuery<User> q = context.Query<User>();\n\nvar space = new char[] { \' \' };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = DateTime.Now.AddDays(1);\nq.Select(a => new\n{\n    Id = a.Id,\n\n    String_Length = (int?)a.Name.Length,//LEN([Users].[Name])\n    Substring = a.Name.Substring(0),//SUBSTRING([Users].[Name],0 + 1,LEN([Users].[Name]))\n    Substring1 = a.Name.Substring(1),//SUBSTRING([Users].[Name],1 + 1,LEN([Users].[Name]))\n    Substring1_2 = a.Name.Substring(1, 2),//SUBSTRING([Users].[Name],1 + 1,2)\n    ToLower = a.Name.ToLower(),//LOWER([Users].[Name])\n    ToUpper = a.Name.ToUpper(),//UPPER([Users].[Name])\n    IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//too long\n    Contains = (bool?)a.Name.Contains(\"s\"),//\n    Trim = a.Name.Trim(),//RTRIM(LTRIM([Users].[Name]))\n    TrimStart = a.Name.TrimStart(space),//LTRIM([Users].[Name])\n    TrimEnd = a.Name.TrimEnd(space),//RTRIM([Users].[Name])\n    StartsWith = (bool?)a.Name.StartsWith(\"s\"),//\n    EndsWith = (bool?)a.Name.EndsWith(\"s\"),//\n\n    DiffYears = DbFunctions.DiffYears(startTime, endTime),//DATEDIFF(YEAR,@P_0,@P_1)\n    DiffMonths = DbFunctions.DiffMonths(startTime, endTime),//DATEDIFF(MONTH,@P_0,@P_1)\n    DiffDays = DbFunctions.DiffDays(startTime, endTime),//DATEDIFF(DAY,@P_0,@P_1)\n    DiffHours = DbFunctions.DiffHours(startTime, endTime),//DATEDIFF(HOUR,@P_0,@P_1)\n    DiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//DATEDIFF(MINUTE,@P_0,@P_1)\n    DiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//DATEDIFF(SECOND,@P_0,@P_1)\n    DiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//DATEDIFF(MILLISECOND,@P_0,@P_1)\n    //DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//DATEDIFF(MICROSECOND,@P_0,@P_1)  Exception\n\n    AddYears = startTime.AddYears(1),//DATEADD(YEAR,1,@P_0)\n    AddMonths = startTime.AddMonths(1),//DATEADD(MONTH,1,@P_0)\n    AddDays = startTime.AddDays(1),//DATEADD(DAY,1,@P_0)\n    AddHours = startTime.AddHours(1),//DATEADD(HOUR,1,@P_0)\n    AddMinutes = startTime.AddMinutes(2),//DATEADD(MINUTE,2,@P_0)\n    AddSeconds = startTime.AddSeconds(120),//DATEADD(SECOND,120,@P_0)\n    AddMilliseconds = startTime.AddMilliseconds(20000),//DATEADD(MILLISECOND,20000,@P_0)\n\n    Now = DateTime.Now,//GETDATE()\n    UtcNow = DateTime.UtcNow,//GETUTCDATE()\n    Today = DateTime.Today,//CAST(GETDATE() AS DATE)\n    Date = DateTime.Now.Date,//CAST(GETDATE() AS DATE)\n    Year = DateTime.Now.Year,//DATEPART(YEAR,GETDATE())\n    Month = DateTime.Now.Month,//DATEPART(MONTH,GETDATE())\n    Day = DateTime.Now.Day,//DATEPART(DAY,GETDATE())\n    Hour = DateTime.Now.Hour,//DATEPART(HOUR,GETDATE())\n    Minute = DateTime.Now.Minute,//DATEPART(MINUTE,GETDATE())\n    Second = DateTime.Now.Second,//DATEPART(SECOND,GETDATE())\n    Millisecond = DateTime.Now.Millisecond,//DATEPART(MILLISECOND,GETDATE())\n    DayOfWeek = DateTime.Now.DayOfWeek,//(DATEPART(WEEKDAY,GETDATE()) - 1)\n\n    Int_Parse = int.Parse(\"1\"),//CAST(N\'1\' AS INT)\n    Int16_Parse = Int16.Parse(\"11\"),//CAST(N\'11\' AS SMALLINT)\n    Long_Parse = long.Parse(\"2\"),//CAST(N\'2\' AS BIGINT)\n    Double_Parse = double.Parse(\"3\"),//CAST(N\'3\' AS FLOAT)\n    Float_Parse = float.Parse(\"4\"),//CAST(N\'4\' AS REAL)\n    //Decimal_Parse = decimal.Parse(\"5\"),//CAST(N\'5\' AS DECIMAL)  ps: \'Decimal.Parse(string s)\' is not supported now,because we don\'t know the precision and scale information.\n    Guid_Parse = Guid.Parse(\"D544BC4C-739E-4CD3-A3D3-7BF803FCE179\"),//CAST(N\'D544BC4C-739E-4CD3-A3D3-7BF803FCE179\' AS UNIQUEIDENTIFIER) AS [Guid_Parse]\n\n    Bool_Parse = bool.Parse(\"1\"),//CASE WHEN CAST(N\'1\' AS BIT) = CAST(1 AS BIT) THEN CAST(1 AS BIT) WHEN NOT (CAST(N\'1\' AS BIT) = CAST(1 AS BIT)) THEN CAST(0 AS BIT) ELSE NULL END AS [Bool_Parse]\n    DateTime_Parse = DateTime.Parse(\"1992-1-16\"),//CAST(N\'1992-1-16\' AS DATETIME) AS [DateTime_Parse]\n\n    B = a.Age == null ? false : a.Age > 1,\n}).ToList();\n```\n上述的函数可以用于 Select 方法，亦可用在 Where 或其它方法的 lambda 表达式树中，最终都会翻译成数据库函数。', '2016-12-02 15:26:07', '2016-12-02 15:26:21', '0', null);
INSERT INTO `wikidocument` VALUES ('3325145692988506112', 'MySql-实体特性', 'MySql-实体特性', 'MySql-实体特性', '<h1 id=\"h1-u5B9Eu4F53u7279u6027\"><a name=\"实体特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实体特性</h1><p>实体特性位于命名空间 Chloe.Entity 下。<br><strong>TableAttribute：</strong><br>Name：映射的表名。<br>实体对应的表默认是实体类名，如实体类型名与表名不一致，可通过该特性指定映射的表名。</p>\n<pre><code class=\"lang-csharp\">public class TableAttribute : Attribute\n{\n    public TableAttribute() { }\n    public TableAttribute(string name)\n    {\n        Name = name;\n    }\n    public string Name { get; set; }\n}\n</code></pre>\n<p><strong>ColumnAttribute：</strong><br>Name：映射的列名，如不指定，则默认使用属性名。<br>IsPrimaryKey：指示列是否为主键，默认为 false。<br>当一个实体没显示指定主键的时候，Chloe 默认选择名为 Id 的属性（如果存在）作为主键列，与此同时，如果该实体也没有显示指定任何自增列并且 Id 属性为 Int16、Int32 或者 Int64 类型，则也会默认其为自增列。</p>\n<pre><code class=\"lang-csharp\">public class ColumnAttribute : Attribute\n{\n    public ColumnAttribute() { }\n    public ColumnAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; set; }\n    public bool IsPrimaryKey { get; set; }\n}\n</code></pre>\n<p><strong>AutoIncrementAttribute：</strong><br>标记属性为自增列。在 SqlServer 中，一个实体不能指定多个自增列，否则会报异常提示。</p>\n<pre><code class=\"lang-csharp\">public class AutoIncrementAttribute : Attribute\n{\n}\n</code></pre>\n<p><strong>NonAutoIncrementAttribute：</strong><br>标记属性为非自增列。</p>\n<pre><code class=\"lang-csharp\">public class NonAutoIncrementAttribute : Attribute\n{\n}\n</code></pre>\n<p><strong>NotMappedAttribute：</strong><br>指示属性不映射任何列。</p>\n<pre><code class=\"lang-csharp\">public class NotMappedAttribute : Attribute\n{\n}\n</code></pre>\n', '# 实体特性\n实体特性位于命名空间 Chloe.Entity 下。\n**TableAttribute：**\nName：映射的表名。\n实体对应的表默认是实体类名，如实体类型名与表名不一致，可通过该特性指定映射的表名。\n```csharp\npublic class TableAttribute : Attribute\n{\n    public TableAttribute() { }\n    public TableAttribute(string name)\n    {\n        Name = name;\n    }\n    public string Name { get; set; }\n}\n```\n**ColumnAttribute：**\nName：映射的列名，如不指定，则默认使用属性名。\nIsPrimaryKey：指示列是否为主键，默认为 false。\n当一个实体没显示指定主键的时候，Chloe 默认选择名为 Id 的属性（如果存在）作为主键列，与此同时，如果该实体也没有显示指定任何自增列并且 Id 属性为 Int16、Int32 或者 Int64 类型，则也会默认其为自增列。\n```csharp\npublic class ColumnAttribute : Attribute\n{\n    public ColumnAttribute() { }\n    public ColumnAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; set; }\n    public bool IsPrimaryKey { get; set; }\n}\n```\n**AutoIncrementAttribute：**\n标记属性为自增列。在 SqlServer 中，一个实体不能指定多个自增列，否则会报异常提示。\n```csharp\npublic class AutoIncrementAttribute : Attribute\n{\n}\n```\n**NonAutoIncrementAttribute：**\n标记属性为非自增列。\n```csharp\npublic class NonAutoIncrementAttribute : Attribute\n{\n}\n```\n**NotMappedAttribute：**\n指示属性不映射任何列。\n```csharp\npublic class NotMappedAttribute : Attribute\n{\n}\n```', '2016-12-02 15:41:52', '2016-12-02 19:32:29', '0', null);
INSERT INTO `wikidocument` VALUES ('3325145777671503872', 'MySql-实体定义', 'MySql-实体定义', 'MySql-实体定义', '<h1 id=\"h1-u5B9Eu4F53u5B9Au4E49\"><a name=\"实体定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实体定义</h1><p>实体为纯 POCO，支持可空类型以及枚举类型映射。</p>\n<pre><code class=\"lang-csharp\">public enum Gender\n{\n    Man = 1,\n    Woman\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">[TableAttribute(&quot;Users&quot;)]\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">public class City\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">public class Province\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n</code></pre>\n', '# 实体定义\n实体为纯 POCO，支持可空类型以及枚举类型映射。\n```csharp\npublic enum Gender\n{\n    Man = 1,\n    Woman\n}\n```\n```csharp\n[TableAttribute(\"Users\")]\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n```\n```csharp\npublic class City\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n```\n```csharp\npublic class Province\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n```', '2016-12-02 15:42:13', '2016-12-02 16:33:41', '0', null);
INSERT INTO `wikidocument` VALUES ('3325145866628497408', 'MySql-创建DbContext', 'MySql-创建DbContext', 'MySql-创建DbContext', '<h1 id=\"h1--dbcontext\"><a name=\"创建 DbContext\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建 DbContext</h1><p>对于 MySql 数据库，需要引用程序集 Chloe.dll 和 Chloe.MySql.dll，然后使用 Chloe.MySql.MySqlContext 创建上下文实例。<br>因为框架本身需要与具体的数据库驱动解耦，所以 MySqlContext 构造函数需要一个 IDbConnectionFactory 的参数，IDbConnectionFactory 接口只有一个 CreateConnection() 方法，必须先建个类，实现 CreateConnection 方法。</p>\n<pre><code class=\"lang-csharp\">public class MySqlConnectionFactory : IDbConnectionFactory\n{\n    string _connString = null;\n    public MySqlConnectionFactory(string connString)\n    {\n        this._connString = connString;\n    }\n    public IDbConnection CreateConnection()\n    {\n        MySqlConnection conn = new MySqlConnection(this._connString);\n        return conn;\n    }\n}\n</code></pre>\n<p>接下来就可以创建 MySqlContext：</p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nMySqlContext context = new MySqlContext(new MySqlConnectionFactory(connString));\n</code></pre>\n', '# 创建 DbContext\n对于 MySql 数据库，需要引用程序集 Chloe.dll 和 Chloe.MySql.dll，然后使用 Chloe.MySql.MySqlContext 创建上下文实例。\n因为框架本身需要与具体的数据库驱动解耦，所以 MySqlContext 构造函数需要一个 IDbConnectionFactory 的参数，IDbConnectionFactory 接口只有一个 CreateConnection() 方法，必须先建个类，实现 CreateConnection 方法。\n```csharp\npublic class MySqlConnectionFactory : IDbConnectionFactory\n{\n    string _connString = null;\n    public MySqlConnectionFactory(string connString)\n    {\n        this._connString = connString;\n    }\n    public IDbConnection CreateConnection()\n    {\n        MySqlConnection conn = new MySqlConnection(this._connString);\n        return conn;\n    }\n}\n```\n接下来就可以创建 MySqlContext：\n```csharp\nstring connString = \"Your connection string\";\nMySqlContext context = new MySqlContext(new MySqlConnectionFactory(connString));\n```', '2016-12-02 15:42:34', '2016-12-02 19:00:13', '0', null);
INSERT INTO `wikidocument` VALUES ('3325145930688102400', 'MySql-基本查询', 'MySql-基本查询', 'MySql-基本查询', '<h1 id=\"h1-u57FAu672Cu67E5u8BE2\"><a name=\"基本查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本查询</h1><p><strong>根据 Id 查询出一个 User 对象：</strong></p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nMySqlContext context = new MySqlContext(new MySqlConnectionFactory(connString));\nIQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nq.Where(a =&gt; a.Id == 1).FirstOrDefault();\n/*\n *生成的 sql：\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` = 1 \n   LIMIT 0,1\n */\n</code></pre>\n<p><strong>in 查询：</strong></p>\n<pre><code class=\"lang-csharp\">List&lt;int&gt; ids = new List&lt;int&gt;() { 1, 2, 3 };\nq.Where(a =&gt; ids.Contains(a.Id)).ToList();\n/*\n * Int32 ?P_0 = 1;\n   Int32 ?P_1 = 2;\n   Int32 ?P_2 = 3;\n   SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` IN (?P_0,?P_1,?P_2)\n */\n</code></pre>\n<p><strong>可以选取指定的字段，返回一个匿名类型：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id == 1).Select(a =&gt; new { a.Id, a.Name }).FirstOrDefault();\n/*\n * 只会生成包含 Id 和 Name 两个字段的 sql 语句：\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` = 1 \n   LIMIT 0,1\n */\n</code></pre>\n<p><strong>排序：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).ThenBy(a =&gt; a.Id).ToList();\n/*\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` &gt; 0 \n   ORDER BY `Users`.`Age` ASC，`Id` ASC\n */\n</code></pre>\n<p><strong>分页：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).TakePage(1, 20).ToList();\n/*\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime`\n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` &gt; 0 \n   ORDER BY `Users`.`Age` ASC \n   LIMIT 0,20\n */\n</code></pre>\n', '# 基本查询\n**根据 Id 查询出一个 User 对象：**\n```csharp\nstring connString = \"Your connection string\";\nMySqlContext context = new MySqlContext(new MySqlConnectionFactory(connString));\nIQuery<User> q = context.Query<User>();\n\nq.Where(a => a.Id == 1).FirstOrDefault();\n/*\n *生成的 sql：\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` = 1 \n   LIMIT 0,1\n */\n```\n**in 查询：**\n```csharp\nList<int> ids = new List<int>() { 1, 2, 3 };\nq.Where(a => ids.Contains(a.Id)).ToList();\n/*\n * Int32 ?P_0 = 1;\n   Int32 ?P_1 = 2;\n   Int32 ?P_2 = 3;\n   SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` IN (?P_0,?P_1,?P_2)\n */\n```\n**可以选取指定的字段，返回一个匿名类型：**\n```csharp\nq.Where(a => a.Id == 1).Select(a => new { a.Id, a.Name }).FirstOrDefault();\n/*\n * 只会生成包含 Id 和 Name 两个字段的 sql 语句：\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` = 1 \n   LIMIT 0,1\n */\n```\n**排序：**\n```csharp\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).ThenBy(a => a.Id).ToList();\n/*\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` > 0 \n   ORDER BY `Users`.`Age` ASC，`Id` ASC\n */\n```\n**分页：**\n```csharp\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).TakePage(1, 20).ToList();\n/*\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime`\n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` > 0 \n   ORDER BY `Users`.`Age` ASC \n   LIMIT 0,20\n */\n```', '2016-12-02 15:42:49', '2016-12-08 11:40:34', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146061768491008', 'MySql-连接查询', 'MySql-连接查询', 'MySql-连接查询', '<h1 id=\"h1-u8FDEu63A5u67E5u8BE2\"><a name=\"连接查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>连接查询</h1><p>Chloe 友好支持多表连接查询，一切都可以用 lambda 表达式操作，返回类型可以是自定义类型，也可以是匿名类型。强类型开发，编译可见错误，容错率高。<br><strong>1.创建相关的 IQuery 对象：</strong></p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; users = context.Query&lt;User&gt;();\nIQuery&lt;City&gt; cities = context.Query&lt;City&gt;();\nIQuery&lt;Province&gt; provinces = context.Query&lt;Province&gt;();\n</code></pre>\n<p><strong>2.建立连接：</strong></p>\n<pre><code class=\"lang-csharp\">/* User 表和 City 表 inner join，得到 IJoiningQuery&lt;User, City&gt; 对象 */\nIJoiningQuery&lt;User, City&gt; user_city = users.InnerJoin(cities, (user, city) =&gt; user.CityId == city.Id);\n\n/* City 表和 Province 表 inner join，得到 IJoiningQuery&lt;User, City, Province&gt; 对象 */\nIJoiningQuery&lt;User, City, Province&gt; user_city_province = user_city.InnerJoin(provinces, (user, city, province) =&gt; city.ProvinceId == province.Id);\n</code></pre>\n<p><strong>3.得到最终的 IJoiningQuery 对象，就可以 Select 所需要的数据返回一个 IQuery 对象，然后就可以进行 Where、OrderBy、GroupBy、分页、聚合查询等操作：</strong><br>查出一个用户及其隶属的城市和省份的所有信息：</p>\n<pre><code class=\"lang-csharp\">/* 调用 Select 方法返回一个泛型为包含 User、City、Province 匿名类型的 IQuery 对象。\n * Select 方法也可以返回自定义类型 。\n */\nvar qq = user_city_province.Select((user, city, province) =&gt; new\n{\n    User = user,\n    City = city,\n    Province = province\n});\n\n/* 根据条件筛选，然后调用 ToList 就会返回一个泛型为 new { User = user, City = city, Province = province } 的 List 集合 */\nvar result = qq.Where(a =&gt; a.User.Id == 1).ToList();\n\n/*\n * 生成的 sql：\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime`,`City`.`Id` AS `Id0`,`City`.`Name` AS `Name0`,`City`.`ProvinceId` AS `ProvinceId`,`Province`.`Id` AS `Id1`,`Province`.`Name` AS `Name1` \n   FROM `Users` AS `Users` \n   INNER JOIN `City` AS `City` ON `Users`.`CityId` = `City`.`Id` \n   INNER JOIN `Province` AS `Province` ON `City`.`ProvinceId` = `Province`.`Id` \n   WHERE `Users`.`Id` = 1\n */\n</code></pre>\n<p>可以只获取指定的字段信息：</p>\n<pre><code class=\"lang-csharp\">user_city_province.Select((user, city, province) =&gt; new\n{\n    UserId = user.Id,\n    UserName = user.Name,\n    CityName = city.Name,\n    ProvinceName = province.Name\n}).Where(a =&gt; a.UserId == 1).ToList();\n\n/*\n * 生成的 sql 只会包含 UserId、UserName、CityName、ProvinceName 四个字段\n * SELECT `Users`.`Id` AS `UserId`,`Users`.`Name` AS `UserName`,`City`.`Name` AS `CityName`,`Province`.`Name` AS `ProvinceName` \n   FROM `Users` AS `Users` \n   INNER JOIN `City` AS `City` ON `Users`.`CityId` = `City`.`Id` \n   INNER JOIN `Province` AS `Province` ON `City`.`ProvinceId` = `Province`.`Id` \n   WHERE `Users`.`Id` = 1\n */\n</code></pre>\n<p>框架亦支持左连接、右连接查询，用法和内连接相同。</p>\n', '# 连接查询\nChloe 友好支持多表连接查询，一切都可以用 lambda 表达式操作，返回类型可以是自定义类型，也可以是匿名类型。强类型开发，编译可见错误，容错率高。\n**1.创建相关的 IQuery 对象：**\n```csharp\nIQuery<User> users = context.Query<User>();\nIQuery<City> cities = context.Query<City>();\nIQuery<Province> provinces = context.Query<Province>();\n```\n**2.建立连接：**\n```csharp\n/* User 表和 City 表 inner join，得到 IJoiningQuery<User, City> 对象 */\nIJoiningQuery<User, City> user_city = users.InnerJoin(cities, (user, city) => user.CityId == city.Id);\n\n/* City 表和 Province 表 inner join，得到 IJoiningQuery<User, City, Province> 对象 */\nIJoiningQuery<User, City, Province> user_city_province = user_city.InnerJoin(provinces, (user, city, province) => city.ProvinceId == province.Id);\n```\n**3.得到最终的 IJoiningQuery 对象，就可以 Select 所需要的数据返回一个 IQuery 对象，然后就可以进行 Where、OrderBy、GroupBy、分页、聚合查询等操作：**\n查出一个用户及其隶属的城市和省份的所有信息：\n```csharp\n/* 调用 Select 方法返回一个泛型为包含 User、City、Province 匿名类型的 IQuery 对象。\n * Select 方法也可以返回自定义类型 。\n */\nvar qq = user_city_province.Select((user, city, province) => new\n{\n    User = user,\n    City = city,\n    Province = province\n});\n\n/* 根据条件筛选，然后调用 ToList 就会返回一个泛型为 new { User = user, City = city, Province = province } 的 List 集合 */\nvar result = qq.Where(a => a.User.Id == 1).ToList();\n\n/*\n * 生成的 sql：\n * SELECT `Users`.`Id` AS `Id`,`Users`.`Name` AS `Name`,`Users`.`Gender` AS `Gender`,`Users`.`Age` AS `Age`,`Users`.`CityId` AS `CityId`,`Users`.`OpTime` AS `OpTime`,`City`.`Id` AS `Id0`,`City`.`Name` AS `Name0`,`City`.`ProvinceId` AS `ProvinceId`,`Province`.`Id` AS `Id1`,`Province`.`Name` AS `Name1` \n   FROM `Users` AS `Users` \n   INNER JOIN `City` AS `City` ON `Users`.`CityId` = `City`.`Id` \n   INNER JOIN `Province` AS `Province` ON `City`.`ProvinceId` = `Province`.`Id` \n   WHERE `Users`.`Id` = 1\n */\n```\n可以只获取指定的字段信息：\n```csharp\nuser_city_province.Select((user, city, province) => new\n{\n    UserId = user.Id,\n    UserName = user.Name,\n    CityName = city.Name,\n    ProvinceName = province.Name\n}).Where(a => a.UserId == 1).ToList();\n\n/*\n * 生成的 sql 只会包含 UserId、UserName、CityName、ProvinceName 四个字段\n * SELECT `Users`.`Id` AS `UserId`,`Users`.`Name` AS `UserName`,`City`.`Name` AS `CityName`,`Province`.`Name` AS `ProvinceName` \n   FROM `Users` AS `Users` \n   INNER JOIN `City` AS `City` ON `Users`.`CityId` = `City`.`Id` \n   INNER JOIN `Province` AS `Province` ON `City`.`ProvinceId` = `Province`.`Id` \n   WHERE `Users`.`Id` = 1\n */\n```\n框架亦支持左连接、右连接查询，用法和内连接相同。', '2016-12-02 15:43:20', '2016-12-03 14:20:34', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146123546394624', 'MySql-分组查询', 'MySql-分组查询', 'MySql-分组查询', '<h1 id=\"h1-u5206u7EC4u67E5u8BE2\"><a name=\"分组查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分组查询</h1><p>Chloe 支持分组查询以及分组后 Having 过滤和聚合查询。</p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nIGroupingQuery&lt;User&gt; g = q.Where(a =&gt; a.Id &gt; 0).GroupBy(a =&gt; a.Age);\ng = g.Having(a =&gt; a.Age &gt; 1 &amp;&amp; AggregateFunctions.Count() &gt; 0);\n\ng.Select(a =&gt; new\n{\n    a.Age,\n    Count = AggregateFunctions.Count(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Avg = AggregateFunctions.Average(a.Age)\n}).ToList();\n/*\n * SELECT `Users`.`Age` AS `Age`,COUNT(1) AS `Count`,CAST(SUM(`Users`.`Age`) AS SIGNED) AS `Sum`,MAX(`Users`.`Age`) AS `Max`,MIN(`Users`.`Age`) AS `Min`,AVG(`Users`.`Age`) AS `Avg` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` &gt; 0 \n   GROUP BY `Users`.`Age` \n   HAVING (`Users`.`Age` &gt; 1 AND COUNT(1) &gt; 0)\n */\n</code></pre>\n', '# 分组查询\nChloe 支持分组查询以及分组后 Having 过滤和聚合查询。\n```csharp\nIQuery<User> q = context.Query<User>();\n\nIGroupingQuery<User> g = q.Where(a => a.Id > 0).GroupBy(a => a.Age);\ng = g.Having(a => a.Age > 1 && AggregateFunctions.Count() > 0);\n\ng.Select(a => new\n{\n    a.Age,\n    Count = AggregateFunctions.Count(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Avg = AggregateFunctions.Average(a.Age)\n}).ToList();\n/*\n * SELECT `Users`.`Age` AS `Age`,COUNT(1) AS `Count`,CAST(SUM(`Users`.`Age`) AS SIGNED) AS `Sum`,MAX(`Users`.`Age`) AS `Max`,MIN(`Users`.`Age`) AS `Min`,AVG(`Users`.`Age`) AS `Avg` \n   FROM `Users` AS `Users` \n   WHERE `Users`.`Id` > 0 \n   GROUP BY `Users`.`Age` \n   HAVING (`Users`.`Age` > 1 AND COUNT(1) > 0)\n */\n```', '2016-12-02 15:43:35', '2016-12-02 19:11:01', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146192995680256', 'MySql-聚合查询', 'MySql-聚合查询', 'MySql-聚合查询', '<h1 id=\"h1-u805Au5408u67E5u8BE2\"><a name=\"聚合查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>聚合查询</h1><p>Chloe 可以像写 sql 一样实现聚合查询。</p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nq.Select(a =&gt; AggregateFunctions.Count()).First();\n/*\n * SELECT COUNT(1) AS `C` FROM `Users` AS `Users` LIMIT 0,1\n */\n\n/* 支持多个聚合函数 */\nq.Select(a =&gt; new\n{\n    Count = AggregateFunctions.Count(),\n    LongCount = AggregateFunctions.LongCount(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Average = AggregateFunctions.Average(a.Age)\n}).First();\n/*\n * SELECT COUNT(1) AS `Count`,COUNT(1) AS `LongCount`,CAST(SUM(`Users`.`Age`) AS SIGNED) AS `Sum`,MAX(`Users`.`Age`) AS `Max`,MIN(`Users`.`Age`) AS `Min`,AVG(`Users`.`Age`) AS `Average` \n   FROM `Users` AS `Users` LIMIT 0,1\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS `C` FROM `Users` AS `Users`\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT(1) AS `C` FROM `Users` AS `Users`\n */\n\nvar sum = q.Sum(a =&gt; a.Age);\n/*\n * SELECT CAST(SUM(`Users`.`Age`) AS SIGNED) AS `C` FROM `Users` AS `Users`\n */\n\nvar max = q.Max(a =&gt; a.Age);\n/*\n * SELECT MAX(`Users`.`Age`) AS `C` FROM `Users` AS `Users`\n */\n\nvar min = q.Min(a =&gt; a.Age);\n/*\n * SELECT MIN(`Users`.`Age`) AS `C` FROM `Users` AS `Users`\n */\n\nvar avg = q.Average(a =&gt; a.Age);\n/*\n * SELECT AVG(`Users`.`Age`) AS `C` FROM `Users` AS `Users`\n */\n</code></pre>\n', '# 聚合查询\nChloe 可以像写 sql 一样实现聚合查询。\n```csharp\nIQuery<User> q = context.Query<User>();\n\nq.Select(a => AggregateFunctions.Count()).First();\n/*\n * SELECT COUNT(1) AS `C` FROM `Users` AS `Users` LIMIT 0,1\n */\n\n/* 支持多个聚合函数 */\nq.Select(a => new\n{\n    Count = AggregateFunctions.Count(),\n    LongCount = AggregateFunctions.LongCount(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Average = AggregateFunctions.Average(a.Age)\n}).First();\n/*\n * SELECT COUNT(1) AS `Count`,COUNT(1) AS `LongCount`,CAST(SUM(`Users`.`Age`) AS SIGNED) AS `Sum`,MAX(`Users`.`Age`) AS `Max`,MIN(`Users`.`Age`) AS `Min`,AVG(`Users`.`Age`) AS `Average` \n   FROM `Users` AS `Users` LIMIT 0,1\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS `C` FROM `Users` AS `Users`\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT(1) AS `C` FROM `Users` AS `Users`\n */\n\nvar sum = q.Sum(a => a.Age);\n/*\n * SELECT CAST(SUM(`Users`.`Age`) AS SIGNED) AS `C` FROM `Users` AS `Users`\n */\n\nvar max = q.Max(a => a.Age);\n/*\n * SELECT MAX(`Users`.`Age`) AS `C` FROM `Users` AS `Users`\n */\n\nvar min = q.Min(a => a.Age);\n/*\n * SELECT MIN(`Users`.`Age`) AS `C` FROM `Users` AS `Users`\n */\n\nvar avg = q.Average(a => a.Age);\n/*\n * SELECT AVG(`Users`.`Age`) AS `C` FROM `Users` AS `Users`\n */\n```', '2016-12-02 15:43:52', '2016-12-02 19:12:43', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146263711645696', 'MySql-Sql查询', 'MySql-Sql查询', 'MySql-Sql查询', '<h1 id=\"h1-sql-\"><a name=\"Sql查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Sql查询</h1><p>对于一些极其复杂的 sql 查询，还是得依赖原生 sql，因此，Chloe 提供了原生 sql 查询接口。<br><strong>获取满足条件的用户信息，将结果映射到 User 类上：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;User&gt;(&quot;select * from Users where Age&gt;?age&quot;, new DbParam(&quot;?age&quot;, 18)).ToList();\n</code></pre>\n<p><strong>获取满足条件的用户 Id：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;int&gt;(&quot;select Id from Users where Age&gt;?age&quot;, new DbParam(&quot;?age&quot;, 18)).ToList();\n</code></pre>\n<p><strong>支持存储过程：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;User&gt;(&quot;Proc_Test&quot;, CommandType.StoredProcedure, new DbParam(&quot;?age&quot;, 18)).ToList();\n</code></pre>\n', '# Sql查询\n对于一些极其复杂的 sql 查询，还是得依赖原生 sql，因此，Chloe 提供了原生 sql 查询接口。\n**获取满足条件的用户信息，将结果映射到 User 类上：**\n```csharp\ncontext.SqlQuery<User>(\"select * from Users where Age>?age\", new DbParam(\"?age\", 18)).ToList();\n```\n**获取满足条件的用户 Id：**\n```csharp\ncontext.SqlQuery<int>(\"select Id from Users where Age>?age\", new DbParam(\"?age\", 18)).ToList();\n```\n**支持存储过程：**\n```csharp\ncontext.SqlQuery<User>(\"Proc_Test\", CommandType.StoredProcedure, new DbParam(\"?age\", 18)).ToList();\n```', '2016-12-02 15:44:09', '2016-12-02 19:13:57', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146327683170304', 'MySql-插入数据', 'MySql-插入数据', 'MySql-插入数据', '<h1 id=\"h1-u63D2u5165u6570u636E\"><a name=\"插入数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>插入数据</h1><p>Chloe 具备两种插入数据的方式。<br><strong>1.实体插入：</strong><br>该方式插入，如果一个实体存在自增列，会自动将自增列设置到相应的属性上。</p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Name = &quot;lu&quot;;\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = DateTime.Now;\n\n/* 会自动将自增 Id 设置到 user 的 Id 属性上 */\nuser = context.Insert(user);\n/*\n * String ?P_0 = &#39;lu&#39;;\n   Gender ?P_1 = Man;\n   Int32 ?P_2 = 18;\n   Int32 ?P_3 = 1;\n   DateTime ?P_4 = &#39;2016/8/26 18:11:26&#39;;\n   INSERT INTO `Users`(`Name`,`Gender`,`Age`,`CityId`,`OpTime`) \n   VALUES(?P_0,?P_1,?P_2,?P_3,?P_4);SELECT @@IDENTITY\n */\n</code></pre>\n<p><strong>2.lambda 方式插入：</strong><br>此种方式插入的好处是，可以指定列插入，就像写 sql 一样简单。<br>同时，该方式插入返回表主键值。如果实体主键是自增列，返回值就会是自增值。</p>\n<pre><code class=\"lang-csharp\">/* 返回主键 Id */\nint id = (int)context.Insert&lt;User&gt;(() =&gt; new User()\n{\n    Name = &quot;lu&quot;,\n    Age = 18,\n    Gender = Gender.Man,\n    CityId = 1,\n    OpTime = DateTime.Now\n});\n/*\n * INSERT INTO `Users`(`Name`,`Age`,`Gender`,`CityId`,`OpTime`) \n   VALUES(N&#39;lu&#39;,18,1,1,NOW());SELECT @@IDENTITY\n */\n</code></pre>\n', '# 插入数据\nChloe 具备两种插入数据的方式。\n**1.实体插入：**\n该方式插入，如果一个实体存在自增列，会自动将自增列设置到相应的属性上。\n```csharp\nUser user = new User();\nuser.Name = \"lu\";\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = DateTime.Now;\n\n/* 会自动将自增 Id 设置到 user 的 Id 属性上 */\nuser = context.Insert(user);\n/*\n * String ?P_0 = \'lu\';\n   Gender ?P_1 = Man;\n   Int32 ?P_2 = 18;\n   Int32 ?P_3 = 1;\n   DateTime ?P_4 = \'2016/8/26 18:11:26\';\n   INSERT INTO `Users`(`Name`,`Gender`,`Age`,`CityId`,`OpTime`) \n   VALUES(?P_0,?P_1,?P_2,?P_3,?P_4);SELECT @@IDENTITY\n */\n```\n**2.lambda 方式插入：**\n此种方式插入的好处是，可以指定列插入，就像写 sql 一样简单。\n同时，该方式插入返回表主键值。如果实体主键是自增列，返回值就会是自增值。\n```csharp\n/* 返回主键 Id */\nint id = (int)context.Insert<User>(() => new User()\n{\n    Name = \"lu\",\n    Age = 18,\n    Gender = Gender.Man,\n    CityId = 1,\n    OpTime = DateTime.Now\n});\n/*\n * INSERT INTO `Users`(`Name`,`Age`,`Gender`,`CityId`,`OpTime`) \n   VALUES(N\'lu\',18,1,1,NOW());SELECT @@IDENTITY\n */\n```', '2016-12-02 15:44:24', '2016-12-03 15:12:00', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146391176544256', 'MySql-更新数据', 'MySql-更新数据', 'MySql-更新数据', '<h1 id=\"h1-u66F4u65B0u6570u636E\"><a name=\"更新数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更新数据</h1><p>Chloe 支持两种数据更新方式。<br><strong>1.实体更新：</strong></p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Id = 1;\nuser.Name = &quot;lu&quot;;\nuser.Age = 28;\nuser.Gender = Gender.Man;\nuser.OpTime = DateTime.Now;\n\n/* 更新所有映射的字段 */\ncontext.Update(user);\n/*\n * String ?P_0 = &#39;lu&#39;;\n   Gender ?P_1 = Man;\n   Int32 ?P_2 = 28;\n   Nullable&lt;Int32&gt; ?P_3 = NULL;\n   DateTime ?P_4 = &#39;2016/8/26 18:18:36&#39;;\n   Int32 ?P_5 = 1;\n   UPDATE `Users` SET `Name`=?P_0,`Gender`=?P_1,`Age`=?P_2,`CityId`=?P_3,`OpTime`=?P_4 \n   WHERE `Users`.`Id` = ?P_5\n */\n</code></pre>\n<p>由于 user 对象未被上下文跟踪，这会使所有的映射列都会被更新。Chloe 也支持类似 EF 一样只更新被修改过的属性。</p>\n<pre><code class=\"lang-csharp\">/*\n * 支持只更新属性值已变的属性\n */\n\n/* 在修改实体属性前让上下文跟踪实体 */\ncontext.TrackEntity(user);\n\n/* 然后再修改实体属性 */\nuser.Name = user.Name + &quot;1&quot;;\n\n/* 然后调用 Update 方法，这时只会更新被修改过的属性 */\ncontext.Update(user);\n/*\n * String ?P_0 = &#39;lu1&#39;;\n   Int32 ?P_1 = 1;\n   UPDATE `Users` SET `Name`=?P_0 WHERE `Users`.`Id` = ?P_1\n */\n</code></pre>\n<p><strong>2.lambda 方式更新：</strong><br>该方式解决的问题是：1.指定列更新；2.批量更新；3.支持类似 Age=Age + 100 这样更新字段。用法如下：</p>\n<pre><code class=\"lang-csharp\">context.Update&lt;User&gt;(a =&gt; a.Age &gt; 18, a =&gt; new User()\n{\n    Name = a.Name,\n    Age = a.Age + 100,\n    Gender = Gender.Man,\n    OpTime = DateTime.Now\n});\n/*\n * UPDATE `Users` SET `Name`=`Users`.`Name`,`Age`=(`Users`.`Age` + 100),`Gender`=1,`OpTime`=NOW() \n   WHERE `Users`.`Age` &gt; 18\n */\n</code></pre>\n', '# 更新数据\nChloe 支持两种数据更新方式。\n**1.实体更新：**\n```csharp\nUser user = new User();\nuser.Id = 1;\nuser.Name = \"lu\";\nuser.Age = 28;\nuser.Gender = Gender.Man;\nuser.OpTime = DateTime.Now;\n\n/* 更新所有映射的字段 */\ncontext.Update(user);\n/*\n * String ?P_0 = \'lu\';\n   Gender ?P_1 = Man;\n   Int32 ?P_2 = 28;\n   Nullable<Int32> ?P_3 = NULL;\n   DateTime ?P_4 = \'2016/8/26 18:18:36\';\n   Int32 ?P_5 = 1;\n   UPDATE `Users` SET `Name`=?P_0,`Gender`=?P_1,`Age`=?P_2,`CityId`=?P_3,`OpTime`=?P_4 \n   WHERE `Users`.`Id` = ?P_5\n */\n```\n由于 user 对象未被上下文跟踪，这会使所有的映射列都会被更新。Chloe 也支持类似 EF 一样只更新被修改过的属性。\n```csharp\n/*\n * 支持只更新属性值已变的属性\n */\n\n/* 在修改实体属性前让上下文跟踪实体 */\ncontext.TrackEntity(user);\n\n/* 然后再修改实体属性 */\nuser.Name = user.Name + \"1\";\n\n/* 然后调用 Update 方法，这时只会更新被修改过的属性 */\ncontext.Update(user);\n/*\n * String ?P_0 = \'lu1\';\n   Int32 ?P_1 = 1;\n   UPDATE `Users` SET `Name`=?P_0 WHERE `Users`.`Id` = ?P_1\n */\n```\n**2.lambda 方式更新：**\n该方式解决的问题是：1.指定列更新；2.批量更新；3.支持类似 Age=Age + 100 这样更新字段。用法如下：\n```csharp\ncontext.Update<User>(a => a.Age > 18, a => new User()\n{\n    Name = a.Name,\n    Age = a.Age + 100,\n    Gender = Gender.Man,\n    OpTime = DateTime.Now\n});\n/*\n * UPDATE `Users` SET `Name`=`Users`.`Name`,`Age`=(`Users`.`Age` + 100),`Gender`=1,`OpTime`=NOW() \n   WHERE `Users`.`Age` > 18\n */\n```', '2016-12-02 15:44:39', '2016-12-02 19:21:38', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146449968103424', 'MySql-删除数据', 'MySql-删除数据', 'MySql-删除数据', '<h1 id=\"h1-u5220u9664u6570u636E\"><a name=\"删除数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除数据</h1><p>Chloe 支持两种数据删除方式。<br><strong>1.实体删除：</strong><br>该方式删除必须要求实体拥有一个主键，否则会报异常提示。</p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 ?P_0 = 1;\n   DELETE `Users` FROM `Users` WHERE `Users`.`Id` = ?P_0\n */\n</code></pre>\n<p><strong>2.lambda 方式删除：</strong><br>使用该方式可以删除单条数据，也可以删除多条数据。</p>\n<pre><code class=\"lang-csharp\">/* 删除单条数据 */\ncontext.Delete&lt;User&gt;(a =&gt; a.Id == 1);\n/*\n * DELETE `Users` FROM `Users` WHERE `Users`.`Id` = 1\n */\n\n/* 批量删除满足条件的数据 */\ncontext.Delete&lt;User&gt;(a =&gt; a.Age &gt; 18);\n/*\n * DELETE `Users` FROM `Users` WHERE `Users`.`Age` &gt; 18\n */\n</code></pre>\n', '# 删除数据\nChloe 支持两种数据删除方式。\n**1.实体删除：**\n该方式删除必须要求实体拥有一个主键，否则会报异常提示。\n```csharp\nUser user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 ?P_0 = 1;\n   DELETE `Users` FROM `Users` WHERE `Users`.`Id` = ?P_0\n */\n```\n**2.lambda 方式删除：**\n使用该方式可以删除单条数据，也可以删除多条数据。\n```csharp\n/* 删除单条数据 */\ncontext.Delete<User>(a => a.Id == 1);\n/*\n * DELETE `Users` FROM `Users` WHERE `Users`.`Id` = 1\n */\n\n/* 批量删除满足条件的数据 */\ncontext.Delete<User>(a => a.Age > 18);\n/*\n * DELETE `Users` FROM `Users` WHERE `Users`.`Age` > 18\n */\n```', '2016-12-02 15:44:53', '2016-12-02 19:24:18', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146546785222656', 'MySql-存储过程', 'MySql-存储过程', 'MySql-存储过程', '<h1 id=\"h1-u5B58u50A8u8FC7u7A0B\"><a name=\"存储过程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>存储过程</h1><p>Chloe 支持存储过程以及 output 参数。<br><strong>通过存储过程获取一个 User 信息：</strong></p>\n<pre><code class=\"lang-csharp\">DbParam id = new DbParam(&quot;?id&quot;, 1);\nUser user = context.SqlQuery&lt;User&gt;(&quot;Proc_GetUser&quot;, CommandType.StoredProcedure, id).FirstOrDefault();\n</code></pre>\n<p><strong>通过存储过程的 output 参数获取一个用户的 name：</strong></p>\n<pre><code class=\"lang-csharp\">DbParam id = new DbParam(&quot;?id&quot;, 1);\nDbParam outputName = new DbParam(&quot;?name&quot;, null, typeof(string)) { Direction = ParamDirection.Output };\ncontext.Session.ExecuteNonQuery(&quot;Proc_GetUserName&quot;, CommandType.StoredProcedure, id, outputName);\n</code></pre>\n', '# 存储过程\nChloe 支持存储过程以及 output 参数。\n**通过存储过程获取一个 User 信息：**\n```csharp\nDbParam id = new DbParam(\"?id\", 1);\nUser user = context.SqlQuery<User>(\"Proc_GetUser\", CommandType.StoredProcedure, id).FirstOrDefault();\n```\n**通过存储过程的 output 参数获取一个用户的 name：**\n```csharp\nDbParam id = new DbParam(\"?id\", 1);\nDbParam outputName = new DbParam(\"?name\", null, typeof(string)) { Direction = ParamDirection.Output };\ncontext.Session.ExecuteNonQuery(\"Proc_GetUserName\", CommandType.StoredProcedure, id, outputName);\n```', '2016-12-02 15:45:16', '2016-12-02 19:25:11', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146606914764800', 'MySql-事务', 'MySql-事务', 'MySql-事务', '<h1 id=\"h1-u4E8Bu52A1u652Fu6301\"><a name=\"事务支持\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>事务支持</h1><p><strong>基本用法：</strong></p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nusing (MySqlContext context = new MySqlContext(new MySqlConnectionFactory(connString)))\n{\n    try\n    {\n        context.Session.BeginTransaction();\n\n        /* do some things here */\n        context.Update(user);\n        context.Delete&lt;User&gt;(a =&gt; a.Gender == null);\n\n        context.Session.CommitTransaction();\n    }\n    catch\n    {\n        if (context.Session.IsInTransaction)\n            context.Session.RollbackTransaction();\n        throw;\n    }\n}\n</code></pre>\n', '# 事务支持\n**基本用法：**\n```csharp\nstring connString = \"Your connection string\";\nusing (MySqlContext context = new MySqlContext(new MySqlConnectionFactory(connString)))\n{\n    try\n    {\n        context.Session.BeginTransaction();\n\n        /* do some things here */\n        context.Update(user);\n        context.Delete<User>(a => a.Gender == null);\n\n        context.Session.CommitTransaction();\n    }\n    catch\n    {\n        if (context.Session.IsInTransaction)\n            context.Session.RollbackTransaction();\n        throw;\n    }\n}\n```', '2016-12-02 15:45:30', '2016-12-02 19:26:16', '0', null);
INSERT INTO `wikidocument` VALUES ('3325146654268456960', 'MySql-常用函数', 'MySql-常用函数', 'MySql-常用函数', '<h1 id=\"h1-u5E38u7528u51FDu6570\"><a name=\"常用函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>常用函数</h1><p><strong>Chloe 对很多数据库函数支持很丰富，具体用法如下：</strong></p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nvar space = new char[] { &#39; &#39; };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = DateTime.Now.AddDays(1);\n\nvar ret = q.Select(a =&gt; new\n{\n    Id = a.Id,\n\n    String_Length = (int?)a.Name.Length,//LENGTH(`Users`.`Name`)\n    Substring = a.Name.Substring(0),//SUBSTRING(`Users`.`Name`,0 + 1,LENGTH(`Users`.`Name`))\n    Substring1 = a.Name.Substring(1),//SUBSTRING(`Users`.`Name`,1 + 1,LENGTH(`Users`.`Name`))\n    Substring1_2 = a.Name.Substring(1, 2),//SUBSTRING(`Users`.`Name`,1 + 1,2)\n    ToLower = a.Name.ToLower(),//LOWER(`Users`.`Name`)\n    ToUpper = a.Name.ToUpper(),//UPPER(`Users`.`Name`)\n    IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//CASE WHEN (`Users`.`Name` IS NULL OR `Users`.`Name` = N&#39;&#39;) THEN 1 ELSE 0 END = 1\n    Contains = (bool?)a.Name.Contains(&quot;s&quot;),//`Users`.`Name` LIKE CONCAT(&#39;%&#39;,N&#39;s&#39;,&#39;%&#39;)\n    Trim = a.Name.Trim(),//TRIM(`Users`.`Name`)\n    TrimStart = a.Name.TrimStart(space),//LTRIM(`Users`.`Name`)\n    TrimEnd = a.Name.TrimEnd(space),//RTRIM(`Users`.`Name`)\n    StartsWith = (bool?)a.Name.StartsWith(&quot;s&quot;),//`Users`.`Name` LIKE CONCAT(N&#39;s&#39;,&#39;%&#39;)\n    EndsWith = (bool?)a.Name.EndsWith(&quot;s&quot;),//`Users`.`Name` LIKE CONCAT(&#39;%&#39;,N&#39;s&#39;)\n\n    DiffYears = DbFunctions.DiffYears(startTime, endTime),//TIMESTAMPDIFF(YEAR,?P_0,?P_1)\n    DiffMonths = DbFunctions.DiffMonths(startTime, endTime),//TIMESTAMPDIFF(MONTH,?P_0,?P_1)\n    DiffDays = DbFunctions.DiffDays(startTime, endTime),//TIMESTAMPDIFF(DAY,?P_0,?P_1)\n    DiffHours = DbFunctions.DiffHours(startTime, endTime),//TIMESTAMPDIFF(HOUR,?P_0,?P_1)\n    DiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//TIMESTAMPDIFF(MINUTE,?P_0,?P_1)\n    DiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//TIMESTAMPDIFF(SECOND,?P_0,?P_1)\n    //DiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//MySql 不支持 Millisecond\n    //DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//ex\n\n    Now = DateTime.Now,//NOW()\n    UtcNow = DateTime.UtcNow,//UTC_TIMESTAMP()\n    Today = DateTime.Today,//CURDATE()\n    Date = DateTime.Now.Date,//DATE(NOW())\n    Year = DateTime.Now.Year,//YEAR(NOW())\n    Month = DateTime.Now.Month,//MONTH(NOW())\n    Day = DateTime.Now.Day,//DAY(NOW())\n    Hour = DateTime.Now.Hour,//HOUR(NOW())\n    Minute = DateTime.Now.Minute,//MINUTE(NOW())\n    Second = DateTime.Now.Second,//SECOND(NOW())\n    Millisecond = DateTime.Now.Millisecond,//?P_2 AS `Millisecond`\n    DayOfWeek = DateTime.Now.DayOfWeek,//(DAYOFWEEK(NOW()) - 1)\n\n    //Byte_Parse = byte.Parse(&quot;1&quot;),//不支持\n    Int_Parse = int.Parse(&quot;1&quot;),//CAST(N&#39;1&#39; AS SIGNED)\n    Int16_Parse = Int16.Parse(&quot;11&quot;),//CAST(N&#39;11&#39; AS SIGNED)\n    Long_Parse = long.Parse(&quot;2&quot;),//CAST(N&#39;2&#39; AS SIGNED)\n    //Double_Parse = double.Parse(&quot;3&quot;),//N&#39;3&#39; 不支持，否则可能会成为BUG\n    //Float_Parse = float.Parse(&quot;4&quot;),//N&#39;4&#39; 不支持，否则可能会成为BUG\n    //Decimal_Parse = decimal.Parse(&quot;5&quot;),//不支持\n    Guid_Parse = Guid.Parse(&quot;D544BC4C-739E-4CD3-A3D3-7BF803FCE179&quot;),//N&#39;D544BC4C-739E-4CD3-A3D3-7BF803FCE179&#39;\n\n    Bool_Parse = bool.Parse(&quot;1&quot;),//CAST(N&#39;1&#39; AS SIGNED)\n    DateTime_Parse = DateTime.Parse(&quot;2014-1-1&quot;),//CAST(N&#39;2014-1-1&#39; AS DATETIME)\n}).ToList();\n</code></pre>\n<p>上述的函数可以用于 Select 方法，亦可用在 Where 或其它方法的 lambda 表达式树中，最终都会翻译成数据库函数。</p>\n', '# 常用函数\n**Chloe 对很多数据库函数支持很丰富，具体用法如下：**\n```csharp\nIQuery<User> q = context.Query<User>();\n\nvar space = new char[] { \' \' };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = DateTime.Now.AddDays(1);\n\nvar ret = q.Select(a => new\n{\n    Id = a.Id,\n\n    String_Length = (int?)a.Name.Length,//LENGTH(`Users`.`Name`)\n    Substring = a.Name.Substring(0),//SUBSTRING(`Users`.`Name`,0 + 1,LENGTH(`Users`.`Name`))\n    Substring1 = a.Name.Substring(1),//SUBSTRING(`Users`.`Name`,1 + 1,LENGTH(`Users`.`Name`))\n    Substring1_2 = a.Name.Substring(1, 2),//SUBSTRING(`Users`.`Name`,1 + 1,2)\n    ToLower = a.Name.ToLower(),//LOWER(`Users`.`Name`)\n    ToUpper = a.Name.ToUpper(),//UPPER(`Users`.`Name`)\n    IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//CASE WHEN (`Users`.`Name` IS NULL OR `Users`.`Name` = N\'\') THEN 1 ELSE 0 END = 1\n    Contains = (bool?)a.Name.Contains(\"s\"),//`Users`.`Name` LIKE CONCAT(\'%\',N\'s\',\'%\')\n    Trim = a.Name.Trim(),//TRIM(`Users`.`Name`)\n    TrimStart = a.Name.TrimStart(space),//LTRIM(`Users`.`Name`)\n    TrimEnd = a.Name.TrimEnd(space),//RTRIM(`Users`.`Name`)\n    StartsWith = (bool?)a.Name.StartsWith(\"s\"),//`Users`.`Name` LIKE CONCAT(N\'s\',\'%\')\n    EndsWith = (bool?)a.Name.EndsWith(\"s\"),//`Users`.`Name` LIKE CONCAT(\'%\',N\'s\')\n\n    DiffYears = DbFunctions.DiffYears(startTime, endTime),//TIMESTAMPDIFF(YEAR,?P_0,?P_1)\n    DiffMonths = DbFunctions.DiffMonths(startTime, endTime),//TIMESTAMPDIFF(MONTH,?P_0,?P_1)\n    DiffDays = DbFunctions.DiffDays(startTime, endTime),//TIMESTAMPDIFF(DAY,?P_0,?P_1)\n    DiffHours = DbFunctions.DiffHours(startTime, endTime),//TIMESTAMPDIFF(HOUR,?P_0,?P_1)\n    DiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//TIMESTAMPDIFF(MINUTE,?P_0,?P_1)\n    DiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//TIMESTAMPDIFF(SECOND,?P_0,?P_1)\n    //DiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//MySql 不支持 Millisecond\n    //DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//ex\n\n    Now = DateTime.Now,//NOW()\n    UtcNow = DateTime.UtcNow,//UTC_TIMESTAMP()\n    Today = DateTime.Today,//CURDATE()\n    Date = DateTime.Now.Date,//DATE(NOW())\n    Year = DateTime.Now.Year,//YEAR(NOW())\n    Month = DateTime.Now.Month,//MONTH(NOW())\n    Day = DateTime.Now.Day,//DAY(NOW())\n    Hour = DateTime.Now.Hour,//HOUR(NOW())\n    Minute = DateTime.Now.Minute,//MINUTE(NOW())\n    Second = DateTime.Now.Second,//SECOND(NOW())\n    Millisecond = DateTime.Now.Millisecond,//?P_2 AS `Millisecond`\n    DayOfWeek = DateTime.Now.DayOfWeek,//(DAYOFWEEK(NOW()) - 1)\n\n    //Byte_Parse = byte.Parse(\"1\"),//不支持\n    Int_Parse = int.Parse(\"1\"),//CAST(N\'1\' AS SIGNED)\n    Int16_Parse = Int16.Parse(\"11\"),//CAST(N\'11\' AS SIGNED)\n    Long_Parse = long.Parse(\"2\"),//CAST(N\'2\' AS SIGNED)\n    //Double_Parse = double.Parse(\"3\"),//N\'3\' 不支持，否则可能会成为BUG\n    //Float_Parse = float.Parse(\"4\"),//N\'4\' 不支持，否则可能会成为BUG\n    //Decimal_Parse = decimal.Parse(\"5\"),//不支持\n    Guid_Parse = Guid.Parse(\"D544BC4C-739E-4CD3-A3D3-7BF803FCE179\"),//N\'D544BC4C-739E-4CD3-A3D3-7BF803FCE179\'\n\n    Bool_Parse = bool.Parse(\"1\"),//CAST(N\'1\' AS SIGNED)\n    DateTime_Parse = DateTime.Parse(\"2014-1-1\"),//CAST(N\'2014-1-1\' AS DATETIME)\n}).ToList();\n```\n上述的函数可以用于 Select 方法，亦可用在 Where 或其它方法的 lambda 表达式树中，最终都会翻译成数据库函数。', '2016-12-02 15:45:42', '2016-12-02 19:27:18', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149150596562944', 'Oracle-实体特性', 'Oracle-实体特性', 'Oracle-实体特性', '<h1 id=\"h1-u5B9Eu4F53u7279u6027\"><a name=\"实体特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实体特性</h1><p><strong>Chloe.Entity.TableAttribute：</strong><br>Name：映射的表名。<br>实体对应的表默认是实体类名，如实体类型名与表名不一致，可通过该特性指定映射的表名。</p>\n<pre><code class=\"lang-csharp\">public class TableAttribute : Attribute\n{\n    public TableAttribute() { }\n    public TableAttribute(string name)\n    {\n        Name = name;\n    }\n    public string Name { get; set; }\n}\n</code></pre>\n<p><strong>Chloe.Entity.ColumnAttribute：</strong><br>Name：映射的列名，如不指定，则默认使用属性名。<br>IsPrimaryKey：指示列是否为主键，默认为 false。<br>当一个实体没显示指定主键的时候，Chloe 默认选择名为 Id 的属性（如果存在）作为主键列。</p>\n<pre><code class=\"lang-csharp\">public class ColumnAttribute : Attribute\n{\n    public ColumnAttribute() { }\n    public ColumnAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; set; }\n    public bool IsPrimaryKey { get; set; }\n}\n</code></pre>\n<p><strong>Chloe.Oracle.SequenceAttribute：</strong><br>标记属性通过序列实现自增，需要指定序列名称。</p>\n<pre><code class=\"lang-csharp\">public class SequenceAttribute : Attribute\n{\n    public SequenceAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; private set; }\n}\n</code></pre>\n<p><strong>Chloe.Entity.NotMappedAttribute：</strong><br>指示属性不映射任何列。</p>\n<pre><code class=\"lang-csharp\">public class NotMappedAttribute : Attribute\n{\n}\n</code></pre>\n', '# 实体特性\n**Chloe.Entity.TableAttribute：**\nName：映射的表名。\n实体对应的表默认是实体类名，如实体类型名与表名不一致，可通过该特性指定映射的表名。\n```csharp\npublic class TableAttribute : Attribute\n{\n    public TableAttribute() { }\n    public TableAttribute(string name)\n    {\n        Name = name;\n    }\n    public string Name { get; set; }\n}\n```\n**Chloe.Entity.ColumnAttribute：**\nName：映射的列名，如不指定，则默认使用属性名。\nIsPrimaryKey：指示列是否为主键，默认为 false。\n当一个实体没显示指定主键的时候，Chloe 默认选择名为 Id 的属性（如果存在）作为主键列。\n```csharp\npublic class ColumnAttribute : Attribute\n{\n    public ColumnAttribute() { }\n    public ColumnAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; set; }\n    public bool IsPrimaryKey { get; set; }\n}\n```\n**Chloe.Oracle.SequenceAttribute：**\n标记属性通过序列实现自增，需要指定序列名称。\n```csharp\npublic class SequenceAttribute : Attribute\n{\n    public SequenceAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; private set; }\n}\n```\n**Chloe.Entity.NotMappedAttribute：**\n指示属性不映射任何列。\n```csharp\npublic class NotMappedAttribute : Attribute\n{\n}\n```', '2016-12-02 15:55:37', '2016-12-03 13:56:32', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149206355640320', 'Oracle-实体定义', 'Oracle-实体定义', 'Oracle-实体定义', '<h1 id=\"h1-u5B9Eu4F53u5B9Au4E49\"><a name=\"实体定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实体定义</h1><p>实体为纯 POCO，支持可空类型以及枚举类型映射。</p>\n<pre><code class=\"lang-csharp\">public enum Gender\n{\n    Man = 1,\n    Woman\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">[TableAttribute(&quot;Users&quot;)]\npublic class User\n{\n    [Sequence(&quot;USERS_AUTOID&quot;)]\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">public class City\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">public class Province\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n</code></pre>\n', '# 实体定义\n实体为纯 POCO，支持可空类型以及枚举类型映射。\n```csharp\npublic enum Gender\n{\n    Man = 1,\n    Woman\n}\n```\n```csharp\n[TableAttribute(\"Users\")]\npublic class User\n{\n    [Sequence(\"USERS_AUTOID\")]\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n```\n```csharp\npublic class City\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n```\n```csharp\npublic class Province\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n```', '2016-12-02 15:55:50', '2016-12-03 13:57:48', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149282020884480', 'Oracle-创建DbContext', 'Oracle-创建DbContext', 'Oracle-创建DbContext', '<h1 id=\"h1--dbcontext\"><a name=\"创建 DbContext\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建 DbContext</h1><p>对于 Oracle 数据库，需要引用程序集 Chloe.dll 和 Chloe.Oracle.dll，然后使用 Chloe.Oracle.OracleContext 创建上下文实例。<br>因为框架本身需要与具体的数据库驱动解耦，所以 OracleContext 构造函数需要一个 IDbConnectionFactory 的参数，IDbConnectionFactory 接口只有一个 CreateConnection() 方法，必须先建个类，实现 CreateConnection 方法。</p>\n<pre><code class=\"lang-csharp\">public class OracleConnectionFactory : IDbConnectionFactory\n{\n    string _connString = null;\n    public OracleConnectionFactory(string connString)\n    {\n        this._connString = connString;\n    }\n    public IDbConnection CreateConnection()\n    {\n        OracleConnection oracleConnection = new OracleConnection(this._connString);\n        OracleConnectionDecorator conn = new OracleConnectionDecorator(oracleConnection);\n        return conn;\n    }\n}\n</code></pre>\n<p>由于笔者使用的是 Oracle.ManagedDataAccess 数据库驱动，OracleConnection 创建的 DbCommand 默认是以顺序方式绑定参数，所以，上述例子使用了装饰者模式对 OracleConnection 封装了一遍，主要就是修改 DbCommand 参数绑定方式。OracleConnectionDecorator 定义如下：</p>\n<pre><code class=\"lang-csharp\">class OracleConnectionDecorator : IDbConnection, IDisposable\n{\n    private OracleConnection _oracleConnection;\n    public OracleConnectionDecorator(OracleConnection oracleConnection)\n    {\n        if (oracleConnection == null)\n            throw new Exception(&quot;Please call 911.&quot;);\n        _oracleConnection = oracleConnection;\n    }\n\n    public string ConnectionString\n    {\n        get { return _oracleConnection.ConnectionString; }\n        set { _oracleConnection.ConnectionString = value; }\n    }\n    public int ConnectionTimeout\n    {\n        get { return _oracleConnection.ConnectionTimeout; }\n    }\n    public string Database\n    {\n        get { return _oracleConnection.Database; }\n    }\n    public ConnectionState State\n    {\n        get { return _oracleConnection.State; }\n    }\n\n    public IDbTransaction BeginTransaction()\n    {\n        return _oracleConnection.BeginTransaction();\n    }\n    public IDbTransaction BeginTransaction(IsolationLevel il)\n    {\n        return _oracleConnection.BeginTransaction(il);\n    }\n    public void ChangeDatabase(string databaseName)\n    {\n        _oracleConnection.ChangeDatabase(databaseName);\n    }\n    public void Close()\n    {\n        _oracleConnection.Close();\n    }\n    public IDbCommand CreateCommand()\n    {\n        var cmd = _oracleConnection.CreateCommand();\n        cmd.BindByName = true;\n        return cmd;\n    }\n    public void Open()\n    {\n        _oracleConnection.Open();\n    }\n\n    public void Dispose()\n    {\n        _oracleConnection.Dispose();\n    }\n}\n</code></pre>\n<p>接下来就可以创建 OracleContext：</p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nOracleContext context = new OracleContext(new OracleConnectionFactory(connString));\n</code></pre>\n<p>OracleContext 生成 sql 语句时默认将所有字段转成大写形式，如需要修改该默认设置，操作如下：</p>\n<pre><code class=\"lang-csharp\">context.ConvertToUppercase = false;\n</code></pre>\n', '# 创建 DbContext\n对于 Oracle 数据库，需要引用程序集 Chloe.dll 和 Chloe.Oracle.dll，然后使用 Chloe.Oracle.OracleContext 创建上下文实例。\n因为框架本身需要与具体的数据库驱动解耦，所以 OracleContext 构造函数需要一个 IDbConnectionFactory 的参数，IDbConnectionFactory 接口只有一个 CreateConnection() 方法，必须先建个类，实现 CreateConnection 方法。\n```csharp\npublic class OracleConnectionFactory : IDbConnectionFactory\n{\n    string _connString = null;\n    public OracleConnectionFactory(string connString)\n    {\n        this._connString = connString;\n    }\n    public IDbConnection CreateConnection()\n    {\n        OracleConnection oracleConnection = new OracleConnection(this._connString);\n        OracleConnectionDecorator conn = new OracleConnectionDecorator(oracleConnection);\n        return conn;\n    }\n}\n```\n由于笔者使用的是 Oracle.ManagedDataAccess 数据库驱动，OracleConnection 创建的 DbCommand 默认是以顺序方式绑定参数，所以，上述例子使用了装饰者模式对 OracleConnection 封装了一遍，主要就是修改 DbCommand 参数绑定方式。OracleConnectionDecorator 定义如下：\n```csharp\nclass OracleConnectionDecorator : IDbConnection, IDisposable\n{\n    private OracleConnection _oracleConnection;\n    public OracleConnectionDecorator(OracleConnection oracleConnection)\n    {\n        if (oracleConnection == null)\n            throw new Exception(\"Please call 911.\");\n        _oracleConnection = oracleConnection;\n    }\n\n    public string ConnectionString\n    {\n        get { return _oracleConnection.ConnectionString; }\n        set { _oracleConnection.ConnectionString = value; }\n    }\n    public int ConnectionTimeout\n    {\n        get { return _oracleConnection.ConnectionTimeout; }\n    }\n    public string Database\n    {\n        get { return _oracleConnection.Database; }\n    }\n    public ConnectionState State\n    {\n        get { return _oracleConnection.State; }\n    }\n\n    public IDbTransaction BeginTransaction()\n    {\n        return _oracleConnection.BeginTransaction();\n    }\n    public IDbTransaction BeginTransaction(IsolationLevel il)\n    {\n        return _oracleConnection.BeginTransaction(il);\n    }\n    public void ChangeDatabase(string databaseName)\n    {\n        _oracleConnection.ChangeDatabase(databaseName);\n    }\n    public void Close()\n    {\n        _oracleConnection.Close();\n    }\n    public IDbCommand CreateCommand()\n    {\n        var cmd = _oracleConnection.CreateCommand();\n        cmd.BindByName = true;\n        return cmd;\n    }\n    public void Open()\n    {\n        _oracleConnection.Open();\n    }\n\n    public void Dispose()\n    {\n        _oracleConnection.Dispose();\n    }\n}\n```\n接下来就可以创建 OracleContext：\n```csharp\nstring connString = \"Your connection string\";\nOracleContext context = new OracleContext(new OracleConnectionFactory(connString));\n```\nOracleContext 生成 sql 语句时默认将所有字段转成大写形式，如需要修改该默认设置，操作如下：\n```csharp\ncontext.ConvertToUppercase = false;\n```', '2016-12-02 15:56:08', '2016-12-04 22:09:58', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149327977873408', 'Oracle-基本查询', 'Oracle-基本查询', 'Oracle-基本查询', '<h1 id=\"h1-u57FAu672Cu67E5u8BE2\"><a name=\"基本查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本查询</h1><p><strong>根据 Id 查询出一个 User 对象：</strong></p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nOracleContext context = new OracleContext(new OracleConnectionFactory(connString));\nIQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nq.Where(a =&gt; a.Id == 1).FirstOrDefault();\n/*\n *生成的 sql：\n * SELECT &quot;USERS&quot;.&quot;ID&quot; AS &quot;ID&quot;,&quot;USERS&quot;.&quot;NAME&quot; AS &quot;NAME&quot;,&quot;USERS&quot;.&quot;GENDER&quot; AS &quot;GENDER&quot;,&quot;USERS&quot;.&quot;AGE&quot; AS &quot;AGE&quot;,&quot;USERS&quot;.&quot;CITYID&quot; AS &quot;CITYID&quot;,&quot;USERS&quot;.&quot;OPTIME&quot; AS &quot;OPTIME&quot; \n   FROM &quot;USERS&quot; &quot;USERS&quot; \n   WHERE (&quot;USERS&quot;.&quot;ID&quot; = 1 AND ROWNUM &lt; 2)\n */\n</code></pre>\n<p><strong>in 查询：</strong></p>\n<pre><code class=\"lang-csharp\">List&lt;int&gt; ids = new List&lt;int&gt;() { 1, 2, 3 };\nq.Where(a =&gt; ids.Contains(a.Id)).ToList();\n/*\n * Int32 :P_0 = 1;\n   Int32 :P_1 = 2;\n   Int32 :P_2 = 3;\n   SELECT &quot;USERS&quot;.&quot;ID&quot; AS &quot;ID&quot;,&quot;USERS&quot;.&quot;NAME&quot; AS &quot;NAME&quot;,&quot;USERS&quot;.&quot;GENDER&quot; AS &quot;GENDER&quot;,&quot;USERS&quot;.&quot;AGE&quot; AS &quot;AGE&quot;,&quot;USERS&quot;.&quot;CITYID&quot; AS &quot;CITYID&quot;,&quot;USERS&quot;.&quot;OPTIME&quot; AS &quot;OPTIME&quot; \n   FROM &quot;USERS&quot; &quot;USERS&quot; \n   WHERE &quot;USERS&quot;.&quot;ID&quot; IN (:P_0,:P_1,:P_2)\n */\n</code></pre>\n<p><strong>可以选取指定的字段，返回一个匿名类型：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id == 1).Select(a =&gt; new { a.Id, a.Name }).FirstOrDefault();\n/*\n * 只会生成包含 Id 和 Name 两个字段的 sql 语句：\n * SELECT &quot;USERS&quot;.&quot;ID&quot; AS &quot;ID&quot;,&quot;USERS&quot;.&quot;NAME&quot; AS &quot;NAME&quot; \n   FROM &quot;USERS&quot; &quot;USERS&quot; \n   WHERE (&quot;USERS&quot;.&quot;ID&quot; = 1 AND ROWNUM &lt; 2)\n */\n</code></pre>\n<p><strong>排序：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).ThenBy(a =&gt; a.Id).ToList();\n/*\n * SELECT &quot;USERS&quot;.&quot;ID&quot; AS &quot;ID&quot;,&quot;USERS&quot;.&quot;NAME&quot; AS &quot;NAME&quot;,&quot;USERS&quot;.&quot;GENDER&quot; AS &quot;GENDER&quot;,&quot;USERS&quot;.&quot;AGE&quot; AS &quot;AGE&quot;,&quot;USERS&quot;.&quot;CITYID&quot; AS &quot;CITYID&quot;,&quot;USERS&quot;.&quot;OPTIME&quot; AS &quot;OPTIME&quot; \n   FROM &quot;USERS&quot; &quot;USERS&quot; \n   WHERE &quot;USERS&quot;.&quot;ID&quot; &gt; 0 \n   ORDER BY &quot;USERS&quot;.&quot;AGE&quot; ASC,&quot;USERS&quot;.&quot;ID&quot; ASC\n */\n</code></pre>\n<p><strong>分页：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).TakePage(1, 20).ToList();\n/*\n * SELECT &quot;T&quot;.&quot;ID&quot; AS &quot;ID&quot;,&quot;T&quot;.&quot;NAME&quot; AS &quot;NAME&quot;,&quot;T&quot;.&quot;GENDER&quot; AS &quot;GENDER&quot;,&quot;T&quot;.&quot;AGE&quot; AS &quot;AGE&quot;,&quot;T&quot;.&quot;CITYID&quot; AS &quot;CITYID&quot;,&quot;T&quot;.&quot;OPTIME&quot; AS &quot;OPTIME&quot; FROM (SELECT &quot;TTAKE&quot;.&quot;ID&quot; AS &quot;ID&quot;,&quot;TTAKE&quot;.&quot;NAME&quot; AS &quot;NAME&quot;,&quot;TTAKE&quot;.&quot;GENDER&quot; AS &quot;GENDER&quot;,&quot;TTAKE&quot;.&quot;AGE&quot; AS &quot;AGE&quot;,&quot;TTAKE&quot;.&quot;CITYID&quot; AS &quot;CITYID&quot;,&quot;TTAKE&quot;.&quot;OPTIME&quot; AS &quot;OPTIME&quot;,ROWNUM AS &quot;ROW_NUMBER_0&quot; FROM (SELECT &quot;USERS&quot;.&quot;ID&quot; AS &quot;ID&quot;,&quot;USERS&quot;.&quot;NAME&quot; AS &quot;NAME&quot;,&quot;USERS&quot;.&quot;GENDER&quot; AS &quot;GENDER&quot;,&quot;USERS&quot;.&quot;AGE&quot; AS &quot;AGE&quot;,&quot;USERS&quot;.&quot;CITYID&quot; AS &quot;CITYID&quot;,&quot;USERS&quot;.&quot;OPTIME&quot; AS &quot;OPTIME&quot; FROM &quot;USERS&quot; &quot;USERS&quot; WHERE &quot;USERS&quot;.&quot;ID&quot; &gt; 0 ORDER BY &quot;USERS&quot;.&quot;AGE&quot; ASC) &quot;TTAKE&quot; WHERE ROWNUM &lt; 21) &quot;T&quot; WHERE &quot;T&quot;.&quot;ROW_NUMBER_0&quot; &gt; 0\n */\n</code></pre>\n', '# 基本查询\n**根据 Id 查询出一个 User 对象：**\n```csharp\nstring connString = \"Your connection string\";\nOracleContext context = new OracleContext(new OracleConnectionFactory(connString));\nIQuery<User> q = context.Query<User>();\n\nq.Where(a => a.Id == 1).FirstOrDefault();\n/*\n *生成的 sql：\n * SELECT \"USERS\".\"ID\" AS \"ID\",\"USERS\".\"NAME\" AS \"NAME\",\"USERS\".\"GENDER\" AS \"GENDER\",\"USERS\".\"AGE\" AS \"AGE\",\"USERS\".\"CITYID\" AS \"CITYID\",\"USERS\".\"OPTIME\" AS \"OPTIME\" \n   FROM \"USERS\" \"USERS\" \n   WHERE (\"USERS\".\"ID\" = 1 AND ROWNUM < 2)\n */\n```\n**in 查询：**\n```csharp\nList<int> ids = new List<int>() { 1, 2, 3 };\nq.Where(a => ids.Contains(a.Id)).ToList();\n/*\n * Int32 :P_0 = 1;\n   Int32 :P_1 = 2;\n   Int32 :P_2 = 3;\n   SELECT \"USERS\".\"ID\" AS \"ID\",\"USERS\".\"NAME\" AS \"NAME\",\"USERS\".\"GENDER\" AS \"GENDER\",\"USERS\".\"AGE\" AS \"AGE\",\"USERS\".\"CITYID\" AS \"CITYID\",\"USERS\".\"OPTIME\" AS \"OPTIME\" \n   FROM \"USERS\" \"USERS\" \n   WHERE \"USERS\".\"ID\" IN (:P_0,:P_1,:P_2)\n */\n```\n**可以选取指定的字段，返回一个匿名类型：**\n```csharp\nq.Where(a => a.Id == 1).Select(a => new { a.Id, a.Name }).FirstOrDefault();\n/*\n * 只会生成包含 Id 和 Name 两个字段的 sql 语句：\n * SELECT \"USERS\".\"ID\" AS \"ID\",\"USERS\".\"NAME\" AS \"NAME\" \n   FROM \"USERS\" \"USERS\" \n   WHERE (\"USERS\".\"ID\" = 1 AND ROWNUM < 2)\n */\n```\n**排序：**\n```csharp\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).ThenBy(a => a.Id).ToList();\n/*\n * SELECT \"USERS\".\"ID\" AS \"ID\",\"USERS\".\"NAME\" AS \"NAME\",\"USERS\".\"GENDER\" AS \"GENDER\",\"USERS\".\"AGE\" AS \"AGE\",\"USERS\".\"CITYID\" AS \"CITYID\",\"USERS\".\"OPTIME\" AS \"OPTIME\" \n   FROM \"USERS\" \"USERS\" \n   WHERE \"USERS\".\"ID\" > 0 \n   ORDER BY \"USERS\".\"AGE\" ASC,\"USERS\".\"ID\" ASC\n */\n```\n**分页：**\n```csharp\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).TakePage(1, 20).ToList();\n/*\n * SELECT \"T\".\"ID\" AS \"ID\",\"T\".\"NAME\" AS \"NAME\",\"T\".\"GENDER\" AS \"GENDER\",\"T\".\"AGE\" AS \"AGE\",\"T\".\"CITYID\" AS \"CITYID\",\"T\".\"OPTIME\" AS \"OPTIME\" FROM (SELECT \"TTAKE\".\"ID\" AS \"ID\",\"TTAKE\".\"NAME\" AS \"NAME\",\"TTAKE\".\"GENDER\" AS \"GENDER\",\"TTAKE\".\"AGE\" AS \"AGE\",\"TTAKE\".\"CITYID\" AS \"CITYID\",\"TTAKE\".\"OPTIME\" AS \"OPTIME\",ROWNUM AS \"ROW_NUMBER_0\" FROM (SELECT \"USERS\".\"ID\" AS \"ID\",\"USERS\".\"NAME\" AS \"NAME\",\"USERS\".\"GENDER\" AS \"GENDER\",\"USERS\".\"AGE\" AS \"AGE\",\"USERS\".\"CITYID\" AS \"CITYID\",\"USERS\".\"OPTIME\" AS \"OPTIME\" FROM \"USERS\" \"USERS\" WHERE \"USERS\".\"ID\" > 0 ORDER BY \"USERS\".\"AGE\" ASC) \"TTAKE\" WHERE ROWNUM < 21) \"T\" WHERE \"T\".\"ROW_NUMBER_0\" > 0\n */\n```', '2016-12-02 15:56:19', '2016-12-08 11:33:53', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149375134433280', 'Oracle-连接查询', 'Oracle-连接查询', 'Oracle-连接查询', '<h1 id=\"h1-u8FDEu63A5u67E5u8BE2\"><a name=\"连接查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>连接查询</h1><p>Chloe 友好支持多表连接查询，一切都可以用 lambda 表达式操作，返回类型可以是自定义类型，也可以是匿名类型。强类型开发，编译可见错误，容错率高。<br><strong>1.创建相关的 IQuery 对象：</strong></p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; users = context.Query&lt;User&gt;();\nIQuery&lt;City&gt; cities = context.Query&lt;City&gt;();\nIQuery&lt;Province&gt; provinces = context.Query&lt;Province&gt;();\n</code></pre>\n<p><strong>2.建立连接：</strong></p>\n<pre><code class=\"lang-csharp\">/* User 表和 City 表 inner join，得到 IJoiningQuery&lt;User, City&gt; 对象 */\nIJoiningQuery&lt;User, City&gt; user_city = users.InnerJoin(cities, (user, city) =&gt; user.CityId == city.Id);\n\n/* City 表和 Province 表 inner join，得到 IJoiningQuery&lt;User, City, Province&gt; 对象 */\nIJoiningQuery&lt;User, City, Province&gt; user_city_province = user_city.InnerJoin(provinces, (user, city, province) =&gt; city.ProvinceId == province.Id);\n</code></pre>\n<p><strong>3.得到最终的 IJoiningQuery 对象，就可以 Select 所需要的数据返回一个 IQuery 对象，然后就可以进行 Where、OrderBy、GroupBy、分页、聚合查询等操作：</strong><br>查出一个用户及其隶属的城市和省份的所有信息：</p>\n<pre><code class=\"lang-csharp\">/* 调用 Select 方法返回一个泛型为包含 User、City、Province 匿名类型的 IQuery 对象。\n * Select 方法也可以返回自定义类型 。\n */\nvar qq = user_city_province.Select((user, city, province) =&gt; new\n{\n    User = user,\n    City = city,\n    Province = province\n});\n\n/* 根据条件筛选，然后调用 ToList 就会返回一个泛型为 new { User = user, City = city, Province = province } 的 List 集合 */\nvar result = qq.Where(a =&gt; a.User.Id == 1).ToList();\n\n/*\n * 生成的 sql：\n * SELECT &quot;USERS&quot;.&quot;ID&quot; AS &quot;ID&quot;,&quot;USERS&quot;.&quot;NAME&quot; AS &quot;NAME&quot;,&quot;USERS&quot;.&quot;GENDER&quot; AS &quot;GENDER&quot;,&quot;USERS&quot;.&quot;AGE&quot; AS &quot;AGE&quot;,&quot;USERS&quot;.&quot;CITYID&quot; AS &quot;CITYID&quot;,&quot;USERS&quot;.&quot;OPTIME&quot; AS &quot;OPTIME&quot;,&quot;CITY&quot;.&quot;ID&quot; AS &quot;ID0&quot;,&quot;CITY&quot;.&quot;NAME&quot; AS &quot;NAME0&quot;,&quot;CITY&quot;.&quot;PROVINCEID&quot; AS &quot;PROVINCEID&quot;,&quot;PROVINCE&quot;.&quot;ID&quot; AS &quot;ID1&quot;,&quot;PROVINCE&quot;.&quot;NAME&quot; AS &quot;NAME1&quot; \n   FROM &quot;USERS&quot; &quot;USERS&quot; \n   INNER JOIN &quot;CITY&quot; &quot;CITY&quot; ON &quot;USERS&quot;.&quot;CITYID&quot; = &quot;CITY&quot;.&quot;ID&quot; \n   INNER JOIN &quot;PROVINCE&quot; &quot;PROVINCE&quot; ON &quot;CITY&quot;.&quot;PROVINCEID&quot; = &quot;PROVINCE&quot;.&quot;ID&quot; \n   WHERE &quot;USERS&quot;.&quot;ID&quot; = 1\n */\n</code></pre>\n<p>可以只获取指定的字段信息：</p>\n<pre><code class=\"lang-csharp\">user_city_province.Select((user, city, province) =&gt; new\n{\n    UserId = user.Id,\n    UserName = user.Name,\n    CityName = city.Name,\n    ProvinceName = province.Name\n}).Where(a =&gt; a.UserId == 1).ToList();\n\n/*\n * 生成的 sql 只会包含 UserId、UserName、CityName、ProvinceName 四个字段\n * SELECT &quot;USERS&quot;.&quot;ID&quot; AS &quot;USERID&quot;,&quot;USERS&quot;.&quot;NAME&quot; AS &quot;USERNAME&quot;,&quot;CITY&quot;.&quot;NAME&quot; AS &quot;CITYNAME&quot;,&quot;PROVINCE&quot;.&quot;NAME&quot; AS &quot;PROVINCENAME&quot; \n   FROM &quot;USERS&quot; &quot;USERS&quot; \n   INNER JOIN &quot;CITY&quot; &quot;CITY&quot; ON &quot;USERS&quot;.&quot;CITYID&quot; = &quot;CITY&quot;.&quot;ID&quot; \n   INNER JOIN &quot;PROVINCE&quot; &quot;PROVINCE&quot; ON &quot;CITY&quot;.&quot;PROVINCEID&quot; = &quot;PROVINCE&quot;.&quot;ID&quot; \n   WHERE &quot;USERS&quot;.&quot;ID&quot; = 1\n */\n</code></pre>\n<p>框架亦支持左连接、右连接和Full连接查询，用法和内连接相同。</p>\n', '# 连接查询\nChloe 友好支持多表连接查询，一切都可以用 lambda 表达式操作，返回类型可以是自定义类型，也可以是匿名类型。强类型开发，编译可见错误，容错率高。\n**1.创建相关的 IQuery 对象：**\n```csharp\nIQuery<User> users = context.Query<User>();\nIQuery<City> cities = context.Query<City>();\nIQuery<Province> provinces = context.Query<Province>();\n```\n**2.建立连接：**\n```csharp\n/* User 表和 City 表 inner join，得到 IJoiningQuery<User, City> 对象 */\nIJoiningQuery<User, City> user_city = users.InnerJoin(cities, (user, city) => user.CityId == city.Id);\n\n/* City 表和 Province 表 inner join，得到 IJoiningQuery<User, City, Province> 对象 */\nIJoiningQuery<User, City, Province> user_city_province = user_city.InnerJoin(provinces, (user, city, province) => city.ProvinceId == province.Id);\n```\n**3.得到最终的 IJoiningQuery 对象，就可以 Select 所需要的数据返回一个 IQuery 对象，然后就可以进行 Where、OrderBy、GroupBy、分页、聚合查询等操作：**\n查出一个用户及其隶属的城市和省份的所有信息：\n```csharp\n/* 调用 Select 方法返回一个泛型为包含 User、City、Province 匿名类型的 IQuery 对象。\n * Select 方法也可以返回自定义类型 。\n */\nvar qq = user_city_province.Select((user, city, province) => new\n{\n    User = user,\n    City = city,\n    Province = province\n});\n\n/* 根据条件筛选，然后调用 ToList 就会返回一个泛型为 new { User = user, City = city, Province = province } 的 List 集合 */\nvar result = qq.Where(a => a.User.Id == 1).ToList();\n\n/*\n * 生成的 sql：\n * SELECT \"USERS\".\"ID\" AS \"ID\",\"USERS\".\"NAME\" AS \"NAME\",\"USERS\".\"GENDER\" AS \"GENDER\",\"USERS\".\"AGE\" AS \"AGE\",\"USERS\".\"CITYID\" AS \"CITYID\",\"USERS\".\"OPTIME\" AS \"OPTIME\",\"CITY\".\"ID\" AS \"ID0\",\"CITY\".\"NAME\" AS \"NAME0\",\"CITY\".\"PROVINCEID\" AS \"PROVINCEID\",\"PROVINCE\".\"ID\" AS \"ID1\",\"PROVINCE\".\"NAME\" AS \"NAME1\" \n   FROM \"USERS\" \"USERS\" \n   INNER JOIN \"CITY\" \"CITY\" ON \"USERS\".\"CITYID\" = \"CITY\".\"ID\" \n   INNER JOIN \"PROVINCE\" \"PROVINCE\" ON \"CITY\".\"PROVINCEID\" = \"PROVINCE\".\"ID\" \n   WHERE \"USERS\".\"ID\" = 1\n */\n```\n可以只获取指定的字段信息：\n```csharp\nuser_city_province.Select((user, city, province) => new\n{\n    UserId = user.Id,\n    UserName = user.Name,\n    CityName = city.Name,\n    ProvinceName = province.Name\n}).Where(a => a.UserId == 1).ToList();\n\n/*\n * 生成的 sql 只会包含 UserId、UserName、CityName、ProvinceName 四个字段\n * SELECT \"USERS\".\"ID\" AS \"USERID\",\"USERS\".\"NAME\" AS \"USERNAME\",\"CITY\".\"NAME\" AS \"CITYNAME\",\"PROVINCE\".\"NAME\" AS \"PROVINCENAME\" \n   FROM \"USERS\" \"USERS\" \n   INNER JOIN \"CITY\" \"CITY\" ON \"USERS\".\"CITYID\" = \"CITY\".\"ID\" \n   INNER JOIN \"PROVINCE\" \"PROVINCE\" ON \"CITY\".\"PROVINCEID\" = \"PROVINCE\".\"ID\" \n   WHERE \"USERS\".\"ID\" = 1\n */\n```\n框架亦支持左连接、右连接和Full连接查询，用法和内连接相同。', '2016-12-02 15:56:30', '2016-12-03 14:20:38', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149450531241984', 'Oracle-分组查询', 'Oracle-分组查询', 'Oracle-分组查询', '<h1 id=\"h1-u5206u7EC4u67E5u8BE2\"><a name=\"分组查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分组查询</h1><p>Chloe 支持分组查询以及分组后 Having 过滤和聚合查询。</p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nIGroupingQuery&lt;User&gt; g = q.Where(a =&gt; a.Id &gt; 0).GroupBy(a =&gt; a.Age);\ng = g.Having(a =&gt; a.Age &gt; 1 &amp;&amp; AggregateFunctions.Count() &gt; 0);\n\ng.Select(a =&gt; new\n{\n    a.Age,\n    Count = AggregateFunctions.Count(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Avg = AggregateFunctions.Average(a.Age)\n}).ToList();\n/*\n * SELECT &quot;USERS&quot;.&quot;AGE&quot; AS &quot;AGE&quot;,COUNT(1) AS &quot;COUNT&quot;,SUM(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;SUM&quot;,MAX(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;MAX&quot;,MIN(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;MIN&quot;,AVG(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;AVG&quot; \n   FROM &quot;USERS&quot; &quot;USERS&quot; \n   WHERE &quot;USERS&quot;.&quot;ID&quot; &gt; 0 \n   GROUP BY &quot;USERS&quot;.&quot;AGE&quot; \n   HAVING (&quot;USERS&quot;.&quot;AGE&quot; &gt; 1 AND COUNT(1) &gt; 0)\n */\n</code></pre>\n', '# 分组查询\nChloe 支持分组查询以及分组后 Having 过滤和聚合查询。\n```csharp\nIQuery<User> q = context.Query<User>();\n\nIGroupingQuery<User> g = q.Where(a => a.Id > 0).GroupBy(a => a.Age);\ng = g.Having(a => a.Age > 1 && AggregateFunctions.Count() > 0);\n\ng.Select(a => new\n{\n    a.Age,\n    Count = AggregateFunctions.Count(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Avg = AggregateFunctions.Average(a.Age)\n}).ToList();\n/*\n * SELECT \"USERS\".\"AGE\" AS \"AGE\",COUNT(1) AS \"COUNT\",SUM(\"USERS\".\"AGE\") AS \"SUM\",MAX(\"USERS\".\"AGE\") AS \"MAX\",MIN(\"USERS\".\"AGE\") AS \"MIN\",AVG(\"USERS\".\"AGE\") AS \"AVG\" \n   FROM \"USERS\" \"USERS\" \n   WHERE \"USERS\".\"ID\" > 0 \n   GROUP BY \"USERS\".\"AGE\" \n   HAVING (\"USERS\".\"AGE\" > 1 AND COUNT(1) > 0)\n */\n```', '2016-12-02 15:56:48', '2016-12-03 14:22:09', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149550670249984', 'Oracle-聚合查询', 'Oracle-聚合查询', 'Oracle-聚合查询', '<h1 id=\"h1-u805Au5408u67E5u8BE2\"><a name=\"聚合查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>聚合查询</h1><p>Chloe 可以像写 sql 一样实现聚合查询。</p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nq.Select(a =&gt; AggregateFunctions.Count()).First();\n/*\n * SELECT COUNT(1) AS &quot;C&quot; FROM &quot;USERS&quot; &quot;USERS&quot; WHERE ROWNUM &lt; 2\n */\n\n/* 支持多个聚合函数 */\nq.Select(a =&gt; new\n{\n    Count = AggregateFunctions.Count(),\n    LongCount = AggregateFunctions.LongCount(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Average = AggregateFunctions.Average(a.Age)\n}).First();\n/*\n * SELECT COUNT(1) AS &quot;COUNT&quot;,COUNT(1) AS &quot;LONGCOUNT&quot;,SUM(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;SUM&quot;,MAX(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;MAX&quot;,MIN(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;MIN&quot;,AVG(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;AVERAGE&quot; \n   FROM &quot;USERS&quot; &quot;USERS&quot; \n   WHERE ROWNUM &lt; 2\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS &quot;C&quot; FROM &quot;USERS&quot; &quot;USERS&quot;\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT(1) AS &quot;C&quot; FROM &quot;USERS&quot; &quot;USERS&quot;\n */\n\nvar sum = q.Sum(a =&gt; a.Age);\n/*\n * SELECT SUM(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;C&quot; FROM &quot;USERS&quot; &quot;USERS&quot;\n */\n\nvar max = q.Max(a =&gt; a.Age);\n/*\n * SELECT MAX(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;C&quot; FROM &quot;USERS&quot; &quot;USERS&quot;\n */\n\nvar min = q.Min(a =&gt; a.Age);\n/*\n * SELECT MIN(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;C&quot; FROM &quot;USERS&quot; &quot;USERS&quot;\n */\n\nvar avg = q.Average(a =&gt; a.Age);\n/*\n * SELECT AVG(&quot;USERS&quot;.&quot;AGE&quot;) AS &quot;C&quot; FROM &quot;USERS&quot; &quot;USERS&quot;\n */\n</code></pre>\n', '# 聚合查询\nChloe 可以像写 sql 一样实现聚合查询。\n```csharp\nIQuery<User> q = context.Query<User>();\n\nq.Select(a => AggregateFunctions.Count()).First();\n/*\n * SELECT COUNT(1) AS \"C\" FROM \"USERS\" \"USERS\" WHERE ROWNUM < 2\n */\n\n/* 支持多个聚合函数 */\nq.Select(a => new\n{\n    Count = AggregateFunctions.Count(),\n    LongCount = AggregateFunctions.LongCount(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Average = AggregateFunctions.Average(a.Age)\n}).First();\n/*\n * SELECT COUNT(1) AS \"COUNT\",COUNT(1) AS \"LONGCOUNT\",SUM(\"USERS\".\"AGE\") AS \"SUM\",MAX(\"USERS\".\"AGE\") AS \"MAX\",MIN(\"USERS\".\"AGE\") AS \"MIN\",AVG(\"USERS\".\"AGE\") AS \"AVERAGE\" \n   FROM \"USERS\" \"USERS\" \n   WHERE ROWNUM < 2\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS \"C\" FROM \"USERS\" \"USERS\"\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT(1) AS \"C\" FROM \"USERS\" \"USERS\"\n */\n\nvar sum = q.Sum(a => a.Age);\n/*\n * SELECT SUM(\"USERS\".\"AGE\") AS \"C\" FROM \"USERS\" \"USERS\"\n */\n\nvar max = q.Max(a => a.Age);\n/*\n * SELECT MAX(\"USERS\".\"AGE\") AS \"C\" FROM \"USERS\" \"USERS\"\n */\n\nvar min = q.Min(a => a.Age);\n/*\n * SELECT MIN(\"USERS\".\"AGE\") AS \"C\" FROM \"USERS\" \"USERS\"\n */\n\nvar avg = q.Average(a => a.Age);\n/*\n * SELECT AVG(\"USERS\".\"AGE\") AS \"C\" FROM \"USERS\" \"USERS\"\n */\n```', '2016-12-02 15:57:12', '2016-12-03 14:23:22', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149605842124800', 'Oracle-Sql查询', 'Oracle-Sql查询', 'Oracle-Sql查询', '<h1 id=\"h1-sql-\"><a name=\"Sql查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Sql查询</h1><p>对于一些极其复杂的 sql 查询，还是得依赖原生 sql，因此，Chloe 提供了原生 sql 查询接口。<br><strong>获取满足条件的用户信息，将结果映射到 User 类上：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;User&gt;(&quot;select * from Users where Age&gt;:age&quot;, new DbParam(&quot;:age&quot;, 18)).ToList();\n</code></pre>\n<p><strong>获取满足条件的用户 Id：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;int&gt;(&quot;select Id from Users where Age&gt;:age&quot;, new DbParam(&quot;:age&quot;, 18)).ToList();\n</code></pre>\n<p><strong>支持存储过程：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;User&gt;(&quot;Proc_Test&quot;, CommandType.StoredProcedure, new DbParam(&quot;:age&quot;, 18)).ToList();\n</code></pre>\n', '# Sql查询\n对于一些极其复杂的 sql 查询，还是得依赖原生 sql，因此，Chloe 提供了原生 sql 查询接口。\n**获取满足条件的用户信息，将结果映射到 User 类上：**\n```csharp\ncontext.SqlQuery<User>(\"select * from Users where Age>:age\", new DbParam(\":age\", 18)).ToList();\n```\n**获取满足条件的用户 Id：**\n```csharp\ncontext.SqlQuery<int>(\"select Id from Users where Age>:age\", new DbParam(\":age\", 18)).ToList();\n```\n**支持存储过程：**\n```csharp\ncontext.SqlQuery<User>(\"Proc_Test\", CommandType.StoredProcedure, new DbParam(\":age\", 18)).ToList();\n```', '2016-12-02 15:57:25', '2016-12-03 14:25:02', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149662540726272', 'Oracle-插入数据', 'Oracle-插入数据', 'Oracle-插入数据', '<h1 id=\"h1-u63D2u5165u6570u636E\"><a name=\"插入数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>插入数据</h1><p>Chloe 具备两种插入数据的方式。<br><strong>1.实体插入：</strong><br>该方式插入，如果一个实体存在自增列（序列），会自动将自增列设置到相应的属性上。</p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Name = &quot;lu&quot;;\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = DateTime.Now;\n\n/* 会自动将自增 Id 设置到 user 的 Id 属性上 */\nuser = context.Insert(user);\n/*\n * SELECT &quot;USERS_AUTOID&quot;.&quot;NEXTVAL&quot; FROM &quot;DUAL&quot;\n * Int32 :P_0 = 15;\n   String :P_1 = &#39;lu&#39;;\n   Int32 :P_2 = 1;\n   Int32 :P_3 = 18;\n   DateTime :P_4 = &#39;2016/9/5 9:16:59&#39;;\n   INSERT INTO &quot;USERS&quot;(&quot;ID&quot;,&quot;NAME&quot;,&quot;GENDER&quot;,&quot;AGE&quot;,&quot;CITYID&quot;,&quot;OPTIME&quot;)     \n   VALUES(:P_0,:P_1,:P_2,:P_3,:P_2,:P_4)\n */\n</code></pre>\n<p><strong>2.lambda 方式插入：</strong><br>此种方式插入的好处是，可以指定列插入，就像写 sql 一样简单。<br>同时，该方式插入返回表主键值。如果实体主键是自增列，返回值就会是自增值。</p>\n<pre><code class=\"lang-csharp\">/* 返回主键 Id */\nint id = (int)context.Insert&lt;User&gt;(() =&gt; new User()\n{\n    Name = &quot;lu&quot;,\n    Age = 18,\n    Gender = Gender.Man,\n    CityId = 1,\n    OpTime = DateTime.Now\n});\n/*\n * SELECT &quot;USERS_AUTOID&quot;.&quot;NEXTVAL&quot; FROM &quot;DUAL&quot;\n * Int32 :P_0 = 14;\n   INSERT INTO &quot;USERS&quot;(&quot;NAME&quot;,&quot;AGE&quot;,&quot;GENDER&quot;,&quot;CITYID&quot;,&quot;OPTIME&quot;,&quot;ID&quot;) \n   VALUES(N&#39;lu&#39;,18,1,1,SYSTIMESTAMP,:P_0)\n */\n</code></pre>\n', '# 插入数据\nChloe 具备两种插入数据的方式。\n**1.实体插入：**\n该方式插入，如果一个实体存在自增列（序列），会自动将自增列设置到相应的属性上。\n```csharp\nUser user = new User();\nuser.Name = \"lu\";\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = DateTime.Now;\n\n/* 会自动将自增 Id 设置到 user 的 Id 属性上 */\nuser = context.Insert(user);\n/*\n * SELECT \"USERS_AUTOID\".\"NEXTVAL\" FROM \"DUAL\"\n * Int32 :P_0 = 15;\n   String :P_1 = \'lu\';\n   Int32 :P_2 = 1;\n   Int32 :P_3 = 18;\n   DateTime :P_4 = \'2016/9/5 9:16:59\';\n   INSERT INTO \"USERS\"(\"ID\",\"NAME\",\"GENDER\",\"AGE\",\"CITYID\",\"OPTIME\")     \n   VALUES(:P_0,:P_1,:P_2,:P_3,:P_2,:P_4)\n */\n```\n**2.lambda 方式插入：**\n此种方式插入的好处是，可以指定列插入，就像写 sql 一样简单。\n同时，该方式插入返回表主键值。如果实体主键是自增列，返回值就会是自增值。\n```csharp\n/* 返回主键 Id */\nint id = (int)context.Insert<User>(() => new User()\n{\n    Name = \"lu\",\n    Age = 18,\n    Gender = Gender.Man,\n    CityId = 1,\n    OpTime = DateTime.Now\n});\n/*\n * SELECT \"USERS_AUTOID\".\"NEXTVAL\" FROM \"DUAL\"\n * Int32 :P_0 = 14;\n   INSERT INTO \"USERS\"(\"NAME\",\"AGE\",\"GENDER\",\"CITYID\",\"OPTIME\",\"ID\") \n   VALUES(N\'lu\',18,1,1,SYSTIMESTAMP,:P_0)\n */\n```', '2016-12-02 15:57:39', '2016-12-04 22:22:24', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149712301948928', 'Oracle-更新数据', 'Oracle-更新数据', 'Oracle-更新数据', '<h1 id=\"h1-u66F4u65B0u6570u636E\"><a name=\"更新数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更新数据</h1><p>Chloe 支持两种数据更新方式。<br><strong>1.实体更新：</strong></p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Id = 1;\nuser.Name = &quot;lu&quot;;\nuser.Age = 28;\nuser.Gender = Gender.Man;\nuser.OpTime = DateTime.Now;\n\n/* 更新所有映射的字段 */\ncontext.Update(user);\n/*\n * String :P_0 = &#39;lu&#39;;\n   Int32 :P_1 = 1;\n   Int32 :P_2 = 28;\n   Nullable&lt;Int32&gt; :P_3 = NULL;\n   DateTime :P_4 = &#39;2016/9/5 9:20:07&#39;;\n   UPDATE &quot;USERS&quot; SET &quot;NAME&quot;=:P_0,&quot;GENDER&quot;=:P_1,&quot;AGE&quot;=:P_2,&quot;CITYID&quot;=:P_3,&quot;OPTIME&quot;=:P_4 \n   WHERE &quot;USERS&quot;.&quot;ID&quot; = :P_1\n */\n</code></pre>\n<p>由于 user 对象未被上下文跟踪，这会使所有的映射列都会被更新。Chloe 也支持类似 EF 一样只更新被修改过的属性。</p>\n<pre><code class=\"lang-csharp\">/*\n * 支持只更新属性值已变的属性\n */\n\n/* 在修改实体属性前让上下文跟踪实体 */\ncontext.TrackEntity(user);\n\n/* 然后再修改实体属性 */\nuser.Name = user.Name + &quot;1&quot;;\n\n/* 然后调用 Update 方法，这时只会更新被修改过的属性 */\ncontext.Update(user);\n/*\n * String :P_0 = &#39;lu1&#39;;\n   Int32 :P_1 = 1;\n   UPDATE &quot;USERS&quot; SET &quot;NAME&quot;=:P_0 WHERE &quot;USERS&quot;.&quot;ID&quot; = :P_1\n */\n</code></pre>\n<p><strong>2.lambda 方式更新：</strong><br>该方式解决的问题是：1.指定列更新；2.批量更新；3.支持类似 Age=Age + 100 这样更新字段。用法如下：</p>\n<pre><code class=\"lang-csharp\">context.Update&lt;User&gt;(a =&gt; a.Age &gt; 18, a =&gt; new User()\n{\n    Name = a.Name,\n    Age = a.Age + 100,\n    Gender = Gender.Man,\n    OpTime = DateTime.Now\n});\n/*\n * UPDATE &quot;USERS&quot; SET &quot;NAME&quot;=&quot;USERS&quot;.&quot;NAME&quot;,&quot;AGE&quot;=(&quot;USERS&quot;.&quot;AGE&quot; + 100),&quot;GENDER&quot;=1,&quot;OPTIME&quot;=SYSTIMESTAMP \n   WHERE &quot;USERS&quot;.&quot;AGE&quot; &gt; 18\n */\n</code></pre>\n', '# 更新数据\nChloe 支持两种数据更新方式。\n**1.实体更新：**\n```csharp\nUser user = new User();\nuser.Id = 1;\nuser.Name = \"lu\";\nuser.Age = 28;\nuser.Gender = Gender.Man;\nuser.OpTime = DateTime.Now;\n\n/* 更新所有映射的字段 */\ncontext.Update(user);\n/*\n * String :P_0 = \'lu\';\n   Int32 :P_1 = 1;\n   Int32 :P_2 = 28;\n   Nullable<Int32> :P_3 = NULL;\n   DateTime :P_4 = \'2016/9/5 9:20:07\';\n   UPDATE \"USERS\" SET \"NAME\"=:P_0,\"GENDER\"=:P_1,\"AGE\"=:P_2,\"CITYID\"=:P_3,\"OPTIME\"=:P_4 \n   WHERE \"USERS\".\"ID\" = :P_1\n */\n```\n由于 user 对象未被上下文跟踪，这会使所有的映射列都会被更新。Chloe 也支持类似 EF 一样只更新被修改过的属性。\n```csharp\n/*\n * 支持只更新属性值已变的属性\n */\n\n/* 在修改实体属性前让上下文跟踪实体 */\ncontext.TrackEntity(user);\n\n/* 然后再修改实体属性 */\nuser.Name = user.Name + \"1\";\n\n/* 然后调用 Update 方法，这时只会更新被修改过的属性 */\ncontext.Update(user);\n/*\n * String :P_0 = \'lu1\';\n   Int32 :P_1 = 1;\n   UPDATE \"USERS\" SET \"NAME\"=:P_0 WHERE \"USERS\".\"ID\" = :P_1\n */\n```\n**2.lambda 方式更新：**\n该方式解决的问题是：1.指定列更新；2.批量更新；3.支持类似 Age=Age + 100 这样更新字段。用法如下：\n```csharp\ncontext.Update<User>(a => a.Age > 18, a => new User()\n{\n    Name = a.Name,\n    Age = a.Age + 100,\n    Gender = Gender.Man,\n    OpTime = DateTime.Now\n});\n/*\n * UPDATE \"USERS\" SET \"NAME\"=\"USERS\".\"NAME\",\"AGE\"=(\"USERS\".\"AGE\" + 100),\"GENDER\"=1,\"OPTIME\"=SYSTIMESTAMP \n   WHERE \"USERS\".\"AGE\" > 18\n */\n```', '2016-12-02 15:57:51', '2016-12-03 14:34:21', '0', null);
INSERT INTO `wikidocument` VALUES ('3325149761299808256', 'Oracle-删除数据', 'Oracle-删除数据', 'Oracle-删除数据', '<h1 id=\"h1-u5220u9664u6570u636E\"><a name=\"删除数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除数据</h1><p>Chloe 支持两种数据删除方式。<br><strong>1.实体删除：</strong><br>该方式删除必须要求实体拥有一个主键，否则会报异常提示。</p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 :P_0 = 1;\n   DELETE FROM &quot;USERS&quot; WHERE &quot;USERS&quot;.&quot;ID&quot; = :P_0\n */\n</code></pre>\n<p><strong>2.lambda 方式删除：</strong><br>使用该方式可以删除单条数据，也可以删除多条数据。</p>\n<pre><code class=\"lang-csharp\">/* 删除单条数据 */\ncontext.Delete&lt;User&gt;(a =&gt; a.Id == 1);\n/*\n * DELETE FROM &quot;USERS&quot; WHERE &quot;USERS&quot;.&quot;ID&quot; = 1\n */\n\n/* 批量删除满足条件的数据 */\ncontext.Delete&lt;User&gt;(a =&gt; a.Age &gt; 18);\n/*\n * DELETE FROM &quot;USERS&quot; WHERE &quot;USERS&quot;.&quot;AGE&quot; &gt; 18\n */\n</code></pre>\n', '# 删除数据\nChloe 支持两种数据删除方式。\n**1.实体删除：**\n该方式删除必须要求实体拥有一个主键，否则会报异常提示。\n```csharp\nUser user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 :P_0 = 1;\n   DELETE FROM \"USERS\" WHERE \"USERS\".\"ID\" = :P_0\n */\n```\n**2.lambda 方式删除：**\n使用该方式可以删除单条数据，也可以删除多条数据。\n```csharp\n/* 删除单条数据 */\ncontext.Delete<User>(a => a.Id == 1);\n/*\n * DELETE FROM \"USERS\" WHERE \"USERS\".\"ID\" = 1\n */\n\n/* 批量删除满足条件的数据 */\ncontext.Delete<User>(a => a.Age > 18);\n/*\n * DELETE FROM \"USERS\" WHERE \"USERS\".\"AGE\" > 18\n */\n```', '2016-12-02 15:58:02', '2016-12-03 15:17:54', '0', null);
INSERT INTO `wikidocument` VALUES ('3325150100572864512', 'Oracle-存储过程', 'Oracle-存储过程', 'Oracle-存储过程', '<h1 id=\"h1-u5B58u50A8u8FC7u7A0B\"><a name=\"存储过程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>存储过程</h1><p>Chloe 支持存储过程以及 output 参数。<br><strong>通过存储过程获取一个 User 信息：</strong><br>Oracle 数据库中，如果一个存储过程需要返回结果集，需要借助 RefCursor output 参数特性。用法如下：</p>\n<pre><code class=\"lang-csharp\">/* 必须先自定义 RefCursor 参数 */\nOracleParameter p_cur = new OracleParameter();\np_cur.ParameterName = &quot;p_cur&quot;;\np_cur.OracleDbType = OracleDbType.RefCursor;\np_cur.Direction = ParameterDirection.Output;\n\nDbParam refCursorParam = new DbParam();\n/* 将自定义 RefCursor 参数设置到 DbParam 的 ExplicitParameter 属性 */\nrefCursorParam.ExplicitParameter = p_cur;\n\nDbParam id = new DbParam(&quot;id&quot;, 1);\nUser user = context.SqlQuery&lt;User&gt;(&quot;Proc_GetUser&quot;, CommandType.StoredProcedure, id，refCursorParam).FirstOrDefault();\n</code></pre>\n<p><strong>通过存储过程的 output 参数获取一个用户的 name：</strong></p>\n<pre><code class=\"lang-csharp\">DbParam id = new DbParam(&quot;id&quot;, 1);\nDbParam outputName = new DbParam(&quot;name&quot;, null, typeof(string)) { Direction = ParamDirection.Output };\ncontext.Session.ExecuteNonQuery(&quot;Proc_GetUserName&quot;, CommandType.StoredProcedure, id, outputName);\n</code></pre>\n', '# 存储过程\nChloe 支持存储过程以及 output 参数。\n**通过存储过程获取一个 User 信息：**\nOracle 数据库中，如果一个存储过程需要返回结果集，需要借助 RefCursor output 参数特性。用法如下：\n```csharp\n/* 必须先自定义 RefCursor 参数 */\nOracleParameter p_cur = new OracleParameter();\np_cur.ParameterName = \"p_cur\";\np_cur.OracleDbType = OracleDbType.RefCursor;\np_cur.Direction = ParameterDirection.Output;\n\nDbParam refCursorParam = new DbParam();\n/* 将自定义 RefCursor 参数设置到 DbParam 的 ExplicitParameter 属性 */\nrefCursorParam.ExplicitParameter = p_cur;\n\nDbParam id = new DbParam(\"id\", 1);\nUser user = context.SqlQuery<User>(\"Proc_GetUser\", CommandType.StoredProcedure, id，refCursorParam).FirstOrDefault();\n```\n**通过存储过程的 output 参数获取一个用户的 name：**\n```csharp\nDbParam id = new DbParam(\"id\", 1);\nDbParam outputName = new DbParam(\"name\", null, typeof(string)) { Direction = ParamDirection.Output };\ncontext.Session.ExecuteNonQuery(\"Proc_GetUserName\", CommandType.StoredProcedure, id, outputName);\n```', '2016-12-02 15:59:23', '2016-12-05 23:11:56', '0', null);
INSERT INTO `wikidocument` VALUES ('3325150155606327296', 'Oracle-事务', 'Oracle-事务', 'Oracle-事务', '<h1 id=\"h1-u4E8Bu52A1u652Fu6301\"><a name=\"事务支持\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>事务支持</h1><p><strong>基本用法：</strong></p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nusing (OracleContext context = new OracleContext(new OracleConnectionFactory(connString)))\n{\n    try\n    {\n        context.Session.BeginTransaction();\n\n        /* do some things here */\n        context.Update(user);\n        context.Delete&lt;User&gt;(a =&gt; a.Gender == null);\n\n        context.Session.CommitTransaction();\n    }\n    catch\n    {\n        if (context.Session.IsInTransaction)\n            context.Session.RollbackTransaction();\n        throw;\n    }\n}\n</code></pre>\n', '# 事务支持\n**基本用法：**\n```csharp\nstring connString = \"Your connection string\";\nusing (OracleContext context = new OracleContext(new OracleConnectionFactory(connString)))\n{\n    try\n    {\n        context.Session.BeginTransaction();\n\n        /* do some things here */\n        context.Update(user);\n        context.Delete<User>(a => a.Gender == null);\n\n        context.Session.CommitTransaction();\n    }\n    catch\n    {\n        if (context.Session.IsInTransaction)\n            context.Session.RollbackTransaction();\n        throw;\n    }\n}\n```', '2016-12-02 15:59:36', '2016-12-03 14:56:43', '0', null);
INSERT INTO `wikidocument` VALUES ('3325150214624378880', 'Oracle-常用函数', 'Oracle-常用函数', 'Oracle-常用函数', '<h1 id=\"h1-u5E38u7528u51FDu6570\"><a name=\"常用函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>常用函数</h1><p><strong>Chloe 对很多数据库函数支持很丰富，具体用法如下：</strong></p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nvar space = new char[] { &#39; &#39; };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = startTime.AddDays(1);\nvar ret = q.Select(a =&gt; new\n     {\n         Id = a.Id,\n\n         String_Length = (int?)a.Name.Length,//LENGTH(&quot;USERS&quot;.&quot;NAME&quot;)\n         Substring = a.Name.Substring(0),//SUBSTR(&quot;USERS&quot;.&quot;NAME&quot;,0 + 1,LENGTH(&quot;USERS&quot;.&quot;NAME&quot;))\n         Substring1 = a.Name.Substring(1),//SUBSTR(&quot;USERS&quot;.&quot;NAME&quot;,1 + 1,LENGTH(&quot;USERS&quot;.&quot;NAME&quot;))\n         Substring1_2 = a.Name.Substring(1, 2),//SUBSTR(&quot;USERS&quot;.&quot;NAME&quot;,1 + 1,2)\n         ToLower = a.Name.ToLower(),//LOWER(&quot;USERS&quot;.&quot;NAME&quot;)\n         ToUpper = a.Name.ToUpper(),//UPPER(&quot;USERS&quot;.&quot;NAME&quot;)\n         IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//too long\n         Contains = (bool?)a.Name.Contains(&quot;s&quot;),//\n         Trim = a.Name.Trim(),//TRIM(&quot;USERS&quot;.&quot;NAME&quot;)\n         TrimStart = a.Name.TrimStart(space),//LTRIM(&quot;USERS&quot;.&quot;NAME&quot;)\n         TrimEnd = a.Name.TrimEnd(space),//RTRIM(&quot;USERS&quot;.&quot;NAME&quot;)\n         StartsWith = (bool?)a.Name.StartsWith(&quot;s&quot;),//\n         EndsWith = (bool?)a.Name.EndsWith(&quot;s&quot;),//\n\n         /* oracle is not supported DbFunctions.Diffxx. */\n         //DiffYears = DbFunctions.DiffYears(startTime, endTime),//\n         //DiffMonths = DbFunctions.DiffMonths(startTime, endTime),//\n         //DiffDays = DbFunctions.DiffDays(startTime, endTime),//\n         //DiffHours = DbFunctions.DiffHours(startTime, endTime),//\n         //DiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//\n         //DiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//\n         //DiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//\n         //DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//\n\n         /* ((CAST(:P_0 AS DATE)-CAST(:P_1 AS DATE)) * 86400000 + CAST(TO_CHAR(CAST(:P_0 AS TIMESTAMP),&#39;ff3&#39;) AS NUMBER) - CAST(TO_CHAR(CAST(:P_1 AS TIMESTAMP),&#39;ff3&#39;) AS NUMBER)) / 86400000 */\n         SubtractTotalDays = endTime.Subtract(startTime).TotalDays,//\n         SubtractTotalHours = endTime.Subtract(startTime).TotalHours,//...\n         SubtractTotalMinutes = endTime.Subtract(startTime).TotalMinutes,//...\n         SubtractTotalSeconds = endTime.Subtract(startTime).TotalSeconds,//...\n         SubtractTotalMilliseconds = endTime.Subtract(startTime).TotalMilliseconds,//...\n\n         AddYears = startTime.AddYears(1),//ADD_MONTHS(:P_0,12 * 1)\n         AddMonths = startTime.AddMonths(1),//ADD_MONTHS(:P_0,1)\n         AddDays = startTime.AddDays(1),//(:P_0 + 1)\n         AddHours = startTime.AddHours(1),//(:P_0 + NUMTODSINTERVAL(1,&#39;HOUR&#39;))\n         AddMinutes = startTime.AddMinutes(2),//(:P_0 + NUMTODSINTERVAL(2,&#39;MINUTE&#39;))\n         AddSeconds = startTime.AddSeconds(120),//(:P_0 + NUMTODSINTERVAL(120,&#39;SECOND&#39;))\n         //AddMilliseconds = startTime.AddMilliseconds(20000),//不支持\n\n         Now = DateTime.Now,//SYSTIMESTAMP\n         UtcNow = DateTime.UtcNow,//SYS_EXTRACT_UTC(SYSTIMESTAMP)\n         Today = DateTime.Today,//TRUNC(SYSDATE,&#39;DD&#39;)\n         Date = DateTime.Now.Date,//TRUNC(SYSTIMESTAMP,&#39;DD&#39;)\n         Year = DateTime.Now.Year,//CAST(TO_CHAR(SYSTIMESTAMP,&#39;yyyy&#39;) AS NUMBER)\n         Month = DateTime.Now.Month,//CAST(TO_CHAR(SYSTIMESTAMP,&#39;mm&#39;) AS NUMBER)\n         Day = DateTime.Now.Day,//CAST(TO_CHAR(SYSTIMESTAMP,&#39;dd&#39;) AS NUMBER)\n         Hour = DateTime.Now.Hour,//CAST(TO_CHAR(SYSTIMESTAMP,&#39;hh24&#39;) AS NUMBER)\n         Minute = DateTime.Now.Minute,//CAST(TO_CHAR(SYSTIMESTAMP,&#39;mi&#39;) AS NUMBER)\n         Second = DateTime.Now.Second,//CAST(TO_CHAR(SYSTIMESTAMP,&#39;ss&#39;) AS NUMBER)\n         Millisecond = DateTime.Now.Millisecond,//CAST(TO_CHAR(SYSTIMESTAMP,&#39;ff3&#39;) AS NUMBER)\n         DayOfWeek = DateTime.Now.DayOfWeek,//(CAST(TO_CHAR(SYSTIMESTAMP,&#39;D&#39;) AS NUMBER) - 1)\n\n         Int_Parse = int.Parse(&quot;1&quot;),//CAST(N&#39;1&#39; AS NUMBER)\n         Int16_Parse = Int16.Parse(&quot;11&quot;),//CAST(N&#39;11&#39; AS NUMBER)\n         Long_Parse = long.Parse(&quot;2&quot;),//CAST(N&#39;2&#39; AS NUMBER)\n         Double_Parse = double.Parse(&quot;3&quot;),//CAST(N&#39;3&#39; AS BINARY_DOUBLE)\n         Float_Parse = float.Parse(&quot;4&quot;),//CAST(N&#39;4&#39; AS BINARY_FLOAT)\n         Decimal_Parse = decimal.Parse(&quot;5&quot;),//CAST(N&#39;5&#39; AS NUMBER)\n         //Guid_Parse = Guid.Parse(&quot;D544BC4C-739E-4CD3-A3D3-7BF803FCE179&quot;),//不支持\n\n         Bool_Parse = bool.Parse(&quot;1&quot;),//\n         DateTime_Parse = DateTime.Parse(&quot;1992-1-16&quot;),//TO_TIMESTAMP(N&#39;1992-1-16&#39;,&#39;yyyy-mm-dd hh24:mi:ssxff&#39;)\n\n         B = a.Age == null ? false : a.Age &gt; 1,\n     }).ToList();\n</code></pre>\n<p>上述的函数可以用于 Select 方法，亦可用在 Where 或其它方法的 lambda 表达式树中，最终都会翻译成数据库函数。</p>\n', '# 常用函数\n**Chloe 对很多数据库函数支持很丰富，具体用法如下：**\n```csharp\nIQuery<User> q = context.Query<User>();\n\nvar space = new char[] { \' \' };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = startTime.AddDays(1);\nvar ret = q.Select(a => new\n     {\n         Id = a.Id,\n\n         String_Length = (int?)a.Name.Length,//LENGTH(\"USERS\".\"NAME\")\n         Substring = a.Name.Substring(0),//SUBSTR(\"USERS\".\"NAME\",0 + 1,LENGTH(\"USERS\".\"NAME\"))\n         Substring1 = a.Name.Substring(1),//SUBSTR(\"USERS\".\"NAME\",1 + 1,LENGTH(\"USERS\".\"NAME\"))\n         Substring1_2 = a.Name.Substring(1, 2),//SUBSTR(\"USERS\".\"NAME\",1 + 1,2)\n         ToLower = a.Name.ToLower(),//LOWER(\"USERS\".\"NAME\")\n         ToUpper = a.Name.ToUpper(),//UPPER(\"USERS\".\"NAME\")\n         IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//too long\n         Contains = (bool?)a.Name.Contains(\"s\"),//\n         Trim = a.Name.Trim(),//TRIM(\"USERS\".\"NAME\")\n         TrimStart = a.Name.TrimStart(space),//LTRIM(\"USERS\".\"NAME\")\n         TrimEnd = a.Name.TrimEnd(space),//RTRIM(\"USERS\".\"NAME\")\n         StartsWith = (bool?)a.Name.StartsWith(\"s\"),//\n         EndsWith = (bool?)a.Name.EndsWith(\"s\"),//\n\n         /* oracle is not supported DbFunctions.Diffxx. */\n         //DiffYears = DbFunctions.DiffYears(startTime, endTime),//\n         //DiffMonths = DbFunctions.DiffMonths(startTime, endTime),//\n         //DiffDays = DbFunctions.DiffDays(startTime, endTime),//\n         //DiffHours = DbFunctions.DiffHours(startTime, endTime),//\n         //DiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//\n         //DiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//\n         //DiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//\n         //DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//\n\n         /* ((CAST(:P_0 AS DATE)-CAST(:P_1 AS DATE)) * 86400000 + CAST(TO_CHAR(CAST(:P_0 AS TIMESTAMP),\'ff3\') AS NUMBER) - CAST(TO_CHAR(CAST(:P_1 AS TIMESTAMP),\'ff3\') AS NUMBER)) / 86400000 */\n         SubtractTotalDays = endTime.Subtract(startTime).TotalDays,//\n         SubtractTotalHours = endTime.Subtract(startTime).TotalHours,//...\n         SubtractTotalMinutes = endTime.Subtract(startTime).TotalMinutes,//...\n         SubtractTotalSeconds = endTime.Subtract(startTime).TotalSeconds,//...\n         SubtractTotalMilliseconds = endTime.Subtract(startTime).TotalMilliseconds,//...\n\n         AddYears = startTime.AddYears(1),//ADD_MONTHS(:P_0,12 * 1)\n         AddMonths = startTime.AddMonths(1),//ADD_MONTHS(:P_0,1)\n         AddDays = startTime.AddDays(1),//(:P_0 + 1)\n         AddHours = startTime.AddHours(1),//(:P_0 + NUMTODSINTERVAL(1,\'HOUR\'))\n         AddMinutes = startTime.AddMinutes(2),//(:P_0 + NUMTODSINTERVAL(2,\'MINUTE\'))\n         AddSeconds = startTime.AddSeconds(120),//(:P_0 + NUMTODSINTERVAL(120,\'SECOND\'))\n         //AddMilliseconds = startTime.AddMilliseconds(20000),//不支持\n\n         Now = DateTime.Now,//SYSTIMESTAMP\n         UtcNow = DateTime.UtcNow,//SYS_EXTRACT_UTC(SYSTIMESTAMP)\n         Today = DateTime.Today,//TRUNC(SYSDATE,\'DD\')\n         Date = DateTime.Now.Date,//TRUNC(SYSTIMESTAMP,\'DD\')\n         Year = DateTime.Now.Year,//CAST(TO_CHAR(SYSTIMESTAMP,\'yyyy\') AS NUMBER)\n         Month = DateTime.Now.Month,//CAST(TO_CHAR(SYSTIMESTAMP,\'mm\') AS NUMBER)\n         Day = DateTime.Now.Day,//CAST(TO_CHAR(SYSTIMESTAMP,\'dd\') AS NUMBER)\n         Hour = DateTime.Now.Hour,//CAST(TO_CHAR(SYSTIMESTAMP,\'hh24\') AS NUMBER)\n         Minute = DateTime.Now.Minute,//CAST(TO_CHAR(SYSTIMESTAMP,\'mi\') AS NUMBER)\n         Second = DateTime.Now.Second,//CAST(TO_CHAR(SYSTIMESTAMP,\'ss\') AS NUMBER)\n         Millisecond = DateTime.Now.Millisecond,//CAST(TO_CHAR(SYSTIMESTAMP,\'ff3\') AS NUMBER)\n         DayOfWeek = DateTime.Now.DayOfWeek,//(CAST(TO_CHAR(SYSTIMESTAMP,\'D\') AS NUMBER) - 1)\n\n         Int_Parse = int.Parse(\"1\"),//CAST(N\'1\' AS NUMBER)\n         Int16_Parse = Int16.Parse(\"11\"),//CAST(N\'11\' AS NUMBER)\n         Long_Parse = long.Parse(\"2\"),//CAST(N\'2\' AS NUMBER)\n         Double_Parse = double.Parse(\"3\"),//CAST(N\'3\' AS BINARY_DOUBLE)\n         Float_Parse = float.Parse(\"4\"),//CAST(N\'4\' AS BINARY_FLOAT)\n         Decimal_Parse = decimal.Parse(\"5\"),//CAST(N\'5\' AS NUMBER)\n         //Guid_Parse = Guid.Parse(\"D544BC4C-739E-4CD3-A3D3-7BF803FCE179\"),//不支持\n\n         Bool_Parse = bool.Parse(\"1\"),//\n         DateTime_Parse = DateTime.Parse(\"1992-1-16\"),//TO_TIMESTAMP(N\'1992-1-16\',\'yyyy-mm-dd hh24:mi:ssxff\')\n\n         B = a.Age == null ? false : a.Age > 1,\n     }).ToList();\n```\n上述的函数可以用于 Select 方法，亦可用在 Where 或其它方法的 lambda 表达式树中，最终都会翻译成数据库函数。', '2016-12-02 15:59:50', '2016-12-03 14:57:50', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155467776229376', 'SQLite-实体特性', 'SQLite-实体特性', 'SQLite-实体特性', '<h1 id=\"h1-u5B9Eu4F53u7279u6027\"><a name=\"实体特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实体特性</h1><p>实体特性位于命名空间 Chloe.Entity 下。<br><strong>TableAttribute：</strong><br>Name：映射的表名。<br>实体对应的表默认是实体类名，如实体类型名与表名不一致，可通过该特性指定映射的表名。</p>\n<pre><code class=\"lang-csharp\">public class TableAttribute : Attribute\n{\n    public TableAttribute() { }\n    public TableAttribute(string name)\n    {\n        Name = name;\n    }\n    public string Name { get; set; }\n}\n</code></pre>\n<p><strong>ColumnAttribute：</strong><br>Name：映射的列名，如不指定，则默认使用属性名。<br>IsPrimaryKey：指示列是否为主键，默认为 false。<br>当一个实体没显示指定主键的时候，Chloe 默认选择名为 Id 的属性（如果存在）作为主键列，与此同时，如果该实体也没有显示指定任何自增列并且 Id 属性为 Int16、Int32 或者 Int64 类型，则也会默认其为自增列。</p>\n<pre><code class=\"lang-csharp\">public class ColumnAttribute : Attribute\n{\n    public ColumnAttribute() { }\n    public ColumnAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; set; }\n    public bool IsPrimaryKey { get; set; }\n}\n</code></pre>\n<p><strong>AutoIncrementAttribute：</strong><br>标记属性为自增列。在 SqlServer 中，一个实体不能指定多个自增列，否则会报异常提示。</p>\n<pre><code class=\"lang-csharp\">public class AutoIncrementAttribute : Attribute\n{\n}\n</code></pre>\n<p><strong>NonAutoIncrementAttribute：</strong><br>标记属性为非自增列。</p>\n<pre><code class=\"lang-csharp\">public class NonAutoIncrementAttribute : Attribute\n{\n}\n</code></pre>\n<p><strong>NotMappedAttribute：</strong><br>指示属性不映射任何列。</p>\n<pre><code class=\"lang-csharp\">public class NotMappedAttribute : Attribute\n{\n}\n</code></pre>\n', '# 实体特性\n实体特性位于命名空间 Chloe.Entity 下。\n**TableAttribute：**\nName：映射的表名。\n实体对应的表默认是实体类名，如实体类型名与表名不一致，可通过该特性指定映射的表名。\n```csharp\npublic class TableAttribute : Attribute\n{\n    public TableAttribute() { }\n    public TableAttribute(string name)\n    {\n        Name = name;\n    }\n    public string Name { get; set; }\n}\n```\n**ColumnAttribute：**\nName：映射的列名，如不指定，则默认使用属性名。\nIsPrimaryKey：指示列是否为主键，默认为 false。\n当一个实体没显示指定主键的时候，Chloe 默认选择名为 Id 的属性（如果存在）作为主键列，与此同时，如果该实体也没有显示指定任何自增列并且 Id 属性为 Int16、Int32 或者 Int64 类型，则也会默认其为自增列。\n```csharp\npublic class ColumnAttribute : Attribute\n{\n    public ColumnAttribute() { }\n    public ColumnAttribute(string name)\n    {\n        this.Name = name;\n    }\n    public string Name { get; set; }\n    public bool IsPrimaryKey { get; set; }\n}\n```\n**AutoIncrementAttribute：**\n标记属性为自增列。在 SqlServer 中，一个实体不能指定多个自增列，否则会报异常提示。\n```csharp\npublic class AutoIncrementAttribute : Attribute\n{\n}\n```\n**NonAutoIncrementAttribute：**\n标记属性为非自增列。\n```csharp\npublic class NonAutoIncrementAttribute : Attribute\n{\n}\n```\n**NotMappedAttribute：**\n指示属性不映射任何列。\n```csharp\npublic class NotMappedAttribute : Attribute\n{\n}\n```', '2016-12-02 16:20:43', '2016-12-03 15:00:07', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155511531208704', 'SQLite-实体定义', 'SQLite-实体定义', 'SQLite-实体定义', '<h1 id=\"h1-u5B9Eu4F53u5B9Au4E49\"><a name=\"实体定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实体定义</h1><p>实体为纯 POCO，支持可空类型以及枚举类型映射。</p>\n<pre><code class=\"lang-csharp\">public enum Gender\n{\n    Man = 1,\n    Woman\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">[TableAttribute(&quot;Users&quot;)]\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">public class City\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n</code></pre>\n<pre><code class=\"lang-csharp\">public class Province\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n</code></pre>\n', '# 实体定义\n实体为纯 POCO，支持可空类型以及枚举类型映射。\n```csharp\npublic enum Gender\n{\n    Man = 1,\n    Woman\n}\n```\n```csharp\n[TableAttribute(\"Users\")]\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n```\n```csharp\npublic class City\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n```\n```csharp\npublic class Province\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n```', '2016-12-02 16:20:53', '2016-12-03 15:00:24', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155568988979200', 'SQLite-创建DbContext', 'SQLite-创建DbContext', 'SQLite-创建DbContext', '<h1 id=\"h1--dbcontext\"><a name=\"创建 DbContext\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建 DbContext</h1><p>对于 SQLite 数据库，需要引用程序集 Chloe.dll 和 Chloe.SQLite.dll，然后使用 Chloe.SQLite.SQLiteContext 创建上下文实例。<br>因为框架本身需要与具体的数据库驱动解耦，所以 SQLiteContext 构造函数需要一个 IDbConnectionFactory 的参数，IDbConnectionFactory 接口只有一个 CreateConnection() 方法，必须先建个类，实现 CreateConnection 方法。</p>\n<pre><code class=\"lang-csharp\">public class SQLiteConnectionFactory : IDbConnectionFactory\n{\n    string _connString = null;\n    public SQLiteConnectionFactory(string connString)\n    {\n        this._connString = connString;\n    }\n    public IDbConnection CreateConnection()\n    {\n        SQLiteConnection conn = new SQLiteConnection(this._connString);\n        return conn;\n    }\n}\n</code></pre>\n<p>接下来就可以创建 SQLiteContext：</p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nSQLiteContext context = new SQLiteContext(new SQLiteConnectionFactory(connString));\n</code></pre>\n', '# 创建 DbContext\n对于 SQLite 数据库，需要引用程序集 Chloe.dll 和 Chloe.SQLite.dll，然后使用 Chloe.SQLite.SQLiteContext 创建上下文实例。\n因为框架本身需要与具体的数据库驱动解耦，所以 SQLiteContext 构造函数需要一个 IDbConnectionFactory 的参数，IDbConnectionFactory 接口只有一个 CreateConnection() 方法，必须先建个类，实现 CreateConnection 方法。\n```csharp\npublic class SQLiteConnectionFactory : IDbConnectionFactory\n{\n    string _connString = null;\n    public SQLiteConnectionFactory(string connString)\n    {\n        this._connString = connString;\n    }\n    public IDbConnection CreateConnection()\n    {\n        SQLiteConnection conn = new SQLiteConnection(this._connString);\n        return conn;\n    }\n}\n```\n接下来就可以创建 SQLiteContext：\n```csharp\nstring connString = \"Your connection string\";\nSQLiteContext context = new SQLiteContext(new SQLiteConnectionFactory(connString));\n```', '2016-12-02 16:21:07', '2016-12-03 15:01:54', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155613347938304', 'SQLite-基本查询', 'SQLite-基本查询', 'SQLite-基本查询', '<h1 id=\"h1-u57FAu672Cu67E5u8BE2\"><a name=\"基本查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本查询</h1><p><strong>根据 Id 查询出一个 User 对象：</strong></p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nSQLiteContext context = new SQLiteContext(new SQLiteConnectionFactory(connString));\nIQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nq.Where(a =&gt; a.Id == 1).FirstOrDefault();\n/*\n *生成的 sql：\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] = 1 \n   LIMIT 1 OFFSET 0\n */\n</code></pre>\n<p><strong>in 查询：</strong></p>\n<pre><code class=\"lang-csharp\">List&lt;int&gt; ids = new List&lt;int&gt;() { 1, 2, 3 };\nq.Where(a =&gt; ids.Contains(a.Id)).ToList();\n/*\n * Int32 @P_0 = 1;\n   Int32 @P_1 = 2;\n   Int32 @P_2 = 3;\n   SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] IN (@P_0,@P_1,@P_2)\n */\n</code></pre>\n<p><strong>可以选取指定的字段，返回一个匿名类型：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id == 1).Select(a =&gt; new { a.Id, a.Name }).FirstOrDefault();\n/*\n * 只会生成包含 Id 和 Name 两个字段的 sql 语句：\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] = 1 \n   LIMIT 1 OFFSET 0\n */\n</code></pre>\n<p><strong>排序：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).ThenBy(a =&gt; a.Id).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] &gt; 0 \n   ORDER BY [Users].[Age] ASC,[Users].[Id] ASC\n */\n</code></pre>\n<p><strong>分页：</strong></p>\n<pre><code class=\"lang-csharp\">q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).TakePage(1, 20).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] &gt; 0 \n   ORDER BY [Users].[Age] ASC \n   LIMIT 20 OFFSET 0\n */\n</code></pre>\n', '# 基本查询\n**根据 Id 查询出一个 User 对象：**\n```csharp\nstring connString = \"Your connection string\";\nSQLiteContext context = new SQLiteContext(new SQLiteConnectionFactory(connString));\nIQuery<User> q = context.Query<User>();\n\nq.Where(a => a.Id == 1).FirstOrDefault();\n/*\n *生成的 sql：\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] = 1 \n   LIMIT 1 OFFSET 0\n */\n```\n**in 查询：**\n```csharp\nList<int> ids = new List<int>() { 1, 2, 3 };\nq.Where(a => ids.Contains(a.Id)).ToList();\n/*\n * Int32 @P_0 = 1;\n   Int32 @P_1 = 2;\n   Int32 @P_2 = 3;\n   SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] IN (@P_0,@P_1,@P_2)\n */\n```\n**可以选取指定的字段，返回一个匿名类型：**\n```csharp\nq.Where(a => a.Id == 1).Select(a => new { a.Id, a.Name }).FirstOrDefault();\n/*\n * 只会生成包含 Id 和 Name 两个字段的 sql 语句：\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] = 1 \n   LIMIT 1 OFFSET 0\n */\n```\n**排序：**\n```csharp\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).ThenBy(a => a.Id).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] > 0 \n   ORDER BY [Users].[Age] ASC,[Users].[Id] ASC\n */\n```\n**分页：**\n```csharp\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).TakePage(1, 20).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n   FROM [Users] AS [Users] \n   WHERE [Users].[Id] > 0 \n   ORDER BY [Users].[Age] ASC \n   LIMIT 20 OFFSET 0\n */\n```', '2016-12-02 16:21:18', '2016-12-08 11:32:49', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155661880229888', 'SQLite-连接查询', 'SQLite-连接查询', 'SQLite-连接查询', '<h1 id=\"h1-u8FDEu63A5u67E5u8BE2\"><a name=\"连接查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>连接查询</h1><p>Chloe 友好支持多表连接查询，一切都可以用 lambda 表达式操作，返回类型可以是自定义类型，也可以是匿名类型。强类型开发，编译可见错误，容错率高。<br><strong>1.创建相关的 IQuery 对象：</strong></p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; users = context.Query&lt;User&gt;();\nIQuery&lt;City&gt; cities = context.Query&lt;City&gt;();\nIQuery&lt;Province&gt; provinces = context.Query&lt;Province&gt;();\n</code></pre>\n<p><strong>2.建立连接：</strong></p>\n<pre><code class=\"lang-csharp\">/* User 表和 City 表 inner join，得到 IJoiningQuery&lt;User, City&gt; 对象 */\nIJoiningQuery&lt;User, City&gt; user_city = users.InnerJoin(cities, (user, city) =&gt; user.CityId == city.Id);\n\n/* City 表和 Province 表 inner join，得到 IJoiningQuery&lt;User, City, Province&gt; 对象 */\nIJoiningQuery&lt;User, City, Province&gt; user_city_province = user_city.InnerJoin(provinces, (user, city, province) =&gt; city.ProvinceId == province.Id);\n</code></pre>\n<p><strong>3.得到最终的 IJoiningQuery 对象，就可以 Select 所需要的数据返回一个 IQuery 对象，然后就可以进行 Where、OrderBy、GroupBy、分页、聚合查询等操作：</strong><br>查出一个用户及其隶属的城市和省份的所有信息：</p>\n<pre><code class=\"lang-csharp\">/* 调用 Select 方法返回一个泛型为包含 User、City、Province 匿名类型的 IQuery 对象。\n * Select 方法也可以返回自定义类型 。\n */\nvar qq = user_city_province.Select((user, city, province) =&gt; new\n{\n    User = user,\n    City = city,\n    Province = province\n});\n\n/* 根据条件筛选，然后调用 ToList 就会返回一个泛型为 new { User = user, City = city, Province = province } 的 List 集合 */\nvar result = qq.Where(a =&gt; a.User.Id == 1).ToList();\n\n/*\n * 生成的 sql：\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[City].[Id] AS [Id0],[City].[Name] AS [Name0],[City].[ProvinceId] AS [ProvinceId],[Province].[Id] AS [Id1],[Province].[Name] AS [Name1] \n   FROM [Users] AS [Users] \n   INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n   WHERE [Users].[Id] = 1\n */\n</code></pre>\n<p>可以只获取指定的字段信息：</p>\n<pre><code class=\"lang-csharp\">user_city_province.Select((user, city, province) =&gt; new\n{\n    UserId = user.Id,\n    UserName = user.Name,\n    CityName = city.Name,\n    ProvinceName = province.Name\n}).Where(a =&gt; a.UserId == 1).ToList();\n\n/*\n * 生成的 sql 只会包含 UserId、UserName、CityName、ProvinceName 四个字段\n * SELECT [Users].[Id] AS [UserId],[Users].[Name] AS [UserName],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] \n   FROM [Users] AS [Users] \n   INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n   WHERE [Users].[Id] = 1\n */\n</code></pre>\n<p>框架亦支持左连接，用法和内连接相同。</p>\n', '# 连接查询\nChloe 友好支持多表连接查询，一切都可以用 lambda 表达式操作，返回类型可以是自定义类型，也可以是匿名类型。强类型开发，编译可见错误，容错率高。\n**1.创建相关的 IQuery 对象：**\n```csharp\nIQuery<User> users = context.Query<User>();\nIQuery<City> cities = context.Query<City>();\nIQuery<Province> provinces = context.Query<Province>();\n```\n**2.建立连接：**\n```csharp\n/* User 表和 City 表 inner join，得到 IJoiningQuery<User, City> 对象 */\nIJoiningQuery<User, City> user_city = users.InnerJoin(cities, (user, city) => user.CityId == city.Id);\n\n/* City 表和 Province 表 inner join，得到 IJoiningQuery<User, City, Province> 对象 */\nIJoiningQuery<User, City, Province> user_city_province = user_city.InnerJoin(provinces, (user, city, province) => city.ProvinceId == province.Id);\n```\n**3.得到最终的 IJoiningQuery 对象，就可以 Select 所需要的数据返回一个 IQuery 对象，然后就可以进行 Where、OrderBy、GroupBy、分页、聚合查询等操作：**\n查出一个用户及其隶属的城市和省份的所有信息：\n```csharp\n/* 调用 Select 方法返回一个泛型为包含 User、City、Province 匿名类型的 IQuery 对象。\n * Select 方法也可以返回自定义类型 。\n */\nvar qq = user_city_province.Select((user, city, province) => new\n{\n    User = user,\n    City = city,\n    Province = province\n});\n\n/* 根据条件筛选，然后调用 ToList 就会返回一个泛型为 new { User = user, City = city, Province = province } 的 List 集合 */\nvar result = qq.Where(a => a.User.Id == 1).ToList();\n\n/*\n * 生成的 sql：\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[City].[Id] AS [Id0],[City].[Name] AS [Name0],[City].[ProvinceId] AS [ProvinceId],[Province].[Id] AS [Id1],[Province].[Name] AS [Name1] \n   FROM [Users] AS [Users] \n   INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n   WHERE [Users].[Id] = 1\n */\n```\n可以只获取指定的字段信息：\n```csharp\nuser_city_province.Select((user, city, province) => new\n{\n    UserId = user.Id,\n    UserName = user.Name,\n    CityName = city.Name,\n    ProvinceName = province.Name\n}).Where(a => a.UserId == 1).ToList();\n\n/*\n * 生成的 sql 只会包含 UserId、UserName、CityName、ProvinceName 四个字段\n * SELECT [Users].[Id] AS [UserId],[Users].[Name] AS [UserName],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] \n   FROM [Users] AS [Users] \n   INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n   WHERE [Users].[Id] = 1\n */\n```\n框架亦支持左连接，用法和内连接相同。', '2016-12-02 16:21:29', '2016-12-03 15:07:59', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155712383844352', 'SQLite-分组查询', 'SQLite-分组查询', 'SQLite-分组查询', '<h1 id=\"h1-u5206u7EC4u67E5u8BE2\"><a name=\"分组查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分组查询</h1><p>Chloe 支持分组查询以及分组后 Having 过滤和聚合查询。</p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nIGroupingQuery&lt;User&gt; g = q.Where(a =&gt; a.Id &gt; 0).GroupBy(a =&gt; a.Age);\ng = g.Having(a =&gt; a.Age &gt; 1 &amp;&amp; AggregateFunctions.Count() &gt; 0);\n\ng.Select(a =&gt; new\n{\n    a.Age,\n    Count = AggregateFunctions.Count(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Avg = AggregateFunctions.Average(a.Age)\n}).ToList();\n/*\n * SELECT [Users].[Age] AS [Age],COUNT(1) AS [Count],CAST(SUM([Users].[Age]) AS INTEGER) AS [Sum],CAST(MAX([Users].[Age]) AS INTEGER) AS [Max],CAST(MIN([Users].[Age]) AS INTEGER) AS [Min],CAST(AVG([Users].[Age]) AS REAL) AS [Avg] \n   FROM [Users] AS [Users] WHERE [Users].[Id] &gt; 0 \n   GROUP BY [Users].[Age] \n   HAVING ([Users].[Age] &gt; 1 AND COUNT(1) &gt; 0)\n */\n</code></pre>\n', '# 分组查询\nChloe 支持分组查询以及分组后 Having 过滤和聚合查询。\n```csharp\nIQuery<User> q = context.Query<User>();\n\nIGroupingQuery<User> g = q.Where(a => a.Id > 0).GroupBy(a => a.Age);\ng = g.Having(a => a.Age > 1 && AggregateFunctions.Count() > 0);\n\ng.Select(a => new\n{\n    a.Age,\n    Count = AggregateFunctions.Count(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Avg = AggregateFunctions.Average(a.Age)\n}).ToList();\n/*\n * SELECT [Users].[Age] AS [Age],COUNT(1) AS [Count],CAST(SUM([Users].[Age]) AS INTEGER) AS [Sum],CAST(MAX([Users].[Age]) AS INTEGER) AS [Max],CAST(MIN([Users].[Age]) AS INTEGER) AS [Min],CAST(AVG([Users].[Age]) AS REAL) AS [Avg] \n   FROM [Users] AS [Users] WHERE [Users].[Id] > 0 \n   GROUP BY [Users].[Age] \n   HAVING ([Users].[Age] > 1 AND COUNT(1) > 0)\n */\n```', '2016-12-02 16:21:41', '2016-12-03 15:08:44', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155763537575936', 'SQLite-聚合查询', 'SQLite-聚合查询', 'SQLite-聚合查询', '<h1 id=\"h1-u805Au5408u67E5u8BE2\"><a name=\"聚合查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>聚合查询</h1><p>Chloe 可以像写 sql 一样实现聚合查询。</p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nq.Select(a =&gt; AggregateFunctions.Count()).First();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users] LIMIT 1 OFFSET 0\n */\n\n/* 支持多个聚合函数 */\nq.Select(a =&gt; new\n{\n    Count = AggregateFunctions.Count(),\n    LongCount = AggregateFunctions.LongCount(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Average = AggregateFunctions.Average(a.Age)\n}).First();\n/*\n * SELECT COUNT(1) AS [Count],COUNT(1) AS [LongCount],CAST(SUM([Users].[Age]) AS INTEGER) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS REAL) AS [Average] \n   FROM [Users] AS [Users] \n   LIMIT 1 OFFSET 0\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar sum = q.Sum(a =&gt; a.Age);\n/*\n * SELECT CAST(SUM([Users].[Age]) AS INTEGER) AS [C] FROM [Users] AS [Users]\n */\n\nvar max = q.Max(a =&gt; a.Age);\n/*\n * SELECT MAX([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar min = q.Min(a =&gt; a.Age);\n/*\n * SELECT MIN([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar avg = q.Average(a =&gt; a.Age);\n/*\n * SELECT CAST(AVG([Users].[Age]) AS REAL) AS [C] FROM [Users] AS [Users]\n */\n</code></pre>\n', '# 聚合查询\nChloe 可以像写 sql 一样实现聚合查询。\n```csharp\nIQuery<User> q = context.Query<User>();\n\nq.Select(a => AggregateFunctions.Count()).First();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users] LIMIT 1 OFFSET 0\n */\n\n/* 支持多个聚合函数 */\nq.Select(a => new\n{\n    Count = AggregateFunctions.Count(),\n    LongCount = AggregateFunctions.LongCount(),\n    Sum = AggregateFunctions.Sum(a.Age),\n    Max = AggregateFunctions.Max(a.Age),\n    Min = AggregateFunctions.Min(a.Age),\n    Average = AggregateFunctions.Average(a.Age)\n}).First();\n/*\n * SELECT COUNT(1) AS [Count],COUNT(1) AS [LongCount],CAST(SUM([Users].[Age]) AS INTEGER) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS REAL) AS [Average] \n   FROM [Users] AS [Users] \n   LIMIT 1 OFFSET 0\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar sum = q.Sum(a => a.Age);\n/*\n * SELECT CAST(SUM([Users].[Age]) AS INTEGER) AS [C] FROM [Users] AS [Users]\n */\n\nvar max = q.Max(a => a.Age);\n/*\n * SELECT MAX([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar min = q.Min(a => a.Age);\n/*\n * SELECT MIN([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar avg = q.Average(a => a.Age);\n/*\n * SELECT CAST(AVG([Users].[Age]) AS REAL) AS [C] FROM [Users] AS [Users]\n */\n```', '2016-12-02 16:21:53', '2016-12-03 15:09:43', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155811822403584', 'SQLite-Sql查询', 'SQLite-Sql查询', 'SQLite-Sql查询', '<h1 id=\"h1-sql-\"><a name=\"Sql查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Sql查询</h1><p>对于一些极其复杂的 sql 查询，还是得依赖原生 sql，因此，Chloe 提供了原生 sql 查询接口。<br><strong>获取满足条件的用户信息，将结果映射到 User 类上：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;User&gt;(&quot;select * from Users where Age&gt;@age&quot;, new DbParam(&quot;@age&quot;, 18)).ToList();\n</code></pre>\n<p><strong>获取满足条件的用户 Id：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;int&gt;(&quot;select Id from Users where Age&gt;@age&quot;, new DbParam(&quot;@age&quot;, 18)).ToList();\n</code></pre>\n<p><strong>支持存储过程：</strong></p>\n<pre><code class=\"lang-csharp\">context.SqlQuery&lt;User&gt;(&quot;Proc_Test&quot;, CommandType.StoredProcedure, new DbParam(&quot;@age&quot;, 18)).ToList();\n</code></pre>\n', '# Sql查询\n对于一些极其复杂的 sql 查询，还是得依赖原生 sql，因此，Chloe 提供了原生 sql 查询接口。\n**获取满足条件的用户信息，将结果映射到 User 类上：**\n```csharp\ncontext.SqlQuery<User>(\"select * from Users where Age>@age\", new DbParam(\"@age\", 18)).ToList();\n```\n**获取满足条件的用户 Id：**\n```csharp\ncontext.SqlQuery<int>(\"select Id from Users where Age>@age\", new DbParam(\"@age\", 18)).ToList();\n```\n**支持存储过程：**\n```csharp\ncontext.SqlQuery<User>(\"Proc_Test\", CommandType.StoredProcedure, new DbParam(\"@age\", 18)).ToList();\n```', '2016-12-02 16:22:05', '2016-12-03 15:10:33', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155856416243712', 'SQLite-插入数据', 'SQLite-插入数据', 'SQLite-插入数据', '<h1 id=\"h1-u63D2u5165u6570u636E\"><a name=\"插入数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>插入数据</h1><p>Chloe 具备两种插入数据的方式。<br><strong>1.实体插入：</strong><br>该方式插入，如果一个实体存在自增列，会自动将自增列设置到相应的属性上。</p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Name = &quot;lu&quot;;\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = DateTime.Now;\n\n/* 会自动将自增 Id 设置到 user 的 Id 属性上 */\nuser = context.Insert(user);\n/*\n * String @P_0 = &#39;lu&#39;;\n   Gender @P_1 = Man;\n   Int32 @P_2 = 18;\n   Int32 @P_3 = 1;\n   DateTime @P_4 = &#39;2016/8/6 22:03:42&#39;;\n   INSERT INTO [Users]([Name],[Gender],[Age],[CityId],[OpTime]) \n   VALUES(@P_0,@P_1,@P_2,@P_3,@P_4);SELECT LAST_INSERT_ROWID()\n */\n</code></pre>\n<p><strong>2.lambda 方式插入：</strong><br>此种方式插入的好处是，可以指定列插入，就像写 sql 一样简单。<br>同时，该方式插入返回表主键值。如果实体主键是自增列，返回值就会是自增值。</p>\n<pre><code class=\"lang-csharp\">/* 返回主键 Id */\nint id = (int)context.Insert&lt;User&gt;(() =&gt; new User()\n{\n    Name = &quot;lu&quot;,\n    Age = 18,\n    Gender = Gender.Man,\n    CityId = 1,\n    OpTime = DateTime.Now\n});\n/*\n * INSERT INTO [Users]([Name],[Age],[Gender],[CityId],[OpTime]) \n   VALUES(&#39;lu&#39;,18,1,1,DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;));SELECT LAST_INSERT_ROWID()\n */\n</code></pre>\n', '# 插入数据\nChloe 具备两种插入数据的方式。\n**1.实体插入：**\n该方式插入，如果一个实体存在自增列，会自动将自增列设置到相应的属性上。\n```csharp\nUser user = new User();\nuser.Name = \"lu\";\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = DateTime.Now;\n\n/* 会自动将自增 Id 设置到 user 的 Id 属性上 */\nuser = context.Insert(user);\n/*\n * String @P_0 = \'lu\';\n   Gender @P_1 = Man;\n   Int32 @P_2 = 18;\n   Int32 @P_3 = 1;\n   DateTime @P_4 = \'2016/8/6 22:03:42\';\n   INSERT INTO [Users]([Name],[Gender],[Age],[CityId],[OpTime]) \n   VALUES(@P_0,@P_1,@P_2,@P_3,@P_4);SELECT LAST_INSERT_ROWID()\n */\n```\n**2.lambda 方式插入：**\n此种方式插入的好处是，可以指定列插入，就像写 sql 一样简单。\n同时，该方式插入返回表主键值。如果实体主键是自增列，返回值就会是自增值。\n```csharp\n/* 返回主键 Id */\nint id = (int)context.Insert<User>(() => new User()\n{\n    Name = \"lu\",\n    Age = 18,\n    Gender = Gender.Man,\n    CityId = 1,\n    OpTime = DateTime.Now\n});\n/*\n * INSERT INTO [Users]([Name],[Age],[Gender],[CityId],[OpTime]) \n   VALUES(\'lu\',18,1,1,DATETIME(\'NOW\',\'LOCALTIME\'));SELECT LAST_INSERT_ROWID()\n */\n```', '2016-12-02 16:22:16', '2016-12-03 15:11:56', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155899147812864', 'SQLite-更新数据', 'SQLite-更新数据', 'SQLite-更新数据', '<h1 id=\"h1-u66F4u65B0u6570u636E\"><a name=\"更新数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更新数据</h1><p>Chloe 支持两种数据更新方式。<br><strong>1.实体更新：</strong></p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Id = 1;\nuser.Name = &quot;lu&quot;;\nuser.Age = 28;\nuser.Gender = Gender.Man;\nuser.OpTime = DateTime.Now;\n\n/* 更新所有映射的字段 */\ncontext.Update(user);\n/*\n * String @P_0 = &#39;lu&#39;;\n   Gender @P_1 = Man;\n   Int32 @P_2 = 28;\n   Nullable&lt;Int32&gt; @P_3 = NULL;\n   DateTime @P_4 = &#39;2016/8/6 22:05:02&#39;;\n   Int32 @P_5 = 1;\n   UPDATE [Users] SET [Name]=@P_0,[Gender]=@P_1,[Age]=@P_2,[CityId]=@P_3,[OpTime]=@P_4 \n   WHERE [Users].[Id] = @P_5\n */\n</code></pre>\n<p>由于 user 对象未被上下文跟踪，这会使所有的映射列都会被更新。Chloe 也支持类似 EF 一样只更新被修改过的属性。</p>\n<pre><code class=\"lang-csharp\">/*\n * 支持只更新属性值已变的属性\n */\n\n/* 在修改实体属性前让上下文跟踪实体 */\ncontext.TrackEntity(user);\n\n/* 然后再修改实体属性 */\nuser.Name = user.Name + &quot;1&quot;;\n\n/* 然后调用 Update 方法，这时只会更新被修改过的属性 */\ncontext.Update(user);\n/*\n * String @P_0 = &#39;lu1&#39;;\n   Int32 @P_1 = 1;\n   UPDATE [Users] SET [Name]=@P_0 WHERE [Users].[Id] = @P_1\n */\n</code></pre>\n<p><strong>2.lambda 方式更新：</strong><br>该方式解决的问题是：1.指定列更新；2.批量更新；3.支持类似 Age=Age + 100 这样更新字段。用法如下：</p>\n<pre><code class=\"lang-csharp\">context.Update&lt;User&gt;(a =&gt; a.Age &gt; 18, a =&gt; new User()\n{\n    Name = a.Name,\n    Age = a.Age + 100,\n    Gender = Gender.Man,\n    OpTime = DateTime.Now\n});\n/*\n * UPDATE [Users] SET [Name]=[Users].[Name],[Age]=([Users].[Age] + 100),[Gender]=1,[OpTime]=DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;) \n   WHERE [Users].[Id] &gt; 18\n */\n</code></pre>\n', '# 更新数据\nChloe 支持两种数据更新方式。\n**1.实体更新：**\n```csharp\nUser user = new User();\nuser.Id = 1;\nuser.Name = \"lu\";\nuser.Age = 28;\nuser.Gender = Gender.Man;\nuser.OpTime = DateTime.Now;\n\n/* 更新所有映射的字段 */\ncontext.Update(user);\n/*\n * String @P_0 = \'lu\';\n   Gender @P_1 = Man;\n   Int32 @P_2 = 28;\n   Nullable<Int32> @P_3 = NULL;\n   DateTime @P_4 = \'2016/8/6 22:05:02\';\n   Int32 @P_5 = 1;\n   UPDATE [Users] SET [Name]=@P_0,[Gender]=@P_1,[Age]=@P_2,[CityId]=@P_3,[OpTime]=@P_4 \n   WHERE [Users].[Id] = @P_5\n */\n```\n由于 user 对象未被上下文跟踪，这会使所有的映射列都会被更新。Chloe 也支持类似 EF 一样只更新被修改过的属性。\n```csharp\n/*\n * 支持只更新属性值已变的属性\n */\n\n/* 在修改实体属性前让上下文跟踪实体 */\ncontext.TrackEntity(user);\n\n/* 然后再修改实体属性 */\nuser.Name = user.Name + \"1\";\n\n/* 然后调用 Update 方法，这时只会更新被修改过的属性 */\ncontext.Update(user);\n/*\n * String @P_0 = \'lu1\';\n   Int32 @P_1 = 1;\n   UPDATE [Users] SET [Name]=@P_0 WHERE [Users].[Id] = @P_1\n */\n```\n**2.lambda 方式更新：**\n该方式解决的问题是：1.指定列更新；2.批量更新；3.支持类似 Age=Age + 100 这样更新字段。用法如下：\n```csharp\ncontext.Update<User>(a => a.Age > 18, a => new User()\n{\n    Name = a.Name,\n    Age = a.Age + 100,\n    Gender = Gender.Man,\n    OpTime = DateTime.Now\n});\n/*\n * UPDATE [Users] SET [Name]=[Users].[Name],[Age]=([Users].[Age] + 100),[Gender]=1,[OpTime]=DATETIME(\'NOW\',\'LOCALTIME\') \n   WHERE [Users].[Id] > 18\n */\n```', '2016-12-02 16:22:26', '2016-12-03 15:13:37', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155947889819648', 'SQLite-删除数据', 'SQLite-删除数据', 'SQLite-删除数据', '<h1 id=\"h1-u5220u9664u6570u636E\"><a name=\"删除数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除数据</h1><p>Chloe 支持两种数据删除方式。<br><strong>1.实体删除：</strong><br>该方式删除必须要求实体拥有一个主键，否则会报异常提示。</p>\n<pre><code class=\"lang-csharp\">User user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 @P_0 = 1;\n   DELETE FROM [Users] WHERE [Users].[Id] = @P_0\n */\n</code></pre>\n<p><strong>2.lambda 方式删除：</strong><br>使用该方式可以删除单条数据，也可以删除多条数据。</p>\n<pre><code class=\"lang-csharp\">/* 删除单条数据 */\ncontext.Delete&lt;User&gt;(a =&gt; a.Id == 1);\n/*\n * DELETE FROM [Users] WHERE [Users].[Id] = 1\n */\n\n/* 批量删除满足条件的数据 */\ncontext.Delete&lt;User&gt;(a =&gt; a.Age &gt; 18);\n/*\n * DELETE FROM [Users] WHERE [Users].[Age] &gt; 18\n */\n</code></pre>\n', '# 删除数据\nChloe 支持两种数据删除方式。\n**1.实体删除：**\n该方式删除必须要求实体拥有一个主键，否则会报异常提示。\n```csharp\nUser user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 @P_0 = 1;\n   DELETE FROM [Users] WHERE [Users].[Id] = @P_0\n */\n```\n**2.lambda 方式删除：**\n使用该方式可以删除单条数据，也可以删除多条数据。\n```csharp\n/* 删除单条数据 */\ncontext.Delete<User>(a => a.Id == 1);\n/*\n * DELETE FROM [Users] WHERE [Users].[Id] = 1\n */\n\n/* 批量删除满足条件的数据 */\ncontext.Delete<User>(a => a.Age > 18);\n/*\n * DELETE FROM [Users] WHERE [Users].[Age] > 18\n */\n```', '2016-12-02 16:22:37', '2016-12-03 15:15:01', '0', null);
INSERT INTO `wikidocument` VALUES ('3325155999823691776', 'SQLite-存储过程', 'SQLite-存储过程', 'SQLite-存储过程', '<p>SQLite 不支持存储过程。</p>\n', 'SQLite 不支持存储过程。', '2016-12-02 16:22:50', '2016-12-03 15:16:06', '0', null);
INSERT INTO `wikidocument` VALUES ('3325156054349643776', 'SQLite-事务', 'SQLite-事务', 'SQLite-事务', '<h1 id=\"h1-u4E8Bu52A1u652Fu6301\"><a name=\"事务支持\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>事务支持</h1><p><strong>基本用法：</strong></p>\n<pre><code class=\"lang-csharp\">string connString = &quot;Your connection string&quot;;\nusing (SQLiteContext context = new SQLiteContext(new SQLiteConnectionFactory(connString)))\n{\n    try\n    {\n        context.Session.BeginTransaction();\n\n        /* do some things here */\n        context.Update(user);\n        context.Delete&lt;User&gt;(a =&gt; a.Gender == null);\n\n        context.Session.CommitTransaction();\n    }\n    catch\n    {\n        if (context.Session.IsInTransaction)\n            context.Session.RollbackTransaction();\n        throw;\n    }\n}\n</code></pre>\n', '# 事务支持\n**基本用法：**\n```csharp\nstring connString = \"Your connection string\";\nusing (SQLiteContext context = new SQLiteContext(new SQLiteConnectionFactory(connString)))\n{\n    try\n    {\n        context.Session.BeginTransaction();\n\n        /* do some things here */\n        context.Update(user);\n        context.Delete<User>(a => a.Gender == null);\n\n        context.Session.CommitTransaction();\n    }\n    catch\n    {\n        if (context.Session.IsInTransaction)\n            context.Session.RollbackTransaction();\n        throw;\n    }\n}\n```', '2016-12-02 16:23:03', '2016-12-03 15:15:43', '0', null);
INSERT INTO `wikidocument` VALUES ('3325156110087749632', 'SQLite-常用函数', 'SQLite-常用函数', 'SQLite-常用函数', '<h1 id=\"h1-u5E38u7528u51FDu6570\"><a name=\"常用函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>常用函数</h1><p><strong>Chloe 对很多数据库函数支持很丰富，具体用法如下：</strong></p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n\nvar space = new char[] { &#39; &#39; };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = DateTime.Now.AddDays(1);\n\nvar ret = q.Select(a =&gt; new\n{\n    Id = a.Id,\n\n    String_Length = (int?)a.Name.Length,//LENGTH([Users].[Name])\n    Substring = a.Name.Substring(0),//SUBSTR([Users].[Name],0 + 1)\n    Substring1 = a.Name.Substring(1),//SUBSTR([Users].[Name],1 + 1)\n    Substring1_2 = a.Name.Substring(1, 2),//SUBSTR([Users].[Name],1 + 1,2)\n    ToLower = a.Name.ToLower(),//LOWER([Users].[Name])\n    ToUpper = a.Name.ToUpper(),//UPPER([Users].[Name])\n    IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//CASE WHEN ([Users].[Name] IS NULL OR [Users].[Name] = &#39;&#39;) THEN 1 ELSE 0 END = 1\n    Contains = (bool?)a.Name.Contains(&quot;s&quot;),//[Users].[Name] LIKE &#39;%&#39; || &#39;s&#39; || &#39;%&#39;\n    StartsWith = (bool?)a.Name.StartsWith(&quot;s&quot;),//[Users].[Name] LIKE &#39;s&#39; || &#39;%&#39;\n    EndsWith = (bool?)a.Name.EndsWith(&quot;s&quot;),//[Users].[Name] LIKE &#39;%&#39; || &#39;s&#39;\n    Trim = a.Name.Trim(),//TRIM([Users].[Name])\n    TrimStart = a.Name.TrimStart(space),//LTRIM([Users].[Name])\n    TrimEnd = a.Name.TrimEnd(space),//RTRIM([Users].[Name])\n\n    DiffYears = DbFunctions.DiffYears(startTime, endTime),//(CAST(STRFTIME(&#39;%Y&#39;,@P_0) AS INTEGER) - CAST(STRFTIME(&#39;%Y&#39;,@P_1) AS INTEGER))\n    DiffMonths = DbFunctions.DiffMonths(startTime, endTime),//((CAST(STRFTIME(&#39;%Y&#39;,@P_0) AS INTEGER) - CAST(STRFTIME(&#39;%Y&#39;,@P_1) AS INTEGER)) * 12 + (CAST(STRFTIME(&#39;%m&#39;,@P_0) AS INTEGER) - CAST(STRFTIME(&#39;%m&#39;,@P_1) AS INTEGER)))\n    DiffDays = DbFunctions.DiffDays(startTime, endTime),//CAST((JULIANDAY(@P_0) - JULIANDAY(@P_1)) AS INTEGER)\n    DiffHours = DbFunctions.DiffHours(startTime, endTime),//CAST((JULIANDAY(@P_0) - JULIANDAY(@P_1)) * 24 AS INTEGER)\n    DiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//CAST((JULIANDAY(@P_0) - JULIANDAY(@P_1)) * 1440 AS INTEGER)\n    DiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//CAST((JULIANDAY(@P_0) - JULIANDAY(@P_1)) * 86400 AS INTEGER)\n    //DiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//不支持 Millisecond\n    //DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//不支持 Microseconds\n\n    AddYears = startTime.AddYears(1),//DATETIME(@P_0,&#39;+&#39; || 1 || &#39; years&#39;)\n    AddMonths = startTime.AddMonths(1),//DATETIME(@P_0,&#39;+&#39; || 1 || &#39; months&#39;)\n    AddDays = startTime.AddDays(1),//DATETIME(@P_0,&#39;+&#39; || 1 || &#39; days&#39;)\n    AddHours = startTime.AddHours(1),//DATETIME(@P_0,&#39;+&#39; || 1 || &#39; hours&#39;)\n    AddMinutes = startTime.AddMinutes(2),//DATETIME(@P_0,&#39;+&#39; || 2 || &#39; minutes&#39;)\n    AddSeconds = startTime.AddSeconds(120),//DATETIME(@P_0,&#39;+&#39; || 120 || &#39; seconds&#39;)\n    //AddMilliseconds = startTime.AddMilliseconds(2000),//不支持\n\n    Now = DateTime.Now,//DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;)\n    UtcNow = DateTime.UtcNow,//DATETIME()\n    Today = DateTime.Today,//DATE(&#39;NOW&#39;,&#39;LOCALTIME&#39;)\n    Date = DateTime.Now.Date,//DATE(&#39;NOW&#39;,&#39;LOCALTIME&#39;)\n    Year = DateTime.Now.Year,//CAST(STRFTIME(&#39;%Y&#39;,DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;)) AS INTEGER)\n    Month = DateTime.Now.Month,//CAST(STRFTIME(&#39;%m&#39;,DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;)) AS INTEGER)\n    Day = DateTime.Now.Day,//CAST(STRFTIME(&#39;%d&#39;,DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;)) AS INTEGER)\n    Hour = DateTime.Now.Hour,//CAST(STRFTIME(&#39;%H&#39;,DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;)) AS INTEGER)\n    Minute = DateTime.Now.Minute,//CAST(STRFTIME(&#39;%M&#39;,DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;)) AS INTEGER)\n    Second = DateTime.Now.Second,//CAST(STRFTIME(&#39;%S&#39;,DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;)) AS INTEGER)\n    Millisecond = DateTime.Now.Millisecond,//@P_2 直接计算 DateTime.Now.Millisecond 的值 \n    DayOfWeek = DateTime.Now.DayOfWeek,//CAST(STRFTIME(&#39;%w&#39;,DATETIME(&#39;NOW&#39;,&#39;LOCALTIME&#39;)) AS INTEGER)\n\n    Byte_Parse = byte.Parse(&quot;1&quot;),//CAST(&#39;1&#39; AS INTEGER)\n    Int_Parse = int.Parse(&quot;1&quot;),//CAST(&#39;1&#39; AS INTEGER)\n    Int16_Parse = Int16.Parse(&quot;11&quot;),//CAST(&#39;11&#39; AS INTEGER)\n    Long_Parse = long.Parse(&quot;2&quot;),//CAST(&#39;2&#39; AS INTEGER)\n    Double_Parse = double.Parse(&quot;3.1&quot;),//CAST(&#39;3.1&#39; AS REAL)\n    Float_Parse = float.Parse(&quot;4.1&quot;),//CAST(&#39;4.1&#39; AS REAL)\n    //Decimal_Parse = decimal.Parse(&quot;5&quot;),//不支持\n    //Guid_Parse = Guid.Parse(&quot;D544BC4C-739E-4CD3-A3D3-7BF803FCE179&quot;),//不支持 &#39;D544BC4C-739E-4CD3-A3D3-7BF803FCE179&#39;\n\n    Bool_Parse = bool.Parse(&quot;1&quot;),//CAST(&#39;1&#39; AS INTEGER)\n    DateTime_Parse = DateTime.Parse(&quot;2014-01-01&quot;),//DATETIME(&#39;2014-01-01&#39;)\n}).ToList();\n</code></pre>\n<p>上述的函数可以用于 Select 方法，亦可用在 Where 或其它方法的 lambda 表达式树中，最终都会翻译成数据库函数。</p>\n', '# 常用函数\n**Chloe 对很多数据库函数支持很丰富，具体用法如下：**\n```csharp\nIQuery<User> q = context.Query<User>();\n\nvar space = new char[] { \' \' };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = DateTime.Now.AddDays(1);\n\nvar ret = q.Select(a => new\n{\n    Id = a.Id,\n\n    String_Length = (int?)a.Name.Length,//LENGTH([Users].[Name])\n    Substring = a.Name.Substring(0),//SUBSTR([Users].[Name],0 + 1)\n    Substring1 = a.Name.Substring(1),//SUBSTR([Users].[Name],1 + 1)\n    Substring1_2 = a.Name.Substring(1, 2),//SUBSTR([Users].[Name],1 + 1,2)\n    ToLower = a.Name.ToLower(),//LOWER([Users].[Name])\n    ToUpper = a.Name.ToUpper(),//UPPER([Users].[Name])\n    IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//CASE WHEN ([Users].[Name] IS NULL OR [Users].[Name] = \'\') THEN 1 ELSE 0 END = 1\n    Contains = (bool?)a.Name.Contains(\"s\"),//[Users].[Name] LIKE \'%\' || \'s\' || \'%\'\n    StartsWith = (bool?)a.Name.StartsWith(\"s\"),//[Users].[Name] LIKE \'s\' || \'%\'\n    EndsWith = (bool?)a.Name.EndsWith(\"s\"),//[Users].[Name] LIKE \'%\' || \'s\'\n    Trim = a.Name.Trim(),//TRIM([Users].[Name])\n    TrimStart = a.Name.TrimStart(space),//LTRIM([Users].[Name])\n    TrimEnd = a.Name.TrimEnd(space),//RTRIM([Users].[Name])\n\n    DiffYears = DbFunctions.DiffYears(startTime, endTime),//(CAST(STRFTIME(\'%Y\',@P_0) AS INTEGER) - CAST(STRFTIME(\'%Y\',@P_1) AS INTEGER))\n    DiffMonths = DbFunctions.DiffMonths(startTime, endTime),//((CAST(STRFTIME(\'%Y\',@P_0) AS INTEGER) - CAST(STRFTIME(\'%Y\',@P_1) AS INTEGER)) * 12 + (CAST(STRFTIME(\'%m\',@P_0) AS INTEGER) - CAST(STRFTIME(\'%m\',@P_1) AS INTEGER)))\n    DiffDays = DbFunctions.DiffDays(startTime, endTime),//CAST((JULIANDAY(@P_0) - JULIANDAY(@P_1)) AS INTEGER)\n    DiffHours = DbFunctions.DiffHours(startTime, endTime),//CAST((JULIANDAY(@P_0) - JULIANDAY(@P_1)) * 24 AS INTEGER)\n    DiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//CAST((JULIANDAY(@P_0) - JULIANDAY(@P_1)) * 1440 AS INTEGER)\n    DiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//CAST((JULIANDAY(@P_0) - JULIANDAY(@P_1)) * 86400 AS INTEGER)\n    //DiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//不支持 Millisecond\n    //DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//不支持 Microseconds\n\n    AddYears = startTime.AddYears(1),//DATETIME(@P_0,\'+\' || 1 || \' years\')\n    AddMonths = startTime.AddMonths(1),//DATETIME(@P_0,\'+\' || 1 || \' months\')\n    AddDays = startTime.AddDays(1),//DATETIME(@P_0,\'+\' || 1 || \' days\')\n    AddHours = startTime.AddHours(1),//DATETIME(@P_0,\'+\' || 1 || \' hours\')\n    AddMinutes = startTime.AddMinutes(2),//DATETIME(@P_0,\'+\' || 2 || \' minutes\')\n    AddSeconds = startTime.AddSeconds(120),//DATETIME(@P_0,\'+\' || 120 || \' seconds\')\n    //AddMilliseconds = startTime.AddMilliseconds(2000),//不支持\n\n    Now = DateTime.Now,//DATETIME(\'NOW\',\'LOCALTIME\')\n    UtcNow = DateTime.UtcNow,//DATETIME()\n    Today = DateTime.Today,//DATE(\'NOW\',\'LOCALTIME\')\n    Date = DateTime.Now.Date,//DATE(\'NOW\',\'LOCALTIME\')\n    Year = DateTime.Now.Year,//CAST(STRFTIME(\'%Y\',DATETIME(\'NOW\',\'LOCALTIME\')) AS INTEGER)\n    Month = DateTime.Now.Month,//CAST(STRFTIME(\'%m\',DATETIME(\'NOW\',\'LOCALTIME\')) AS INTEGER)\n    Day = DateTime.Now.Day,//CAST(STRFTIME(\'%d\',DATETIME(\'NOW\',\'LOCALTIME\')) AS INTEGER)\n    Hour = DateTime.Now.Hour,//CAST(STRFTIME(\'%H\',DATETIME(\'NOW\',\'LOCALTIME\')) AS INTEGER)\n    Minute = DateTime.Now.Minute,//CAST(STRFTIME(\'%M\',DATETIME(\'NOW\',\'LOCALTIME\')) AS INTEGER)\n    Second = DateTime.Now.Second,//CAST(STRFTIME(\'%S\',DATETIME(\'NOW\',\'LOCALTIME\')) AS INTEGER)\n    Millisecond = DateTime.Now.Millisecond,//@P_2 直接计算 DateTime.Now.Millisecond 的值 \n    DayOfWeek = DateTime.Now.DayOfWeek,//CAST(STRFTIME(\'%w\',DATETIME(\'NOW\',\'LOCALTIME\')) AS INTEGER)\n\n    Byte_Parse = byte.Parse(\"1\"),//CAST(\'1\' AS INTEGER)\n    Int_Parse = int.Parse(\"1\"),//CAST(\'1\' AS INTEGER)\n    Int16_Parse = Int16.Parse(\"11\"),//CAST(\'11\' AS INTEGER)\n    Long_Parse = long.Parse(\"2\"),//CAST(\'2\' AS INTEGER)\n    Double_Parse = double.Parse(\"3.1\"),//CAST(\'3.1\' AS REAL)\n    Float_Parse = float.Parse(\"4.1\"),//CAST(\'4.1\' AS REAL)\n    //Decimal_Parse = decimal.Parse(\"5\"),//不支持\n    //Guid_Parse = Guid.Parse(\"D544BC4C-739E-4CD3-A3D3-7BF803FCE179\"),//不支持 \'D544BC4C-739E-4CD3-A3D3-7BF803FCE179\'\n\n    Bool_Parse = bool.Parse(\"1\"),//CAST(\'1\' AS INTEGER)\n    DateTime_Parse = DateTime.Parse(\"2014-01-01\"),//DATETIME(\'2014-01-01\')\n}).ToList();\n```\n上述的函数可以用于 Select 方法，亦可用在 Where 或其它方法的 lambda 表达式树中，最终都会翻译成数据库函数。', '2016-12-02 16:23:16', '2016-12-03 15:16:51', '0', null);
INSERT INTO `wikidocument` VALUES ('3325175022200291328', 'Chloe.ORM-更新记录', 'Chloe.ORM-更新记录', 'Chloe.ORM-更新记录', '<ul>\n<li><strong>2016-12-10</strong><ul>\n<li>修改内容：如果一个继承属性出现在IQuery.Select 方法的lambda中，会出现空引用异常，现已修复</li><li>版本更新至 2.1.2</li></ul>\n</li><li><strong>2016-12-7</strong><ul>\n<li>修改内容：InternalDbSession 中的 IDbCommand 是单例可重用的，所以，每次调用 PrepareCommand 方法时需要清掉上次执行的残留参数，即执行 cmd.Parameters.Clear()（主要防止以下“特俗”情况：当执行 sql 过程出现异常，会来不及调用 cmd.Parameters.Clear()，就会出现残留的参数，为了保证每次使用 IDbCommand 不受上次异常情况下的影响，所以得清除一下上次残留的参数）</li><li>版本更新至 2.1.1</li></ul>\n</li><li><p><strong>2016-12-4</strong></p>\n<ul>\n<li>支持 Oracle 数据库</li><li>实体支持继承</li><li>支持存储过程</li><li>重命名：NotAutoIncrementAttribute —&gt; NonAutoIncrementAttribute</li><li>废弃 DbContext.CurrentSession 属性，取而代之 DbContext.Session</li><li>IQuery 接口增加 TakePage 方法</li><li>内部代码结构调整</li><li>版本升级至 2.1.0</li></ul>\n</li><li><p><strong>2016-8-26</strong></p>\n<ul>\n<li>版本升级至 2.0.0</li><li>发布 ChloeCore.MySql NuGet 包</li></ul>\n</li><li><p><strong>2016-8-8</strong></p>\n<ul>\n<li>支持 SQLite 数据库</li><li>.NET Ver update: 1.0.2</li><li>.NET Core Ver update: 1.0.4</li></ul>\n</li><li><p><strong>2016-8-1</strong></p>\n<ul>\n<li>支持 .NET Core</li><li>发行 NuGet 包<ul>\n<li>.NET Ver: 1.0.1</li><li>.NET Core Ver: 1.0.3</li></ul>\n</li></ul>\n</li><li><p><strong>2016-7-25</strong></p>\n<ul>\n<li>支持 MySql 数据库</li></ul>\n</li><li><p><strong>2016-7-4</strong></p>\n<ul>\n<li>正式开源</li></ul>\n</li></ul>\n', '* **2016-12-10**\n	* 修改内容：如果一个继承属性出现在IQuery.Select 方法的lambda中，会出现空引用异常，现已修复\n	* 版本更新至 2.1.2\n* **2016-12-7**\n	* 修改内容：InternalDbSession 中的 IDbCommand 是单例可重用的，所以，每次调用 PrepareCommand 方法时需要清掉上次执行的残留参数，即执行 cmd.Parameters.Clear()（主要防止以下“特俗”情况：当执行 sql 过程出现异常，会来不及调用 cmd.Parameters.Clear()，就会出现残留的参数，为了保证每次使用 IDbCommand 不受上次异常情况下的影响，所以得清除一下上次残留的参数）\n	* 版本更新至 2.1.1\n* **2016-12-4**\n	* 支持 Oracle 数据库\n	* 实体支持继承\n	* 支持存储过程\n	* 重命名：NotAutoIncrementAttribute --> NonAutoIncrementAttribute\n	* 废弃 DbContext.CurrentSession 属性，取而代之 DbContext.Session\n	* IQuery 接口增加 TakePage 方法\n	* 内部代码结构调整\n	* 版本升级至 2.1.0\n\n* **2016-8-26**\n	* 版本升级至 2.0.0\n	* 发布 ChloeCore.MySql NuGet 包\n\n* **2016-8-8**\n	* 支持 SQLite 数据库\n	* .NET Ver update: 1.0.2\n	* .NET Core Ver update: 1.0.4\n\n* **2016-8-1**\n	* 支持 .NET Core\n    * 发行 NuGet 包\n      * .NET Ver: 1.0.1\n      * .NET Core Ver: 1.0.3\n\n* **2016-7-25**\n    * 支持 MySql 数据库\n\n* **2016-7-4**\n	* 正式开源\n', '2016-12-02 17:38:25', '2016-12-10 10:56:21', '0', null);
INSERT INTO `wikidocument` VALUES ('3325507078541279232', '使用进阶-复杂查询', '使用进阶-复杂查询', '使用进阶-复杂查询', '<h1 id=\"h1-u590Du6742u67E5u8BE2\"><a name=\"复杂查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>复杂查询</h1><p>IQuery&lt;T&gt; 接口支持多表连接查询、聚合查询、分组查询，这几个接口配合使用可以让我们开发达到事半功倍的效果。对于一般的复杂查询，Chloe 还是游刃有余的。<br><strong>example 1：</strong><br>达到一般的 in 子查询效果，比如如下 sql：</p>\n<pre><code class=\"lang-csharp\">string sql = &quot;select Users.* from Users where Users.Id in(select id from City where City.Name LIKE &#39;%&#39; + N&#39;北京&#39; + &#39;%&#39;)&quot;;\n</code></pre>\n<p>Chloe 无需拼接字符串就可以做到：</p>\n<pre><code class=\"lang-csharp\">var userQuery = context.Query&lt;User&gt;();\n\nvar cityIdsQuery = context.Query&lt;City&gt;().Where(a =&gt; a.Name.Contains(&quot;北京&quot;)).Select(a =&gt; a.Id);\n\n/* 建立连接 */\nvar view = userQuery.InnerJoin(cityIdsQuery, (user, cityId) =&gt; user.CityId == cityId).Select((user, cityId) =&gt; user);\n\n/* 执行查询 */\nList&lt;User&gt; userList = view.ToList();\n\n/*\n * 生成的 sql：\n * SELECT [Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[Users].[Id] AS [Id],[Users].[Name] AS [Name] \n   FROM [Users] AS [Users] \n   INNER JOIN \n   (SELECT [City].[Id] AS [C] FROM [City] AS [City] WHERE [City].[Name] LIKE &#39;%&#39; + N&#39;北京&#39; + &#39;%&#39;) AS [T] \n   ON [Users].[CityId] = [T].[C]\n */\n</code></pre>\n<p><strong>example 2：连接、分组、聚合查询结合</strong><br>现有 Users 表、City 表，他们的关系是一个 User 隶属一个 City，一个 City 有多个用户。假设，现在有需求要查出 City 的信息，<strong>同时也要把该 City 下用户最小的年龄输出</strong>，如果用原生 sql 写的话大概是：</p>\n<pre><code class=\"lang-sql\">select City.*,T.MinAge from City left join (select CityId,Min(Users.Age) as MinAge \nfrom Users group by Users.CityId) as T on City.Id=T.CityId\n</code></pre>\n<p>这类的查询 Chloe 也完全可以做到：</p>\n<pre><code class=\"lang-csharp\">IQuery&lt;User&gt; users = context.Query&lt;User&gt;();\nIQuery&lt;City&gt; cities = context.Query&lt;City&gt;();\nvar gq = users.GroupBy(a =&gt; a.CityId).Select(a =&gt; new { a.CityId, MinAge = DbFunctions.Min(a.Age) });\n\ncities.LeftJoin(gq, (city, g) =&gt; city.Id == g.CityId).Select((city, g) =&gt; new { City = city, MinAge = g.MinAge }).ToList();\n/*\n * SELECT [T].[MinAge] AS [MinAge],[City].[Id] AS [Id],[City].[Name] AS [Name],[City].[ProvinceId] AS [ProvinceId] \n   FROM [City] AS [City] \n   LEFT JOIN (SELECT [Users].[CityId] AS [CityId],MIN([Users].[Age]) AS [MinAge] \n   FROM [Users] AS [Users] GROUP BY [Users].[CityId]) AS [T] ON [City].[Id] = [T].[CityId]\n */\n</code></pre>\n', '# 复杂查询\nIQuery<T> 接口支持多表连接查询、聚合查询、分组查询，这几个接口配合使用可以让我们开发达到事半功倍的效果。对于一般的复杂查询，Chloe 还是游刃有余的。\n**example 1：**\n达到一般的 in 子查询效果，比如如下 sql：\n```csharp\nstring sql = \"select Users.* from Users where Users.Id in(select id from City where City.Name LIKE \'%\' + N\'北京\' + \'%\')\";\n```\nChloe 无需拼接字符串就可以做到：\n```csharp\nvar userQuery = context.Query<User>();\n\nvar cityIdsQuery = context.Query<City>().Where(a => a.Name.Contains(\"北京\")).Select(a => a.Id);\n\n/* 建立连接 */\nvar view = userQuery.InnerJoin(cityIdsQuery, (user, cityId) => user.CityId == cityId).Select((user, cityId) => user);\n\n/* 执行查询 */\nList<User> userList = view.ToList();\n\n/*\n * 生成的 sql：\n * SELECT [Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[Users].[Id] AS [Id],[Users].[Name] AS [Name] \n   FROM [Users] AS [Users] \n   INNER JOIN \n   (SELECT [City].[Id] AS [C] FROM [City] AS [City] WHERE [City].[Name] LIKE \'%\' + N\'北京\' + \'%\') AS [T] \n   ON [Users].[CityId] = [T].[C]\n */\n```\n**example 2：连接、分组、聚合查询结合**\n现有 Users 表、City 表，他们的关系是一个 User 隶属一个 City，一个 City 有多个用户。假设，现在有需求要查出 City 的信息，**同时也要把该 City 下用户最小的年龄输出**，如果用原生 sql 写的话大概是：\n```sql\nselect City.*,T.MinAge from City left join (select CityId,Min(Users.Age) as MinAge \nfrom Users group by Users.CityId) as T on City.Id=T.CityId\n```\n这类的查询 Chloe 也完全可以做到：\n```csharp\nIQuery<User> users = context.Query<User>();\nIQuery<City> cities = context.Query<City>();\nvar gq = users.GroupBy(a => a.CityId).Select(a => new { a.CityId, MinAge = DbFunctions.Min(a.Age) });\n\ncities.LeftJoin(gq, (city, g) => city.Id == g.CityId).Select((city, g) => new { City = city, MinAge = g.MinAge }).ToList();\n/*\n * SELECT [T].[MinAge] AS [MinAge],[City].[Id] AS [Id],[City].[Name] AS [Name],[City].[ProvinceId] AS [ProvinceId] \n   FROM [City] AS [City] \n   LEFT JOIN (SELECT [Users].[CityId] AS [CityId],MIN([Users].[Age]) AS [MinAge] \n   FROM [Users] AS [Users] GROUP BY [Users].[CityId]) AS [T] ON [City].[Id] = [T].[CityId]\n */\n```', '2016-12-03 15:37:53', '2016-12-04 10:52:18', '0', null);
INSERT INTO `wikidocument` VALUES ('3325512137098395648', '使用进阶-动态排序', '使用进阶-动态排序', '使用进阶-动态排序', '<h1 id=\"h1-u52A8u6001u6392u5E8F\"><a name=\"动态排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>动态排序</h1><p>在一些后台系统中，很多查询的排序字段是不定的，需要动态排序的场景不少。目前 Chloe 也支持了这功能。<br><strong>简单用法：</strong><br>这种用法针对简单的实体。</p>\n<pre><code class=\"lang-csharp\">var userQuery = context.Query&lt;User&gt;();\nuserQuery = userQuery.OrderBy(&quot;Age asc,Id desc&quot;);/* 传入字符串，多个排序以 &#39;,&#39; 分隔 */\nList&lt;User&gt; users = userQuery.ToList();\n/*\n * 生成的 sql：\n * SELECT [Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[Users].[Id] AS [Id],[Users].[Name] AS [Name] \n   FROM [Users] AS [Users] \n   ORDER BY [Users].[Age] ASC,[Users].[Id] DESC\n */\n</code></pre>\n<p><strong>高级用法：</strong><br>当查询返回的类型是复杂类型的时候可以使用这种用法。</p>\n<pre><code class=\"lang-csharp\">var userQuery = context.Query&lt;User&gt;();\nvar cityQuery = context.Query&lt;City&gt;();\n\n/* 建立连接 */\nvar user_city = userQuery.LeftJoin(cityQuery, (user, city) =&gt; user.CityId == city.Id);\n\n/* Select 返回的是一个复杂的匿名类型 */\nvar view = user_city.Select((user, city) =&gt; new { User = user, City = city });\n\n/* 传入字符串排序 */\nview = view.OrderBy(&quot;User.Age asc,User.Id desc&quot;);\nvar result = view.ToList();\n/*\n * SELECT [Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[Users].[Id] AS [Id],[Users].[Name] AS [Name],[City].[Id] AS [Id0],[City].[Name] AS [Name0],[City].[ProvinceId] AS [ProvinceId] \n   FROM [Users] AS [Users] \n   LEFT JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   ORDER BY [Users].[Age] ASC,[Users].[Id] DESC\n */\n</code></pre>\n', '# 动态排序\n在一些后台系统中，很多查询的排序字段是不定的，需要动态排序的场景不少。目前 Chloe 也支持了这功能。\n**简单用法：**\n这种用法针对简单的实体。\n```csharp\nvar userQuery = context.Query<User>();\nuserQuery = userQuery.OrderBy(\"Age asc,Id desc\");/* 传入字符串，多个排序以 \',\' 分隔 */\nList<User> users = userQuery.ToList();\n/*\n * 生成的 sql：\n * SELECT [Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[Users].[Id] AS [Id],[Users].[Name] AS [Name] \n   FROM [Users] AS [Users] \n   ORDER BY [Users].[Age] ASC,[Users].[Id] DESC\n */\n```\n**高级用法：**\n当查询返回的类型是复杂类型的时候可以使用这种用法。\n```csharp\nvar userQuery = context.Query<User>();\nvar cityQuery = context.Query<City>();\n\n/* 建立连接 */\nvar user_city = userQuery.LeftJoin(cityQuery, (user, city) => user.CityId == city.Id);\n\n/* Select 返回的是一个复杂的匿名类型 */\nvar view = user_city.Select((user, city) => new { User = user, City = city });\n\n/* 传入字符串排序 */\nview = view.OrderBy(\"User.Age asc,User.Id desc\");\nvar result = view.ToList();\n/*\n * SELECT [Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[Users].[Id] AS [Id],[Users].[Name] AS [Name],[City].[Id] AS [Id0],[City].[Name] AS [Name0],[City].[ProvinceId] AS [ProvinceId] \n   FROM [Users] AS [Users] \n   LEFT JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n   ORDER BY [Users].[Age] ASC,[Users].[Id] DESC\n */\n```', '2016-12-03 15:58:00', '2016-12-03 16:08:11', '0', null);
INSERT INTO `wikidocument` VALUES ('3325833069088210944', 'Github-Chloe-README.md', 'Github-Chloe-README.md', 'Github-Chloe-README.md', '<h1 id=\"h1-chloe\"><a name=\"Chloe\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Chloe</h1><p>Chloe is a lightweight Object/Relational Mapping(ORM) library.<br>The query interface is similar to LINQ.You can query data like LINQ and do any things(Join Query | Group Query | Aggregate Query | Insert | Batch Update | Batch Delete) by lambda with Chloe.ORM.</p>\n<p><strong>Documentation</strong>: <a href=\"http://www.52chloe.com\" title=\"http://www.52chloe.com\">http://www.52chloe.com</a><br>.NET交流群：325936847，只要您<strong>愿意</strong>，即可加入</p>\n<h1 id=\"h1-nuget-install-command\"><a name=\"NuGet Install Command\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NuGet Install Command</h1><table>\n<thead>\n<tr>\n<th></th>\n<th>.NET Framework</th>\n<th>.NET Core</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SqlServer</td>\n<td>Install-Package Chloe.SqlServer</td>\n<td>Install-Package ChloeCore.SqlServer</td>\n</tr>\n<tr>\n<td>MySql</td>\n<td>Install-Package Chloe.MySql</td>\n<td>Install-Package ChloeCore.MySql</td>\n</tr>\n<tr>\n<td>Oracle</td>\n<td>Install-Package Chloe.Oracle</td>\n<td>-</td>\n</tr>\n<tr>\n<td>SQLite</td>\n<td>Install-Package Chloe.SQLite</td>\n<td>Install-Package ChloeCore.SQLite</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"h1-usage\"><a name=\"Usage\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Usage</h1><ul>\n<li><strong>Entity</strong><br>```C#<br>public enum Gender<br>{<br>  Man = 1,<br>  Woman<br>}</li></ul>\n<p>[Table(“Users”)]<br>public class User<br>{<br>    [Column(IsPrimaryKey = true)]<br>    [AutoIncrement]<br>    public int Id { get; set; }<br>    public string Name { get; set; }<br>    public Gender? Gender { get; set; }<br>    public int? Age { get; set; }<br>    public int? CityId { get; set; }<br>    public DateTime? OpTime { get; set; }<br>}</p>\n<p>public class City<br>{<br>    [Column(IsPrimaryKey = true)]<br>    public int Id { get; set; }<br>    public string Name { get; set; }<br>    public int ProvinceId { get; set; }<br>}</p>\n<p>public class Province<br>{<br>    [Column(IsPrimaryKey = true)]<br>    public int Id { get; set; }<br>    public string Name { get; set; }<br>}</p>\n<pre><code>* **DbContext**\n```C#\nIDbContext context = new MsSqlContext(DbHelper.ConnectionString);\nIQuery&lt;User&gt; q = context.Query&lt;User&gt;();\n</code></pre><ul>\n<li><strong>Query</strong><br>```C#<br>IQuery&lt;User&gt; q = context.Query&lt;User&gt;();<br>q.Where(a =&gt; a.Id &gt; 0).FirstOrDefault();<br>q.Where(a =&gt; a.Id &gt; 0).ToList();<br>q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).ToList();<br>q.Where(a =&gt; a.Id &gt; 0).Take(999).OrderBy(a =&gt; a.Age).ToList();</li></ul>\n<p>q.Where(a =&gt; a.Id &gt; 0).OrderBy(a =&gt; a.Age).ThenByDesc(a =&gt; a.Id).Select(a =&gt; new { a.Id, a.Name }).Skip(1).Take(999).ToList();<br>/*</p>\n<ul>\n<li>SELECT TOP (999) [T].[Id] AS [Id],[T].[Name] AS [Name] FROM (SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],ROW_NUMBER() OVER(ORDER BY [Users].[Age] ASC,[Users].[Id] DESC) AS [ROW_NUMBER_0] FROM [Users] AS [Users] WHERE [Users].[Id] &gt; 0) AS [T] WHERE [T].[ROW_NUMBER_0] &gt; 1<br>*/</li></ul>\n<p>q.Where(a =&gt; a.Id &gt; 0).Where(a =&gt; a.Name.Contains(“lu”)).ToList();<br>/*</p>\n<ul>\n<li>SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] </li><li>FROM [Users] AS [Users] </li><li>WHERE ([Users].[Id] &gt; 0 AND [Users].[Name] LIKE ‘%’ + N’lu’ + ‘%’)<br>*/<br>```<ul>\n<li><strong>Join Query</strong><br>```C#<br>MsSqlContext context = new MsSqlContext(DbHelper.ConnectionString);</li></ul>\n</li></ul>\n<p>IQuery&lt;User&gt; users = context.Query&lt;User&gt;();<br>IQuery&lt;City&gt; cities = context.Query&lt;City&gt;();<br>IQuery&lt;Province&gt; provinces = context.Query&lt;Province&gt;();</p>\n<p>IJoiningQuery&lt;User, City&gt; user_city = users.InnerJoin(cities, (user, city) =&gt; user.CityId == city.Id);<br>IJoiningQuery&lt;User, City, Province&gt; user_city_province = user_city.InnerJoin(provinces, (user, city, province) =&gt; city.ProvinceId == province.Id);</p>\n<p>user_city_province.Select((user, city, province) =&gt; new { UserId = user.Id, CityName = city.Name, ProvinceName = province.Name }).Where(a =&gt; a.UserId == 1).ToList();<br>/*</p>\n<ul>\n<li>SELECT [Users].[Id] AS [UserId],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] </li><li>FROM [Users] AS [Users] </li><li>INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] </li><li>INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] </li><li>WHERE [Users].[Id] = 1<br>*/</li></ul>\n<p>var view = user_city_province.Select((user, city, province) =&gt; new { User = user, City = city, Province = province });</p>\n<p>view.Where(a =&gt; a.User.Id == 1).ToList();<br>/*</p>\n<ul>\n<li>SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[City].[Id] AS [Id0],[City].[Name] AS [Name0],[City].[ProvinceId] AS [ProvinceId],[Province].[Id] AS [Id1],[Province].[Name] AS [Name1] </li><li>FROM [Users] AS [Users] </li><li>INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] </li><li>INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] </li><li>WHERE [Users].[Id] = 1<br>*/</li></ul>\n<p>view.Where(a =&gt; a.User.Id == 1).Select(a =&gt; new { UserId = a.User.Id, CityName = a.City.Name, ProvinceName = a.Province.Name }).ToList();<br>/*</p>\n<ul>\n<li>SELECT [Users].[Id] AS [UserId],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] </li><li>FROM [Users] AS [Users] </li><li>INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] </li><li>INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] </li><li>WHERE [Users].[Id] = 1<br>*/</li></ul>\n<p>/*</p>\n<ul>\n<li>Chloe also supports left join,right join and full join query.</li><li>For details please see ‘<a href=\"https://github.com/shuxinqin/Chloe/blob/master/src/DotNet/Chloe/IQuery%60.cs\">https://github.com/shuxinqin/Chloe/blob/master/src/DotNet/Chloe/IQuery%60.cs</a>‘.<br>*/<br>```<ul>\n<li><strong>Group Query</strong><br>```C#<br>IQuery&lt;User&gt; q = context.Query&lt;User&gt;();</li></ul>\n</li></ul>\n<p>IGroupingQuery&lt;User&gt; g = q.Where(a =&gt; a.Id &gt; 0).GroupBy(a =&gt; a.Age);<br>g = g.Having(a =&gt; a.Age &gt; 1 &amp;&amp; AggregateFunctions.Count() &gt; 0);</p>\n<p>g.Select(a =&gt; new { a.Age, Count = AggregateFunctions.Count(), Sum = AggregateFunctions.Sum(a.Age), Max = AggregateFunctions.Max(a.Age), Min = AggregateFunctions.Min(a.Age), Avg = AggregateFunctions.Average(a.Age) }).ToList();<br>/*</p>\n<ul>\n<li>SELECT [Users].[Age] AS [Age],COUNT(1) AS [Count],SUM([Users].[Age]) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Avg] </li><li>FROM [Users] AS [Users] </li><li>WHERE [Users].[Id] &gt; 0 </li><li>GROUP BY [Users].[Age] HAVING ([Users].[Age] &gt; 1 AND COUNT(1) &gt; 0)<br>*/<pre><code>* **Sql Query**\n```C#\ncontext.SqlQuery&lt;User&gt;(&quot;select Id,Name,Age from Users where Name=<a href=\"https://github.com/name\" title=\"&#64;name\" class=\"at-link\">@name</a>&quot;, DbParam.Create(&quot;<a href=\"https://github.com/name\" title=\"&#64;name\" class=\"at-link\">@name</a>&quot;, &quot;lu&quot;)).ToList();\ncontext.SqlQuery&lt;int&gt;(&quot;select Id from Users&quot;).ToList();\n</code></pre><ul>\n<li><strong>Aggregate Query</strong><br>```C#<br>IQuery&lt;User&gt; q = context.Query&lt;User&gt;();</li></ul>\n</li></ul>\n<p>q.Select(a =&gt; AggregateFunctions.Count()).First();<br>/*</p>\n<ul>\n<li>SELECT TOP (1) COUNT(1) AS [C] FROM [Users] AS [Users]<br>*/</li></ul>\n<p>q.Select(a =&gt; new { Count = AggregateFunctions.Count(), LongCount = AggregateFunctions.LongCount(), Sum = AggregateFunctions.Sum(a.Age), Max = AggregateFunctions.Max(a.Age), Min = AggregateFunctions.Min(a.Age), Average = AggregateFunctions.Average(a.Age) }).First();<br>/*</p>\n<ul>\n<li>SELECT TOP (1) COUNT(1) AS [Count],COUNT_BIG(1) AS [LongCount],SUM([Users].[Age]) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Average] </li><li>FROM [Users] AS [Users]<br>*/</li></ul>\n<p>var count = q.Count();<br>/*</p>\n<ul>\n<li>SELECT COUNT(1) AS [C] FROM [Users] AS [Users]<br>*/</li></ul>\n<p>var longCount = q.LongCount();<br>/*</p>\n<ul>\n<li>SELECT COUNT_BIG(1) AS [C] FROM [Users] AS [Users]<br>*/</li></ul>\n<p>var sum = q.Sum(a =&gt; a.Age);<br>/*</p>\n<ul>\n<li>SELECT SUM([Users].[Age]) AS [C] FROM [Users] AS [Users]<br>*/</li></ul>\n<p>var max = q.Max(a =&gt; a.Age);<br>/*</p>\n<ul>\n<li>SELECT MAX([Users].[Age]) AS [C] FROM [Users] AS [Users]<br>*/</li></ul>\n<p>var min = q.Min(a =&gt; a.Age);<br>/*</p>\n<ul>\n<li>SELECT MIN([Users].[Age]) AS [C] FROM [Users] AS [Users]<br>*/</li></ul>\n<p>var avg = q.Average(a =&gt; a.Age);<br>/*</p>\n<ul>\n<li>SELECT CAST(AVG([Users].[Age]) AS FLOAT) AS [C] FROM [Users] AS [Users]<br>*/<br>```<ul>\n<li><strong>Method</strong><br>```C#<br>IQuery&lt;User&gt; q = context.Query&lt;User&gt;();</li></ul>\n</li></ul>\n<p>var space = new char[] { ‘ ‘ };</p>\n<p>DateTime startTime = DateTime.Now;<br>DateTime endTime = DateTime.Now.AddDays(1);<br>q.Select(a =&gt; new<br>{<br>    Id = a.Id,</p>\n<pre><code>String_Length = (int?)a.Name.Length,//LEN([Users].[Name])\nSubstring = a.Name.Substring(0),//SUBSTRING([Users].[Name],0 + 1,LEN([Users].[Name]))\nSubstring1 = a.Name.Substring(1),//SUBSTRING([Users].[Name],1 + 1,LEN([Users].[Name]))\nSubstring1_2 = a.Name.Substring(1, 2),//SUBSTRING([Users].[Name],1 + 1,2)\nToLower = a.Name.ToLower(),//LOWER([Users].[Name])\nToUpper = a.Name.ToUpper(),//UPPER([Users].[Name])\nIsNullOrEmpty = string.IsNullOrEmpty(a.Name),//too long\nContains = (bool?)a.Name.Contains(&quot;s&quot;),//\nTrim = a.Name.Trim(),//RTRIM(LTRIM([Users].[Name]))\nTrimStart = a.Name.TrimStart(space),//LTRIM([Users].[Name])\nTrimEnd = a.Name.TrimEnd(space),//RTRIM([Users].[Name])\nStartsWith = (bool?)a.Name.StartsWith(&quot;s&quot;),//\nEndsWith = (bool?)a.Name.EndsWith(&quot;s&quot;),//\n\nDiffYears = DbFunctions.DiffYears(startTime, endTime),//DATEDIFF(YEAR,@P_0,@P_1)\nDiffMonths = DbFunctions.DiffMonths(startTime, endTime),//DATEDIFF(MONTH,@P_0,@P_1)\nDiffDays = DbFunctions.DiffDays(startTime, endTime),//DATEDIFF(DAY,@P_0,@P_1)\nDiffHours = DbFunctions.DiffHours(startTime, endTime),//DATEDIFF(HOUR,@P_0,@P_1)\nDiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//DATEDIFF(MINUTE,@P_0,@P_1)\nDiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//DATEDIFF(SECOND,@P_0,@P_1)\nDiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//DATEDIFF(MILLISECOND,@P_0,@P_1)\n//DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//DATEDIFF(MICROSECOND,@P_0,@P_1)  Exception\n\n/* No longer support method &#39;DateTime.Subtract(DateTime d)&#39;, instead of using &#39;DbFunctions.DiffXX&#39; */\n//SubtractTotalDays = endTime.Subtract(startTime).TotalDays,//CAST(DATEDIFF(DAY,@P_0,@P_1)\n//SubtractTotalHours = endTime.Subtract(startTime).TotalHours,//CAST(DATEDIFF(HOUR,@P_0,@P_1)\n//SubtractTotalMinutes = endTime.Subtract(startTime).TotalMinutes,//CAST(DATEDIFF(MINUTE,@P_0,@P_1)\n//SubtractTotalSeconds = endTime.Subtract(startTime).TotalSeconds,//CAST(DATEDIFF(SECOND,@P_0,@P_1)\n//SubtractTotalMilliseconds = endTime.Subtract(startTime).TotalMilliseconds,//CAST(DATEDIFF(MILLISECOND,@P_0,@P_1)\n\nAddYears = startTime.AddYears(1),//DATEADD(YEAR,1,@P_0)\nAddMonths = startTime.AddMonths(1),//DATEADD(MONTH,1,@P_0)\nAddDays = startTime.AddDays(1),//DATEADD(DAY,1,@P_0)\nAddHours = startTime.AddHours(1),//DATEADD(HOUR,1,@P_0)\nAddMinutes = startTime.AddMinutes(2),//DATEADD(MINUTE,2,@P_0)\nAddSeconds = startTime.AddSeconds(120),//DATEADD(SECOND,120,@P_0)\nAddMilliseconds = startTime.AddMilliseconds(20000),//DATEADD(MILLISECOND,20000,@P_0)\n\nNow = DateTime.Now,//GETDATE()\nUtcNow = DateTime.UtcNow,//GETUTCDATE()\nToday = DateTime.Today,//CAST(GETDATE() AS DATE)\nDate = DateTime.Now.Date,//CAST(GETDATE() AS DATE)\nYear = DateTime.Now.Year,//DATEPART(YEAR,GETDATE())\nMonth = DateTime.Now.Month,//DATEPART(MONTH,GETDATE())\nDay = DateTime.Now.Day,//DATEPART(DAY,GETDATE())\nHour = DateTime.Now.Hour,//DATEPART(HOUR,GETDATE())\nMinute = DateTime.Now.Minute,//DATEPART(MINUTE,GETDATE())\nSecond = DateTime.Now.Second,//DATEPART(SECOND,GETDATE())\nMillisecond = DateTime.Now.Millisecond,//DATEPART(MILLISECOND,GETDATE())\nDayOfWeek = DateTime.Now.DayOfWeek,//(DATEPART(WEEKDAY,GETDATE()) - 1)\n\nInt_Parse = int.Parse(&quot;1&quot;),//CAST(N&#39;1&#39; AS INT)\nInt16_Parse = Int16.Parse(&quot;11&quot;),//CAST(N&#39;11&#39; AS SMALLINT)\nLong_Parse = long.Parse(&quot;2&quot;),//CAST(N&#39;2&#39; AS BIGINT)\nDouble_Parse = double.Parse(&quot;3&quot;),//CAST(N&#39;3&#39; AS FLOAT)\nFloat_Parse = float.Parse(&quot;4&quot;),//CAST(N&#39;4&#39; AS REAL)\n//Decimal_Parse = decimal.Parse(&quot;5&quot;),//CAST(N&#39;5&#39; AS DECIMAL)  ps: &#39;Decimal.Parse(string s)&#39; is not supported now,because we don&#39;t know the precision and scale information.\nGuid_Parse = Guid.Parse(&quot;D544BC4C-739E-4CD3-A3D3-7BF803FCE179&quot;),//CAST(N&#39;D544BC4C-739E-4CD3-A3D3-7BF803FCE179&#39; AS UNIQUEIDENTIFIER) AS [Guid_Parse]\n\nBool_Parse = bool.Parse(&quot;1&quot;),//CASE WHEN CAST(N&#39;1&#39; AS BIT) = CAST(1 AS BIT) THEN CAST(1 AS BIT) WHEN NOT (CAST(N&#39;1&#39; AS BIT) = CAST(1 AS BIT)) THEN CAST(0 AS BIT) ELSE NULL END AS [Bool_Parse]\nDateTime_Parse = DateTime.Parse(&quot;1992-1-16&quot;),//CAST(N&#39;1992-1-16&#39; AS DATETIME) AS [DateTime_Parse]\n\nB = a.Age == null ? false : a.Age &gt; 1,\n</code></pre><p>}).ToList();</p>\n<pre><code>* **Insert**\n```C#\nIDbContext context = new MsSqlContext(DbHelper.ConnectionString);\n\n//return the key value\nint id = (int)context.Insert&lt;User&gt;(() =&gt; new User() { Name = &quot;lu&quot;, Age = 18, Gender = Gender.Man, CityId = 1, OpTime = DateTime.Now });\n/*\n * INSERT INTO [Users]([Name],[Age],[Gender],[CityId],[OpTime]) VALUES(N&#39;lu&#39;,18,1,1,GETDATE());SELECT @@IDENTITY\n */\n\n\nUser user = new User();\nuser.Name = &quot;lu&quot;;\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = new DateTime(1992, 1, 16);\n\nuser = context.Insert(user);\n/*\n * String @P_0 = &quot;lu&quot;;\n   Gender @P_1 = Man;\n   Int32 @P_2 = 18;\n   Int32 @P_3 = 1;\n   DateTime @P_4 = &quot;1992/1/16 0:00:00&quot;;\n   INSERT INTO [Users]([Name],[Gender],[Age],[CityId],[OpTime]) VALUES(@P_0,@P_1,@P_2,@P_3,@P_4);SELECT @@IDENTITY\n */\n</code></pre><ul>\n<li><strong>Update</strong><br>```C#<br>MsSqlContext context = new MsSqlContext(DbHelper.ConnectionString);</li></ul>\n<p>context.Update&lt;User&gt;(a =&gt; new User() { Name = a.Name, Age = a.Age + 100, Gender = Gender.Man, OpTime = DateTime.Now }, a =&gt; a.Id == 1);<br>/*</p>\n<ul>\n<li>UPDATE [Users] SET [Name]=[Users].[Name],[Age]=([Users].[Age] + 100),[Gender]=1,[OpTime]=GETDATE() WHERE [Users].[Id] = 1<br>*/</li></ul>\n<p>context.Update&lt;User&gt;(a =&gt; new User() { Age = a.Age - 10, OpTime = DateTime.Now }, a =&gt; a.Gender == Gender.Woman);<br>/*</p>\n<ul>\n<li>UPDATE [Users] SET [Age]=([Users].[Age] - 10),[OpTime]=GETDATE() WHERE [Users].[Gender] = 2<br>*/</li></ul>\n<p>User user = new User();<br>user.Id = 1;<br>user.Name = “lu”;<br>user.Age = 28;<br>user.Gender = Gender.Man;<br>user.OpTime = DateTime.Now;</p>\n<p>context.Update(user); //update all columns<br>/*</p>\n<ul>\n<li>String <a href=\"https://github.com/P_0\" title=\"&#64;P_0\" class=\"at-link\">@P_0</a> = “lu”;<br>Gender <a href=\"https://github.com/P_1\" title=\"&#64;P_1\" class=\"at-link\">@P_1</a> = Man;<br>Int32 <a href=\"https://github.com/P_2\" title=\"&#64;P_2\" class=\"at-link\">@P_2</a> = 28;<br>Nullable&lt;Int32&gt; <a href=\"https://github.com/P_3\" title=\"&#64;P_3\" class=\"at-link\">@P_3</a> = NULL;<br>DateTime <a href=\"https://github.com/P_4\" title=\"&#64;P_4\" class=\"at-link\">@P_4</a> = “2016/7/8 11&#58;28&#58;27”;<br>Int32 <a href=\"https://github.com/P_5\" title=\"&#64;P_5\" class=\"at-link\">@P_5</a> = 1;<br>UPDATE [Users] SET [Name]=<a href=\"https://github.com/P_0\" title=\"&#64;P_0\" class=\"at-link\">@P_0</a>,[Gender]=<a href=\"https://github.com/P_1\" title=\"&#64;P_1\" class=\"at-link\">@P_1</a>,[Age]=<a href=\"https://github.com/P_2\" title=\"&#64;P_2\" class=\"at-link\">@P_2</a>,[CityId]=<a href=\"https://github.com/P_3\" title=\"&#64;P_3\" class=\"at-link\">@P_3</a>,[OpTime]=<a href=\"https://github.com/P_4\" title=\"&#64;P_4\" class=\"at-link\">@P_4</a> WHERE [Users].[Id] = <a href=\"https://github.com/P_5\" title=\"&#64;P_5\" class=\"at-link\">@P_5</a><br>*/</li></ul>\n<p>context.TrackEntity(user);//track entity<br>user.Name = user.Name + “1”;<br>context.Update(user);//update the column ‘Name’ only<br>/*</p>\n<ul>\n<li>String <a href=\"https://github.com/P_0\" title=\"&#64;P_0\" class=\"at-link\">@P_0</a> = “lu1”;<br>Int32 <a href=\"https://github.com/P_1\" title=\"&#64;P_1\" class=\"at-link\">@P_1</a> = 1;<br>UPDATE [Users] SET [Name]=<a href=\"https://github.com/P_0\" title=\"&#64;P_0\" class=\"at-link\">@P_0</a> WHERE [Users].[Id] = <a href=\"https://github.com/P_1\" title=\"&#64;P_1\" class=\"at-link\">@P_1</a><br>*/<br>```<ul>\n<li><strong>Delete</strong><br>```C#<br>MsSqlContext context = new MsSqlContext(DbHelper.ConnectionString);</li></ul>\n</li></ul>\n<p>context.Delete&lt;User&gt;(a =&gt; a.Id == 1);<br>/*</p>\n<ul>\n<li>DELETE [Users] WHERE [Users].[Id] = 1<br>*/</li></ul>\n<p>context.Delete&lt;User&gt;(a =&gt; a.Gender == null);<br>/*</p>\n<ul>\n<li>DELETE [Users] WHERE [Users].[Gender] IS NULL<br>*/</li></ul>\n<p>User user = new User();<br>user.Id = 1;<br>context.Delete(user);<br>/*</p>\n<ul>\n<li>Int32 <a href=\"https://github.com/P_0\" title=\"&#64;P_0\" class=\"at-link\">@P_0</a> = 1;<br>DELETE [Users] WHERE [Users].[Id] = <a href=\"https://github.com/P_0\" title=\"&#64;P_0\" class=\"at-link\">@P_0</a><br>*/<br>```</li></ul>\n<p><a href=\"http://www.cnblogs.com/so9527/p/5636216.html\">More…</a></p>\n', '# Chloe\nChloe is a lightweight Object/Relational Mapping(ORM) library.\nThe query interface is similar to LINQ.You can query data like LINQ and do any things(Join Query | Group Query | Aggregate Query | Insert | Batch Update | Batch Delete) by lambda with Chloe.ORM.\n\n**Documentation**: [http://www.52chloe.com](http://www.52chloe.com \"http://www.52chloe.com\")\n.NET交流群：325936847，只要您**愿意**，即可加入\n\n# NuGet Install Command\n\n|              | .NET Framework  | .NET Core  |\n| ------------ | ------------ | ------------ | ------------ |\n| SqlServer  | Install-Package Chloe.SqlServer  | Install-Package ChloeCore.SqlServer  |\n| MySql  | Install-Package Chloe.MySql  |  Install-Package ChloeCore.MySql |\n| Oracle  | Install-Package Chloe.Oracle  |  - |\n| SQLite  | Install-Package Chloe.SQLite  |  Install-Package ChloeCore.SQLite |\n\n# Usage\n* **Entity**\n```C#\npublic enum Gender\n{\n    Man = 1,\n    Woman\n}\n\n[Table(\"Users\")]\npublic class User\n{\n    [Column(IsPrimaryKey = true)]\n    [AutoIncrement]\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public Gender? Gender { get; set; }\n    public int? Age { get; set; }\n    public int? CityId { get; set; }\n    public DateTime? OpTime { get; set; }\n}\n\npublic class City\n{\n    [Column(IsPrimaryKey = true)]\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int ProvinceId { get; set; }\n}\n\npublic class Province\n{\n    [Column(IsPrimaryKey = true)]\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n```\n* **DbContext**\n```C#\nIDbContext context = new MsSqlContext(DbHelper.ConnectionString);\nIQuery<User> q = context.Query<User>();\n```\n* **Query**\n```C#\nIQuery<User> q = context.Query<User>();\nq.Where(a => a.Id > 0).FirstOrDefault();\nq.Where(a => a.Id > 0).ToList();\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).ToList();\nq.Where(a => a.Id > 0).Take(999).OrderBy(a => a.Age).ToList();\n\nq.Where(a => a.Id > 0).OrderBy(a => a.Age).ThenByDesc(a => a.Id).Select(a => new { a.Id, a.Name }).Skip(1).Take(999).ToList();\n/*\n * SELECT TOP (999) [T].[Id] AS [Id],[T].[Name] AS [Name] FROM (SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],ROW_NUMBER() OVER(ORDER BY [Users].[Age] ASC,[Users].[Id] DESC) AS [ROW_NUMBER_0] FROM [Users] AS [Users] WHERE [Users].[Id] > 0) AS [T] WHERE [T].[ROW_NUMBER_0] > 1\n */\n\nq.Where(a => a.Id > 0).Where(a => a.Name.Contains(\"lu\")).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime] \n * FROM [Users] AS [Users] \n * WHERE ([Users].[Id] > 0 AND [Users].[Name] LIKE \'%\' + N\'lu\' + \'%\')\n */\n```\n* **Join Query**\n```C#\nMsSqlContext context = new MsSqlContext(DbHelper.ConnectionString);\n\nIQuery<User> users = context.Query<User>();\nIQuery<City> cities = context.Query<City>();\nIQuery<Province> provinces = context.Query<Province>();\n\nIJoiningQuery<User, City> user_city = users.InnerJoin(cities, (user, city) => user.CityId == city.Id);\nIJoiningQuery<User, City, Province> user_city_province = user_city.InnerJoin(provinces, (user, city, province) => city.ProvinceId == province.Id);\n\nuser_city_province.Select((user, city, province) => new { UserId = user.Id, CityName = city.Name, ProvinceName = province.Name }).Where(a => a.UserId == 1).ToList();\n/*\n * SELECT [Users].[Id] AS [UserId],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] \n * FROM [Users] AS [Users] \n * INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n * INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n * WHERE [Users].[Id] = 1\n */\n \nvar view = user_city_province.Select((user, city, province) => new { User = user, City = city, Province = province });\n \nview.Where(a => a.User.Id == 1).ToList();\n/*\n * SELECT [Users].[Id] AS [Id],[Users].[Name] AS [Name],[Users].[Gender] AS [Gender],[Users].[Age] AS [Age],[Users].[CityId] AS [CityId],[Users].[OpTime] AS [OpTime],[City].[Id] AS [Id0],[City].[Name] AS [Name0],[City].[ProvinceId] AS [ProvinceId],[Province].[Id] AS [Id1],[Province].[Name] AS [Name1] \n * FROM [Users] AS [Users] \n * INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n * INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n * WHERE [Users].[Id] = 1\n */\n \nview.Where(a => a.User.Id == 1).Select(a => new { UserId = a.User.Id, CityName = a.City.Name, ProvinceName = a.Province.Name }).ToList();\n/*\n * SELECT [Users].[Id] AS [UserId],[City].[Name] AS [CityName],[Province].[Name] AS [ProvinceName] \n * FROM [Users] AS [Users] \n * INNER JOIN [City] AS [City] ON [Users].[CityId] = [City].[Id] \n * INNER JOIN [Province] AS [Province] ON [City].[ProvinceId] = [Province].[Id] \n * WHERE [Users].[Id] = 1\n */\n\n/*\n * Chloe also supports left join,right join and full join query.\n * For details please see \'https://github.com/shuxinqin/Chloe/blob/master/src/DotNet/Chloe/IQuery%60.cs\'.\n */\n```\n* **Group Query**\n```C#\nIQuery<User> q = context.Query<User>();\n\nIGroupingQuery<User> g = q.Where(a => a.Id > 0).GroupBy(a => a.Age);\ng = g.Having(a => a.Age > 1 && AggregateFunctions.Count() > 0);\n\ng.Select(a => new { a.Age, Count = AggregateFunctions.Count(), Sum = AggregateFunctions.Sum(a.Age), Max = AggregateFunctions.Max(a.Age), Min = AggregateFunctions.Min(a.Age), Avg = AggregateFunctions.Average(a.Age) }).ToList();\n/*\n * SELECT [Users].[Age] AS [Age],COUNT(1) AS [Count],SUM([Users].[Age]) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Avg] \n * FROM [Users] AS [Users] \n * WHERE [Users].[Id] > 0 \n * GROUP BY [Users].[Age] HAVING ([Users].[Age] > 1 AND COUNT(1) > 0)\n */\n```\n* **Sql Query**\n```C#\ncontext.SqlQuery<User>(\"select Id,Name,Age from Users where Name=@name\", DbParam.Create(\"@name\", \"lu\")).ToList();\ncontext.SqlQuery<int>(\"select Id from Users\").ToList();\n```\n* **Aggregate Query**\n```C#\nIQuery<User> q = context.Query<User>();\n\nq.Select(a => AggregateFunctions.Count()).First();\n/*\n * SELECT TOP (1) COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nq.Select(a => new { Count = AggregateFunctions.Count(), LongCount = AggregateFunctions.LongCount(), Sum = AggregateFunctions.Sum(a.Age), Max = AggregateFunctions.Max(a.Age), Min = AggregateFunctions.Min(a.Age), Average = AggregateFunctions.Average(a.Age) }).First();\n/*\n * SELECT TOP (1) COUNT(1) AS [Count],COUNT_BIG(1) AS [LongCount],SUM([Users].[Age]) AS [Sum],MAX([Users].[Age]) AS [Max],MIN([Users].[Age]) AS [Min],CAST(AVG([Users].[Age]) AS FLOAT) AS [Average] \n * FROM [Users] AS [Users]\n */\n\nvar count = q.Count();\n/*\n * SELECT COUNT(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar longCount = q.LongCount();\n/*\n * SELECT COUNT_BIG(1) AS [C] FROM [Users] AS [Users]\n */\n\nvar sum = q.Sum(a => a.Age);\n/*\n * SELECT SUM([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar max = q.Max(a => a.Age);\n/*\n * SELECT MAX([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar min = q.Min(a => a.Age);\n/*\n * SELECT MIN([Users].[Age]) AS [C] FROM [Users] AS [Users]\n */\n\nvar avg = q.Average(a => a.Age);\n/*\n * SELECT CAST(AVG([Users].[Age]) AS FLOAT) AS [C] FROM [Users] AS [Users]\n */\n```\n* **Method**\n```C#\nIQuery<User> q = context.Query<User>();\n\nvar space = new char[] { \' \' };\n\nDateTime startTime = DateTime.Now;\nDateTime endTime = DateTime.Now.AddDays(1);\nq.Select(a => new\n{\n    Id = a.Id,\n\n    String_Length = (int?)a.Name.Length,//LEN([Users].[Name])\n    Substring = a.Name.Substring(0),//SUBSTRING([Users].[Name],0 + 1,LEN([Users].[Name]))\n    Substring1 = a.Name.Substring(1),//SUBSTRING([Users].[Name],1 + 1,LEN([Users].[Name]))\n    Substring1_2 = a.Name.Substring(1, 2),//SUBSTRING([Users].[Name],1 + 1,2)\n    ToLower = a.Name.ToLower(),//LOWER([Users].[Name])\n    ToUpper = a.Name.ToUpper(),//UPPER([Users].[Name])\n    IsNullOrEmpty = string.IsNullOrEmpty(a.Name),//too long\n    Contains = (bool?)a.Name.Contains(\"s\"),//\n    Trim = a.Name.Trim(),//RTRIM(LTRIM([Users].[Name]))\n    TrimStart = a.Name.TrimStart(space),//LTRIM([Users].[Name])\n    TrimEnd = a.Name.TrimEnd(space),//RTRIM([Users].[Name])\n    StartsWith = (bool?)a.Name.StartsWith(\"s\"),//\n    EndsWith = (bool?)a.Name.EndsWith(\"s\"),//\n\n	DiffYears = DbFunctions.DiffYears(startTime, endTime),//DATEDIFF(YEAR,@P_0,@P_1)\n	DiffMonths = DbFunctions.DiffMonths(startTime, endTime),//DATEDIFF(MONTH,@P_0,@P_1)\n	DiffDays = DbFunctions.DiffDays(startTime, endTime),//DATEDIFF(DAY,@P_0,@P_1)\n	DiffHours = DbFunctions.DiffHours(startTime, endTime),//DATEDIFF(HOUR,@P_0,@P_1)\n	DiffMinutes = DbFunctions.DiffMinutes(startTime, endTime),//DATEDIFF(MINUTE,@P_0,@P_1)\n	DiffSeconds = DbFunctions.DiffSeconds(startTime, endTime),//DATEDIFF(SECOND,@P_0,@P_1)\n	DiffMilliseconds = DbFunctions.DiffMilliseconds(startTime, endTime),//DATEDIFF(MILLISECOND,@P_0,@P_1)\n	//DiffMicroseconds = DbFunctions.DiffMicroseconds(startTime, endTime),//DATEDIFF(MICROSECOND,@P_0,@P_1)  Exception\n\n	/* No longer support method \'DateTime.Subtract(DateTime d)\', instead of using \'DbFunctions.DiffXX\' */\n    //SubtractTotalDays = endTime.Subtract(startTime).TotalDays,//CAST(DATEDIFF(DAY,@P_0,@P_1)\n    //SubtractTotalHours = endTime.Subtract(startTime).TotalHours,//CAST(DATEDIFF(HOUR,@P_0,@P_1)\n    //SubtractTotalMinutes = endTime.Subtract(startTime).TotalMinutes,//CAST(DATEDIFF(MINUTE,@P_0,@P_1)\n    //SubtractTotalSeconds = endTime.Subtract(startTime).TotalSeconds,//CAST(DATEDIFF(SECOND,@P_0,@P_1)\n    //SubtractTotalMilliseconds = endTime.Subtract(startTime).TotalMilliseconds,//CAST(DATEDIFF(MILLISECOND,@P_0,@P_1)\n\n	AddYears = startTime.AddYears(1),//DATEADD(YEAR,1,@P_0)\n	AddMonths = startTime.AddMonths(1),//DATEADD(MONTH,1,@P_0)\n	AddDays = startTime.AddDays(1),//DATEADD(DAY,1,@P_0)\n	AddHours = startTime.AddHours(1),//DATEADD(HOUR,1,@P_0)\n	AddMinutes = startTime.AddMinutes(2),//DATEADD(MINUTE,2,@P_0)\n	AddSeconds = startTime.AddSeconds(120),//DATEADD(SECOND,120,@P_0)\n	AddMilliseconds = startTime.AddMilliseconds(20000),//DATEADD(MILLISECOND,20000,@P_0)\n	\n    Now = DateTime.Now,//GETDATE()\n    UtcNow = DateTime.UtcNow,//GETUTCDATE()\n    Today = DateTime.Today,//CAST(GETDATE() AS DATE)\n    Date = DateTime.Now.Date,//CAST(GETDATE() AS DATE)\n    Year = DateTime.Now.Year,//DATEPART(YEAR,GETDATE())\n    Month = DateTime.Now.Month,//DATEPART(MONTH,GETDATE())\n    Day = DateTime.Now.Day,//DATEPART(DAY,GETDATE())\n    Hour = DateTime.Now.Hour,//DATEPART(HOUR,GETDATE())\n    Minute = DateTime.Now.Minute,//DATEPART(MINUTE,GETDATE())\n    Second = DateTime.Now.Second,//DATEPART(SECOND,GETDATE())\n    Millisecond = DateTime.Now.Millisecond,//DATEPART(MILLISECOND,GETDATE())\n    DayOfWeek = DateTime.Now.DayOfWeek,//(DATEPART(WEEKDAY,GETDATE()) - 1)\n\n    Int_Parse = int.Parse(\"1\"),//CAST(N\'1\' AS INT)\n    Int16_Parse = Int16.Parse(\"11\"),//CAST(N\'11\' AS SMALLINT)\n    Long_Parse = long.Parse(\"2\"),//CAST(N\'2\' AS BIGINT)\n    Double_Parse = double.Parse(\"3\"),//CAST(N\'3\' AS FLOAT)\n    Float_Parse = float.Parse(\"4\"),//CAST(N\'4\' AS REAL)\n    //Decimal_Parse = decimal.Parse(\"5\"),//CAST(N\'5\' AS DECIMAL)  ps: \'Decimal.Parse(string s)\' is not supported now,because we don\'t know the precision and scale information.\n    Guid_Parse = Guid.Parse(\"D544BC4C-739E-4CD3-A3D3-7BF803FCE179\"),//CAST(N\'D544BC4C-739E-4CD3-A3D3-7BF803FCE179\' AS UNIQUEIDENTIFIER) AS [Guid_Parse]\n\n    Bool_Parse = bool.Parse(\"1\"),//CASE WHEN CAST(N\'1\' AS BIT) = CAST(1 AS BIT) THEN CAST(1 AS BIT) WHEN NOT (CAST(N\'1\' AS BIT) = CAST(1 AS BIT)) THEN CAST(0 AS BIT) ELSE NULL END AS [Bool_Parse]\n    DateTime_Parse = DateTime.Parse(\"1992-1-16\"),//CAST(N\'1992-1-16\' AS DATETIME) AS [DateTime_Parse]\n\n    B = a.Age == null ? false : a.Age > 1,\n}).ToList();\n```\n* **Insert**\n```C#\nIDbContext context = new MsSqlContext(DbHelper.ConnectionString);\n\n//return the key value\nint id = (int)context.Insert<User>(() => new User() { Name = \"lu\", Age = 18, Gender = Gender.Man, CityId = 1, OpTime = DateTime.Now });\n/*\n * INSERT INTO [Users]([Name],[Age],[Gender],[CityId],[OpTime]) VALUES(N\'lu\',18,1,1,GETDATE());SELECT @@IDENTITY\n */\n\n \nUser user = new User();\nuser.Name = \"lu\";\nuser.Age = 18;\nuser.Gender = Gender.Man;\nuser.CityId = 1;\nuser.OpTime = new DateTime(1992, 1, 16);\n\nuser = context.Insert(user);\n/*\n * String @P_0 = \"lu\";\n   Gender @P_1 = Man;\n   Int32 @P_2 = 18;\n   Int32 @P_3 = 1;\n   DateTime @P_4 = \"1992/1/16 0:00:00\";\n   INSERT INTO [Users]([Name],[Gender],[Age],[CityId],[OpTime]) VALUES(@P_0,@P_1,@P_2,@P_3,@P_4);SELECT @@IDENTITY\n */\n```\n* **Update**\n```C#\nMsSqlContext context = new MsSqlContext(DbHelper.ConnectionString);\n\ncontext.Update<User>(a => new User() { Name = a.Name, Age = a.Age + 100, Gender = Gender.Man, OpTime = DateTime.Now }, a => a.Id == 1);\n/*\n * UPDATE [Users] SET [Name]=[Users].[Name],[Age]=([Users].[Age] + 100),[Gender]=1,[OpTime]=GETDATE() WHERE [Users].[Id] = 1\n */\n\ncontext.Update<User>(a => new User() { Age = a.Age - 10, OpTime = DateTime.Now }, a => a.Gender == Gender.Woman);\n/*\n * UPDATE [Users] SET [Age]=([Users].[Age] - 10),[OpTime]=GETDATE() WHERE [Users].[Gender] = 2\n */\n\n\nUser user = new User();\nuser.Id = 1;\nuser.Name = \"lu\";\nuser.Age = 28;\nuser.Gender = Gender.Man;\nuser.OpTime = DateTime.Now;\n\ncontext.Update(user); //update all columns\n/*\n * String @P_0 = \"lu\";\n   Gender @P_1 = Man;\n   Int32 @P_2 = 28;\n   Nullable<Int32> @P_3 = NULL;\n   DateTime @P_4 = \"2016/7/8 11:28:27\";\n   Int32 @P_5 = 1;\n   UPDATE [Users] SET [Name]=@P_0,[Gender]=@P_1,[Age]=@P_2,[CityId]=@P_3,[OpTime]=@P_4 WHERE [Users].[Id] = @P_5\n */\n\ncontext.TrackEntity(user);//track entity\nuser.Name = user.Name + \"1\";\ncontext.Update(user);//update the column \'Name\' only\n/*\n * String @P_0 = \"lu1\";\n   Int32 @P_1 = 1;\n   UPDATE [Users] SET [Name]=@P_0 WHERE [Users].[Id] = @P_1\n */\n```\n* **Delete**\n```C#\nMsSqlContext context = new MsSqlContext(DbHelper.ConnectionString);\n\ncontext.Delete<User>(a => a.Id == 1);\n/*\n * DELETE [Users] WHERE [Users].[Id] = 1\n */\n\ncontext.Delete<User>(a => a.Gender == null);\n/*\n * DELETE [Users] WHERE [Users].[Gender] IS NULL\n */\n \n \nUser user = new User();\nuser.Id = 1;\ncontext.Delete(user);\n/*\n * Int32 @P_0 = 1;\n   DELETE [Users] WHERE [Users].[Id] = @P_0\n */\n```\n\n[More...](http://www.cnblogs.com/so9527/p/5636216.html)\n', '2016-12-04 13:13:16', '2016-12-04 13:24:16', '0', null);
INSERT INTO `wikidocument` VALUES ('3325873886481874944', 'Chloe-性能评测', '性能测评', 'Chloe-性能评测', '<h1 id=\"h1-u6027u80FDu8BC4u6D4B\"><a name=\"性能评测\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>性能评测</h1><p>测评对象：EntityFramework6.1、Dapper 和 Chloe.ORM。<br><strong>1.映射能力</strong><br>一次查50万条数据，总共测试5轮，测试结果数据如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Chloe.IQuery(ms)</th>\n<th>Chloe.SqlQuery(ms)</th>\n<th>Dapper.Query(ms)</th>\n<th>EF.IQueryable(ms)</th>\n<th>EF.SqlQuery(ms)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第1轮</td>\n<td>6976</td>\n<td>7170</td>\n<td>7948</td>\n<td>7704</td>\n<td>7744</td>\n</tr>\n<tr>\n<td>第2轮</td>\n<td>7357</td>\n<td>6853</td>\n<td>8410</td>\n<td>8328</td>\n<td>7783</td>\n</tr>\n<tr>\n<td>第3轮</td>\n<td>7610</td>\n<td>7833</td>\n<td>8107</td>\n<td>9795</td>\n<td>8706</td>\n</tr>\n<tr>\n<td>第4轮</td>\n<td>7296</td>\n<td>6957</td>\n<td>7760</td>\n<td>8643</td>\n<td>7873</td>\n</tr>\n<tr>\n<td>第5轮</td>\n<td>9636</td>\n<td>6705</td>\n<td>8805</td>\n<td>8946</td>\n<td>8544</td>\n</tr>\n<tr>\n<td><strong>平均</strong></td>\n<td><strong>7775</strong></td>\n<td><strong>7103</strong></td>\n<td><strong>8206</strong></td>\n<td><strong>8683</strong></td>\n<td><strong>8130</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>2.查询能力</strong><br>一次查询只查一条数据，循环执行20000次查询。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Chloe.IQuery(ms)</th>\n<th>Chloe.SqlQuery(ms)</th>\n<th>Dapper.Query(ms)</th>\n<th>EF.IQueryable(ms)</th>\n<th>EF.SqlQuery(ms)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第1轮</td>\n<td>15281</td>\n<td>11858</td>\n<td>11981</td>\n<td>31394</td>\n<td>19309</td>\n</tr>\n<tr>\n<td>第2轮</td>\n<td>15194</td>\n<td>12177</td>\n<td>12314</td>\n<td>31464</td>\n<td>18161</td>\n</tr>\n<tr>\n<td>第3轮</td>\n<td>15967</td>\n<td>12348</td>\n<td>12366</td>\n<td>31082</td>\n<td>18030</td>\n</tr>\n<tr>\n<td>第4轮</td>\n<td>15371</td>\n<td>11793</td>\n<td>12479</td>\n<td>32314</td>\n<td>18356</td>\n</tr>\n<tr>\n<td>第5轮</td>\n<td>15350</td>\n<td>11921</td>\n<td>11937</td>\n<td>35023</td>\n<td>18356</td>\n</tr>\n<tr>\n<td><strong>平均</strong></td>\n<td><strong>15411</strong></td>\n<td><strong>12019</strong></td>\n<td><strong>12215</strong></td>\n<td><strong>32255</strong></td>\n<td><strong>18442</strong></td>\n</tr>\n</tbody>\n</table>\n<p>以上测试，EF 均使用了 AsNoTracking。测试效果在不同机子可能会有略微差别，以上数据仅供参考。<br>数据来源：<a href=\"http://www.cnblogs.com/so9527/p/5674498.html\" title=\"http://www.cnblogs.com/so9527/p/5674498.html\">http://www.cnblogs.com/so9527/p/5674498.html</a></p>\n', '# 性能评测\n测评对象：EntityFramework6.1、Dapper 和 Chloe.ORM。\n**1.映射能力**\n一次查50万条数据，总共测试5轮，测试结果数据如下：\n\n|   | Chloe.IQuery(ms)  | Chloe.SqlQuery(ms)  | Dapper.Query(ms)  | EF.IQueryable(ms)  | EF.SqlQuery(ms)  |\n| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |\n| 第1轮  | 6976 | 7170  | 7948  | 7704  | 7744  |\n| 第2轮  | 7357  | 6853  | 8410  | 8328  | 7783  |\n| 第3轮  | 7610  | 7833  | 8107  | 9795  | 8706 |\n| 第4轮  | 7296  | 6957  | 7760  | 8643  | 7873  |\n| 第5轮  | 9636  | 6705  | 8805  | 8946  | 8544  |\n| **平均**  | **7775**  | **7103**  | **8206**  | **8683**  | **8130**  |\n\n**2.查询能力**\n一次查询只查一条数据，循环执行20000次查询。\n\n|   | Chloe.IQuery(ms)  | Chloe.SqlQuery(ms)  | Dapper.Query(ms)  | EF.IQueryable(ms)  | EF.SqlQuery(ms)  |\n| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |\n| 第1轮  | 15281 | 11858  | 11981  | 31394  | 19309  |\n| 第2轮  | 15194  | 12177  | 12314  | 31464  | 18161  |\n| 第3轮  | 15967  | 12348  | 12366  | 31082  | 18030 |\n| 第4轮  | 15371  | 11793  | 12479  | 32314  | 18356  |\n| 第5轮  | 15350  | 11921  | 11937  | 35023  | 18356  |\n| **平均**  | **15411**  | **12019**  | **12215**  | **32255**  | **18442**  |\n\n以上测试，EF 均使用了 AsNoTracking。测试效果在不同机子可能会有略微差别，以上数据仅供参考。\n数据来源：[http://www.cnblogs.com/so9527/p/5674498.html](http://www.cnblogs.com/so9527/p/5674498.html \"http://www.cnblogs.com/so9527/p/5674498.html\")', '2016-12-04 15:55:27', '2016-12-04 16:09:46', '0', null);

-- ----------------------------
-- Table structure for wikimenuitem
-- ----------------------------
DROP TABLE IF EXISTS `wikimenuitem`;
CREATE TABLE `wikimenuitem` (
  `Id` varchar(50) NOT NULL,
  `ParentId` varchar(50) DEFAULT NULL,
  `Name` varchar(100) DEFAULT NULL,
  `DocumentId` varchar(100) DEFAULT NULL,
  `SortCode` int(11) DEFAULT NULL,
  `IsEnabled` bit(1) NOT NULL,
  `CreationTime` datetime NOT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB DEFAULT CHARSET=gbk;

-- ----------------------------
-- Records of wikimenuitem
-- ----------------------------
INSERT INTO `wikimenuitem` VALUES ('0229cd4475014678aab6a2a30055df4e', '4de0d7a7609646db97ed165a20116add', '基本查询', '3325155613347938304', '4', '', '2016-12-02 16:25:19');
INSERT INTO `wikimenuitem` VALUES ('0581d42795d048c7bf6f070ab9abbe04', '0aa3d30328fd49d98641999f8c4393a1', 'DbFunctions', '3324788085501198336', '8', '', '2016-12-01 16:02:12');
INSERT INTO `wikimenuitem` VALUES ('0622103789d04583ba05bdfb7c5958ac', '4de0d7a7609646db97ed165a20116add', '聚合查询', '3325155763537575936', '7', '', '2016-12-02 16:26:00');
INSERT INTO `wikimenuitem` VALUES ('095ee201e96a40c38919b681dabb2b0f', 'd133d6a8b6064de6af14851bbbf3b6b1', '聚合查询', '3325149550670249984', '7', '', '2016-12-02 16:18:01');
INSERT INTO `wikimenuitem` VALUES ('0aa3d30328fd49d98641999f8c4393a1', null, '接口一览', null, '1', '', '2016-12-01 15:08:42');
INSERT INTO `wikimenuitem` VALUES ('0c8fdabbb00d499bbb8b7c40823c257b', '4de0d7a7609646db97ed165a20116add', '实体定义', '3325155511531208704', '2', '', '2016-12-02 16:24:33');
INSERT INTO `wikimenuitem` VALUES ('0d195df806d04c3582e7bc839ea94876', 'e7e1cfb2856d492faeaadc8e2962ac76', '更新数据', '3325146391176544256', '10', '', '2016-12-02 15:53:01');
INSERT INTO `wikimenuitem` VALUES ('0dad2c1700774046bddc3c72c39324ef', '6e5b779e849e459f957f3abef2a277e6', '事务', '3324837890621440000', '13', '', '2016-12-01 19:22:30');
INSERT INTO `wikimenuitem` VALUES ('111d5aafd0e3495ab8d1cd6d590eeddd', 'e7e1cfb2856d492faeaadc8e2962ac76', '聚合查询', '3325146192995680256', '7', '', '2016-12-02 15:52:08');
INSERT INTO `wikimenuitem` VALUES ('1176ff41a980443dbc6b12b5383564f8', '6e5b779e849e459f957f3abef2a277e6', '插入数据', '3324837619082199040', '9', '', '2016-12-01 19:21:26');
INSERT INTO `wikimenuitem` VALUES ('1887d73bc1b7487ea1b6dbaf676a7403', 'e7e1cfb2856d492faeaadc8e2962ac76', '实体特性', '3325145692988506112', '1', '', '2016-12-02 15:46:40');
INSERT INTO `wikimenuitem` VALUES ('1cb702e488544a13bb885f2dad051a66', 'd133d6a8b6064de6af14851bbbf3b6b1', '更新数据', '3325149712301948928', '10', '', '2016-12-02 16:18:42');
INSERT INTO `wikimenuitem` VALUES ('1d0c549780cb453a8da9d0f496808f3c', '6e5b779e849e459f957f3abef2a277e6', '存储过程', '3324837828717707264', '12', '', '2016-12-01 19:22:17');
INSERT INTO `wikimenuitem` VALUES ('1d57b23aeb4141e5b903f65442535522', 'd133d6a8b6064de6af14851bbbf3b6b1', '多表连接', '3325149375134433280', '5', '', '2016-12-02 16:17:32');
INSERT INTO `wikimenuitem` VALUES ('2306b7b2c026499eb839ed212ce027f8', 'e7e1cfb2856d492faeaadc8e2962ac76', '插入数据', '3325146327683170304', '9', '', '2016-12-02 15:52:42');
INSERT INTO `wikimenuitem` VALUES ('2823256324a14d2094a34b7087393e4c', '6e5b779e849e459f957f3abef2a277e6', '常用函数', '3325141727961939968', '14', '', '2016-12-02 15:27:14');
INSERT INTO `wikimenuitem` VALUES ('29b71a2ab28346e4ae8c2fdee32265e0', 'd133d6a8b6064de6af14851bbbf3b6b1', '删除数据', '3325149761299808256', '11', '', '2016-12-02 16:18:56');
INSERT INTO `wikimenuitem` VALUES ('2e07e5f795d84ffba9c49b5882d430d5', '6e5b779e849e459f957f3abef2a277e6', 'Sql查询', '3324834901575860224', '8', '', '2016-12-01 19:20:35');
INSERT INTO `wikimenuitem` VALUES ('313a300c33444764bb19ff0b3b575ed9', '0aa3d30328fd49d98641999f8c4393a1', 'IOrderedQuery', '3324761124187930624', '3', '', '2016-12-01 15:10:07');
INSERT INTO `wikimenuitem` VALUES ('31844a305baa4b5f90c22d253af18b91', 'd133d6a8b6064de6af14851bbbf3b6b1', '事务', '3325150155606327296', '13', '', '2016-12-02 16:19:27');
INSERT INTO `wikimenuitem` VALUES ('324ab3ef4a644103aa9b098141f324e2', 'e7e1cfb2856d492faeaadc8e2962ac76', '事务', '3325146606914764800', '13', '', '2016-12-02 15:53:55');
INSERT INTO `wikimenuitem` VALUES ('39f15c0e90684f17aa20a603135e26cf', '4de0d7a7609646db97ed165a20116add', '实体特性', '3325155467776229376', '1', '', '2016-12-02 16:24:10');
INSERT INTO `wikimenuitem` VALUES ('3d62622a211c4fe58e7a0ffdd1216330', '6e5b779e849e459f957f3abef2a277e6', '基本查询', '3324802610879266816', '4', '', '2016-12-01 17:22:07');
INSERT INTO `wikimenuitem` VALUES ('438b113e0fdd4ad1a2369980c20767bf', '0aa3d30328fd49d98641999f8c4393a1', 'IJoiningQuery', '3324766621741875200', '5', '', '2016-12-01 15:11:14');
INSERT INTO `wikimenuitem` VALUES ('45dbafd1df34415483f7d8856a887908', '6e5b779e849e459f957f3abef2a277e6', '实体特性', '3324793835434803200', '1', '', '2016-12-01 16:54:57');
INSERT INTO `wikimenuitem` VALUES ('45f9b44dc1204faba11b12b134f03137', 'd133d6a8b6064de6af14851bbbf3b6b1', '存储过程', '3325150100572864512', '12', '', '2016-12-02 16:19:12');
INSERT INTO `wikimenuitem` VALUES ('4612e6b3b38d4efe864af6ecb64068e3', 'e7e1cfb2856d492faeaadc8e2962ac76', '实体定义', '3325145777671503872', '2', '', '2016-12-02 15:50:00');
INSERT INTO `wikimenuitem` VALUES ('4880ec5f1bbd46f59df171675c9a5c7a', null, '其它', null, '7', '', '2016-12-04 16:09:06');
INSERT INTO `wikimenuitem` VALUES ('4de0d7a7609646db97ed165a20116add', null, 'SQLite', null, '5', '', '2016-12-02 15:30:33');
INSERT INTO `wikimenuitem` VALUES ('4eb47e95f65b4256b0a398c2f6431fb3', '0aa3d30328fd49d98641999f8c4393a1', 'IDbSession', '3324773693170647040', '6', '', '2016-12-01 15:11:31');
INSERT INTO `wikimenuitem` VALUES ('50b8e57344444f14867bdedabe14337d', 'd133d6a8b6064de6af14851bbbf3b6b1', '插入数据', '3325149662540726272', '9', '', '2016-12-02 16:18:30');
INSERT INTO `wikimenuitem` VALUES ('5732a9242e30414cabe6e48a3bab4fbf', 'e7e1cfb2856d492faeaadc8e2962ac76', '常用函数', '3325146654268456960', '14', '', '2016-12-02 15:54:08');
INSERT INTO `wikimenuitem` VALUES ('58aa3699bc0442f9b9bbb820063f1c83', 'e7e1cfb2856d492faeaadc8e2962ac76', '分组查询', '3325146123546394624', '6', '', '2016-12-02 15:51:50');
INSERT INTO `wikimenuitem` VALUES ('5af4040dbfed49018af695a95fc66966', '6e5b779e849e459f957f3abef2a277e6', '分组查询', '3324832206215446528', '6', '', '2016-12-01 19:20:01');
INSERT INTO `wikimenuitem` VALUES ('5b20c56fd04340baa95015bddd4836ff', '4de0d7a7609646db97ed165a20116add', '创建DbContext', '3325155568988979200', '3', '', '2016-12-02 16:24:48');
INSERT INTO `wikimenuitem` VALUES ('5c56cd25bbca40fb8802e4437426db92', '4de0d7a7609646db97ed165a20116add', '分组查询', '3325155712383844352', '6', '', '2016-12-02 16:25:47');
INSERT INTO `wikimenuitem` VALUES ('6bc7f42dda8d463aad0de7979103870b', '0aa3d30328fd49d98641999f8c4393a1', 'IQuery', '3324760360224817152', '2', '', '2016-12-01 15:09:49');
INSERT INTO `wikimenuitem` VALUES ('6cd0d1e9c74c41cd9a912eaaa51b2f88', '4de0d7a7609646db97ed165a20116add', '存储过程', '3325155999823691776', '12', '', '2016-12-02 16:27:06');
INSERT INTO `wikimenuitem` VALUES ('6e5b779e849e459f957f3abef2a277e6', null, 'SqlServer', null, '2', '', '2016-11-19 00:00:00');
INSERT INTO `wikimenuitem` VALUES ('6edc1a9ad849481f882a1fc9eb469845', 'e7e1cfb2856d492faeaadc8e2962ac76', '创建DbContext', '3325145866628497408', '3', '', '2016-12-02 15:50:33');
INSERT INTO `wikimenuitem` VALUES ('6f10fffb4abc449dbe20903608f5ca97', 'd133d6a8b6064de6af14851bbbf3b6b1', '创建DbContext', '3325149282020884480', '3', '', '2016-12-02 16:16:59');
INSERT INTO `wikimenuitem` VALUES ('7444ce78fe1a46ddb06b640d03003fb8', '0aa3d30328fd49d98641999f8c4393a1', 'IDbContext', '3324756912431431680', '1', '', '2016-12-01 15:09:24');
INSERT INTO `wikimenuitem` VALUES ('7b844f2b778c403e90b7e3d7b97a6518', 'bdc06740283949158e793a1c0dcff031', '复杂查询', '3325507078541279232', '1', '', '2016-12-03 16:09:22');
INSERT INTO `wikimenuitem` VALUES ('8066e9effe6d40159ca87018031f9698', 'e7e1cfb2856d492faeaadc8e2962ac76', 'Sql查询', '3325146263711645696', '8', '', '2016-12-02 15:52:26');
INSERT INTO `wikimenuitem` VALUES ('823dc8efd03643dca96bb52f4c34a21f', '4de0d7a7609646db97ed165a20116add', '事务', '3325156054349643776', '13', '', '2016-12-02 16:27:18');
INSERT INTO `wikimenuitem` VALUES ('8659eea519c54e4e9cbd2b7bb81321c4', 'd133d6a8b6064de6af14851bbbf3b6b1', '实体特性', '3325149150596562944', '1', '', '2016-12-02 16:16:15');
INSERT INTO `wikimenuitem` VALUES ('8c0d3eae2b284c9196d3eed666c2b165', 'e7e1cfb2856d492faeaadc8e2962ac76', '删除数据', '3325146449968103424', '11', '', '2016-12-02 15:53:16');
INSERT INTO `wikimenuitem` VALUES ('920aac90c3aa4d458359de132448b663', 'e7e1cfb2856d492faeaadc8e2962ac76', '基本查询', '3325145930688102400', '4', '', '2016-12-02 15:51:20');
INSERT INTO `wikimenuitem` VALUES ('93f4b30e2b9f45f1bdade3549923e8ef', '4de0d7a7609646db97ed165a20116add', '常用函数', '3325156110087749632', '14', '', '2016-12-02 16:27:32');
INSERT INTO `wikimenuitem` VALUES ('9754b3651f4d40d5b07aa265aeb9666d', '4de0d7a7609646db97ed165a20116add', '插入数据', '3325155856416243712', '9', '', '2016-12-02 16:26:25');
INSERT INTO `wikimenuitem` VALUES ('99d90325ce1647a3828cfadcfb025292', '0aa3d30328fd49d98641999f8c4393a1', 'AggregateFunctions', '3324786622028840960', '7', '', '2016-12-01 16:01:59');
INSERT INTO `wikimenuitem` VALUES ('9acd51b68efa4bfa83fa30b077fca917', '6e5b779e849e459f957f3abef2a277e6', '删除数据', '3324837762527395840', '11', '', '2016-12-01 19:22:04');
INSERT INTO `wikimenuitem` VALUES ('a8d13bd653e54496aeab28f6eec4696a', 'd133d6a8b6064de6af14851bbbf3b6b1', '分组查询', '3325149450531241984', '6', '', '2016-12-02 16:17:48');
INSERT INTO `wikimenuitem` VALUES ('ac0095b2fbda4731a2efdcb942320b45', '4de0d7a7609646db97ed165a20116add', '删除数据', '3325155947889819648', '11', '', '2016-12-02 16:26:53');
INSERT INTO `wikimenuitem` VALUES ('b17f31ef1a434b419bbadc2f35557e9b', '4de0d7a7609646db97ed165a20116add', '更新数据', '3325155899147812864', '10', '', '2016-12-02 16:26:42');
INSERT INTO `wikimenuitem` VALUES ('b3303381a5ad4f818f30e1912bdae33d', '6e5b779e849e459f957f3abef2a277e6', '创建DbContext', '3324798423210655744', '3', '', '2016-12-01 16:55:43');
INSERT INTO `wikimenuitem` VALUES ('b4958b8839df4ed48cc7900fe98ff3a4', '4880ec5f1bbd46f59df171675c9a5c7a', '性能评测', '3325873886481874944', '1', '', '2016-12-04 16:09:32');
INSERT INTO `wikimenuitem` VALUES ('b58ca60e2f75482dbd0982ae04d8fc73', '4de0d7a7609646db97ed165a20116add', 'Sql查询', '3325155811822403584', '8', '', '2016-12-02 16:26:12');
INSERT INTO `wikimenuitem` VALUES ('b7eeba275f6a4243aa0f0a382590f07a', '6e5b779e849e459f957f3abef2a277e6', '实体定义', '3324795934096752640', '2', '', '2016-12-01 16:55:20');
INSERT INTO `wikimenuitem` VALUES ('b992ac53aba142e3b8fc8e9b7e5b5503', 'd133d6a8b6064de6af14851bbbf3b6b1', '常用函数', '3325150214624378880', '14', '', '2016-12-02 16:19:42');
INSERT INTO `wikimenuitem` VALUES ('bdc06740283949158e793a1c0dcff031', null, '使用进阶', null, '6', '', '2016-12-03 16:08:55');
INSERT INTO `wikimenuitem` VALUES ('bf5286c0067f42ffb18f58103a8cbe22', 'e7e1cfb2856d492faeaadc8e2962ac76', '存储过程', '3325146546785222656', '12', '', '2016-12-02 15:53:31');
INSERT INTO `wikimenuitem` VALUES ('c5af1363d0c24b3cba2c8cbcd4df2edb', 'bdc06740283949158e793a1c0dcff031', '动态排序', '3325512137098395648', '2', '', '2016-12-03 16:09:36');
INSERT INTO `wikimenuitem` VALUES ('c65aff6f48a640caa94771b74ea744d9', '6e5b779e849e459f957f3abef2a277e6', '更新数据', '3324837696316112896', '10', '', '2016-12-01 19:21:49');
INSERT INTO `wikimenuitem` VALUES ('c912268134834507a6fdb9eb7dd7a966', '4de0d7a7609646db97ed165a20116add', '多表连接', '3325155661880229888', '5', '', '2016-12-02 16:25:33');
INSERT INTO `wikimenuitem` VALUES ('c91e639b61c34936a65b31008bc65136', 'd133d6a8b6064de6af14851bbbf3b6b1', '基本查询', '3325149327977873408', '4', '', '2016-12-02 16:17:17');
INSERT INTO `wikimenuitem` VALUES ('c9957c52ce8e4baf8f1b680eebfb6cf0', '6e5b779e849e459f957f3abef2a277e6', '多表连接', '3324809512287731712', '5', '', '2016-12-01 18:11:29');
INSERT INTO `wikimenuitem` VALUES ('ca12fc2048f04775846e77a0a955dc32', '6e5b779e849e459f957f3abef2a277e6', '聚合查询', '3324833832581988352', '7', '', '2016-12-01 19:20:20');
INSERT INTO `wikimenuitem` VALUES ('d133d6a8b6064de6af14851bbbf3b6b1', null, 'Oracle', null, '4', '', '2016-11-26 21:30:51');
INSERT INTO `wikimenuitem` VALUES ('d322377ea275446bb400069b5ee233cb', 'e7e1cfb2856d492faeaadc8e2962ac76', '多表连接', '3325146061768491008', '5', '', '2016-12-02 15:51:35');
INSERT INTO `wikimenuitem` VALUES ('e70a8a96f7dc4c058d0b13da3f5fac23', '0aa3d30328fd49d98641999f8c4393a1', 'IGroupingQuery', '3324765409034371072', '4', '', '2016-12-01 15:10:57');
INSERT INTO `wikimenuitem` VALUES ('e70ed5a2386e4bba813281b21728d6a6', 'd133d6a8b6064de6af14851bbbf3b6b1', '实体定义', '3325149206355640320', '2', '', '2016-12-02 16:16:33');
INSERT INTO `wikimenuitem` VALUES ('e7e1cfb2856d492faeaadc8e2962ac76', null, 'MySql', null, '3', '', '2016-11-19 00:00:00');
INSERT INTO `wikimenuitem` VALUES ('ff3e67c39f884e4791e06379513fee8c', 'd133d6a8b6064de6af14851bbbf3b6b1', 'Sql查询', '3325149605842124800', '8', '', '2016-12-02 16:18:15');

-- ----------------------------
-- Procedure structure for Proc_Test
-- ----------------------------
DROP PROCEDURE IF EXISTS `Proc_Test`;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` PROCEDURE `Proc_Test`(in id1 int,in name1 varchar(100),out age int,out name2 varchar(100))
begin 
set age =100;
set name2 ='so';
select id1 as ID,name1 as `NAME`;
end
;;
DELIMITER ;

-- ----------------------------
-- Procedure structure for Proc_Test1
-- ----------------------------
DROP PROCEDURE IF EXISTS `Proc_Test1`;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` PROCEDURE `Proc_Test1`(in id1 int)
begin 
-- set age =100;
-- set name2 ='so';
-- select id1 as ID,name1 as `NAME`;
end
;;
DELIMITER ;
